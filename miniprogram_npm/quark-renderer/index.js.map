{"version":3,"sources":["index.js","lib\\quark-renderer.js","lib\\core\\utils\\guid.js","lib\\core\\env.js","lib\\event\\QRendererEventHandler.js","lib\\core\\utils\\data_structure_util.js","lib\\graphic\\constants.js","lib\\core\\utils\\class_util.js","lib\\core\\utils\\vector.js","lib\\core\\utils\\event_util.js","lib\\event\\Eventful.js","lib\\core\\utils\\four_points_transform.js","lib\\event\\MultiDragDrop.js","lib\\event\\GestureMgr.js","lib\\Storage.js","lib\\graphic\\Group.js","lib\\graphic\\Element.js","lib\\graphic\\transform\\Transformable.js","lib\\core\\utils\\matrix.js","lib\\animation\\Animatable.js","lib\\animation\\AnimationProcess.js","lib\\animation\\Track.js","lib\\animation\\Timeline.js","lib\\animation\\utils\\easing.js","lib\\core\\utils\\color_util.js","lib\\core\\LRU.js","lib\\graphic\\transform\\BoundingRect.js","lib\\core\\utils\\timsort.js","lib\\CanvasPainter.js","lib\\animation\\utils\\request_animation_frame.js","lib\\config.js","lib\\CanvasLayer.js","lib\\core\\utils\\canvas_util.js","lib\\graphic\\Style.js","lib\\graphic\\utils\\fix_shadow.js","lib\\graphic\\Pattern.js","lib\\graphic\\Image.js","lib\\graphic\\Displayable.js","lib\\graphic\\RectText.js","lib\\graphic\\utils\\text_util.js","lib\\core\\contain\\text.js","lib\\graphic\\utils\\image.js","lib\\graphic\\utils\\round_rect.js","lib\\animation\\GlobalAnimationMgr.js","lib\\event\\DomEventProxy.js","lib\\export.js","lib\\core\\utils\\path_util.js","lib\\graphic\\Path.js","lib\\graphic\\PathProxy.js","lib\\core\\utils\\curve_util.js","lib\\core\\utils\\bbox_util.js","lib\\core\\contain\\path.js","lib\\core\\contain\\line.js","lib\\core\\contain\\cubic.js","lib\\core\\contain\\quadratic.js","lib\\core\\contain\\arc.js","lib\\core\\contain\\radian_util.js","lib\\core\\contain\\winding_line.js","lib\\core\\utils\\transform_path.js","lib\\svg\\SVGParser.js","lib\\graphic\\Text.js","lib\\graphic\\shape\\Circle.js","lib\\graphic\\shape\\Rect.js","lib\\graphic\\utils\\sub_pixel_optimize.js","lib\\graphic\\shape\\Ellipse.js","lib\\graphic\\shape\\Line.js","lib\\graphic\\shape\\Polygon.js","lib\\graphic\\utils\\poly.js","lib\\graphic\\utils\\smooth_spline.js","lib\\graphic\\utils\\smooth_bezier.js","lib\\graphic\\shape\\Polyline.js","lib\\graphic\\gradient\\LinearGradient.js","lib\\graphic\\gradient\\Gradient.js","lib\\graphic\\CompoundPath.js","lib\\graphic\\IncrementalDisplayable.js","lib\\graphic\\shape\\Arc.js","lib\\graphic\\shape\\BezierCurve.js","lib\\graphic\\shape\\Droplet.js","lib\\graphic\\shape\\Heart.js","lib\\graphic\\shape\\Isogon.js","lib\\graphic\\shape\\Ring.js","lib\\graphic\\shape\\Rose.js","lib\\graphic\\shape\\Sector.js","lib\\graphic\\utils\\fix_clip_with_shadow.js","lib\\graphic\\shape\\Star.js","lib\\graphic\\shape\\Trochoid.js","lib\\graphic\\gradient\\RadialGradient.js","lib\\svg\\svg.js","lib\\svg\\graphic.js","lib\\svg\\core.js","lib\\svg\\SVGPainter.js","lib\\core\\utils\\array_diff2.js","lib\\svg\\helper\\GradientManager.js","lib\\svg\\helper\\Definable.js","lib\\svg\\helper\\ClippathManager.js","lib\\svg\\helper\\ShadowManager.js","lib\\vml\\vml.js","lib\\vml\\graphic.js","lib\\vml\\core.js","lib\\vml\\VMLPainter.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,AENA,AHSA;ADIA,AGTA,ADGA,AENA,AHSA;ADIA,AGTA,ADGA,AENA,AHSA;ADIA,AGTA,AENA,AHSA,AENA,AHSA;ADIA,AGTA,AENA,AHSA,AENA,AHSA;ADIA,AGTA,AENA,ADGA,AHSA;ADIA,AGTA,AENA,ADGA,AENA,ALeA;ADIA,AGTA,AENA,ADGA,AENA,ALeA;ADIA,AGTA,AENA,ADGA,AENA,ALeA;AELA,AIZA,AFMA,ADGA,AENA,ALeA;AELA,AIZA,AFMA,ADGA,AENA,ALeA;AELA,AIZA,AFMA,ADGA,AENA,ALeA;AELA,AIZA,AFMA,AGTA,AJYA,AENA,ALeA;AELA,AIZA,AFMA,AGTA,AJYA,AENA,ALeA;AELA,AIZA,AFMA,AGTA,AJYA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,ADGA,AJYA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,ADGA,AJYA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,ADGA,AJYA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,ADGA,AENA,ANkBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,ADGA,AENA,ANkBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,ADGA,AENA,ANkBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,ANkBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,ANkBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,ANkBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AENA,ARwBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AENA,ARwBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AENA,ARwBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AENA,ALeA;AELA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AENA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AENA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AENA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AENA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AWjCA,AT2BA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AWjCA,AT2BA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AWjCA,AT2BA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,ALeA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AHSA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AXiCA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,AhBgDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,AhBgDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,AhBgDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AjBmDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AjBmDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AjBmDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,ACHA,AlBsDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,ACHA,AlBsDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,ACHA,AlBsDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AlBsDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AlBsDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AlBsDA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,ApB4DA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,ApB4DA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,ApB4DA,AIZA,AFMA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,ApB4DA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,ApB4DA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,ApB4DA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AWjCA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AV8BA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;AatCA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,AJYA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,AJYA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,AJYA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A2BhFA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,AIZA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AT2BA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AMlBA,ACHA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AkBtDA,A3BiFA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AkBtDA,A3BiFA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AkBtDA,A3BiFA,AoB5DA,AT2BA,AhBgDA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AkBtDA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AkBtDA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AkBtDA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AoB5DA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AoB5DA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AoB5DA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AqB/DA,ADGA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AqB/DA,ADGA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AYpCA,ADGA,AqB/DA,ADGA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AOrBA,ALeA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AFMA,A3BiFA,AoB5DA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AjCmGA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AKfA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AKfA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,AtBkEA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AKfA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AKfA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AKfA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AiBnDA,AKfA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,AFMA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,AFMA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,AFMA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AENA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AENA,AOrBA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,AzB2EA,AiBnDA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AENA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AiCnGA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,AS3BA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,ADGA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,AZoCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,AZoCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,AZoCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A6BvFA,ARwBA,AnByDA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,AqB/DA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,AqB/DA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,AqB/DA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AbuCA,AGTA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,Ae7CA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A0B9EA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A0B9EA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A0B9EA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A2BjFA,ADGA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A2BjFA,ADGA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A2BjFA,ADGA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A4BpFA,ADGA,ADGA,AXiCA,ArC+GA,A+C7IA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A4BpFA,ADGA,ADGA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A4BpFA,ADGA,ADGA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A4BpFA,ADGA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AGTA,ADGA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A4BpFA,ADGA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A4BpFA,ADGA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,AnByDA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA;A8BzFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,AV8BA,ALeA,APqBA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AlCsGA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AlCsGA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,AENA,AhBgDA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AlCsGA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AnCyGA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AnCyGA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AnCyGA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,ACHA,ApC4GA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,ACHA,ApC4GA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,ACHA,ApC4GA,AT2BA,AwBxEA,ACHA,AHSA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,ACHA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,ACHA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AFMA,ADGA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,ACHA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AHSA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,AFMA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AHSA,ADGA,AGTA,Ad0CA,AiBnDA,APqBA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,AFMA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AHSA,ADGA,AGTA,Ad0CA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,AFMA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,AHSA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,AHSA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,AHSA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,ACHA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,AqB/DA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A0B9EA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A0B9EA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A0B9EA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AJYA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AwBxEA,A0B9EA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,AENA,ARwBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,ACHA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AWjCA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AWjCA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AWjCA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AzB2EA,A2BjFA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,ArB+DA,ADGA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,ARwBA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AWjCA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AV8BA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,Ad0CA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,Ad0CA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,Ad0CA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A8B1FA,AJYA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AGTA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,ACHA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,AbuCA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,AbuCA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,AbuCA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AkDtJA,AENA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,ApC4GA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,AqB/DA,AsClHA,A3BiFA,ACHA,Af6CA,A2BjFA,AYpCA,ADGA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,AtDkKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,AtDkKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,AtDkKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AS3BA,A4BpFA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,AvDqKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,AvDqKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,AvDqKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AxDwKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AxDwKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AxDwKA,AT2BA,AoD5JA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AxDwKA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AxDwKA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,AWjCA,AIZA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AxDwKA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,A1D8KA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,A1D8KA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,A1D8KA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA;A5BqFA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A4BpFA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A4BpFA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A4BpFA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A6BvFA,ADGA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A6BvFA,ADGA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AyC3HA,A4BpFA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A6BvFA,ADGA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A8B1FA,ADGA,ADGA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A8B1FA,ADGA,ADGA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,A0D9KA,A8B1FA,ADGA,ADGA;AxDyKA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A8B1FA,ADGA;AzD4KA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,Af6CA,AgBhDA,AbuCA,Ac1CA,ACHA,Ad0CA,ACHA,AIZA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A8B1FA,ADGA;AzD4KA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AU9BA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A8B1FA,ADGA;AzD4KA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A8B1FA,ADGA;AzD4KA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ADGA,ALeA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA;AzD4KA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,AENA,A0B9EA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA;AzD4KA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,A+B7FA,AlDsJA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AIZA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AIZA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AIZA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,AbuCA,Ac1CA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA;A7DwLA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA;AhEiMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA;AhEiMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AKfA,ARwBA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA;AhEiMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,ACHA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,ACHA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,ACHA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AENA,ADGA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,ANkBA,AxBwEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AENA,ADGA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AENA,ADGA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,A0B9EA,AXiCA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AGTA,ADGA,ADGA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AGTA,ADGA,ADGA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2BjFA,Ae7CA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AGTA,ADGA,ADGA;AjEoMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AHSA,AkBtDA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AkEtMA,Ad0CA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AoD5JA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AoD5JA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AoD5JA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AoD5JA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AoD5JA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,ACHA,ACHA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AoD5JA,A9B0FA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AENA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AENA,ACHA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,A3DiLA,AT2BA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,Ad0CA,AKfA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A0C9HA,ACHA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,Ad0CA,Ae7CA,ACHA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,Ad0CA,AgBhDA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,Ad0CA,AgBhDA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AGTA,AENA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AIZA,AqC/GA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,ADGA,ADGA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,AuBrEA,AtBkEA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AnByDA,AoC5GA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AKfA,ACHA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,AT2BA,ACHA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AMlBA,AENA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AlCsGA,ANkBA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AqE/MA,ApC4GA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AQxBA,ACHA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AS3BA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AS3BA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AS3BA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AS3BA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AS3BA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,AS3BA,ApE4MA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,A2DjLA,A3BiFA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AzC2HA,A1B8EA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;AlEuMA,AHSA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,A3DiLA,AsBlEA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,A2CjIA,ArC+GA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ARwBA,ACHA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,APqBA,AENA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AiCnGA,ArB+DA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,ALeA,A4BpFA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AYpCA,ADGA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AWjCA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AxCwHA,AWjCA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,A7BuFA,AgChGA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AmDzJA,AnEyMA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AMlBA,ADGA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AGTA,AIZA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AOrBA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AOrBA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AOrBA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AOrBA,AFMA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,ADGA,AKfA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AuBrEA,AXiCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AyC3HA,AnByDA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AGTA,ACHA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AKfA,AIZA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,Af6CA,AMlBA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AiBnDA,AIZA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,AT2BA,AtCkHA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AyB3EA,A5CoIA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A/C6IA,AyF3QA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,A0C9HA,A/B6FA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AhBgDA,AnByDA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,AsBlEA,AqB/DA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,A6BvFA,AS3BA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AYpCA,AnCyGA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AWjCA,AsClHA;ArEgNA,AvBqEA,A2CjIA,AiDnJA;ArEgNA,AvBqEA,A2CjIA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AoB5DA,AiDnJA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA,AqE/MA;ArEgNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var _quarkRenderer = require(\"./lib/quark-renderer\");\n\n(function () {\n  for (var key in _quarkRenderer) {\n    if (_quarkRenderer == null || !_quarkRenderer.hasOwnProperty(key) || key === 'default' || key === '__esModule') return;\n    exports[key] = _quarkRenderer[key];\n  }\n})();\n\nvar _export = require(\"./lib/export\");\n\n(function () {\n  for (var key in _export) {\n    if (_export == null || !_export.hasOwnProperty(key) || key === 'default' || key === '__esModule') return;\n    exports[key] = _export[key];\n  }\n})();\n\nrequire(\"./lib/svg/svg\");\n\nrequire(\"./lib/vml/vml\");","var guid = require(\"./core/utils/guid\");\n\nvar env = require(\"./core/env\");\n\nvar QRendererEventHandler = require(\"./event/QRendererEventHandler\");\n\nvar Storage = require(\"./Storage\");\n\nvar CanvasPainter = require(\"./CanvasPainter\");\n\nvar GlobalAnimationMgr = require(\"./animation/GlobalAnimationMgr\");\n\nvar DomEventProxy = require(\"./event/DomEventProxy\");\n\nvar textContain = require(\"./core/contain/text\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.core.QuarkRenderer\r\n * QuarkRenderer, a high performance 2d drawing library.\r\n * Class QuarkRenderer is the global entry, every time you call qrenderer.init() will \r\n * create an instance of QuarkRenderer class, each instance has an unique id.\r\n * \r\n * QuarkRenderer 是一款高性能的 2d 渲染引擎。\r\n * QuarkRenderer 类是全局入口，每次调用 qrenderer.init() 会创建一个实例，\r\n * 每个 QuarkRenderer 实例有自己唯一的 ID。\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\nif (!env.canvasSupported) {\n  throw new Error(\"Need Canvas Environment.\");\n}\n\nvar useVML = !env.canvasSupported;\nvar painterMap = {\n  canvas: CanvasPainter\n}; // QuarkRenderer 实例map索引，浏览器中同一个 window 下的 QuarkRenderer 实例都存在这里。\n\nvar instances = {};\n/**\r\n * @property {String}\r\n */\n\nvar version = '4.1.2';\n/**\r\n * @method qrenderer.init()\r\n * Global entry for creating a qrenderer instance.\r\n * \r\n * 全局总入口，创建 QuarkRenderer 的实例。\r\n * \r\n * @param {HTMLDomElement|Canvas|Context} host \r\n * This can be a HTMLDomElement like a DIV, or a Canvas instance, \r\n * or Context for Wechat mini-program.\r\n * \r\n * 此属性可以是 HTMLDomElement ，比如 DIV 标签；也可以是 Canvas 实例；或者是 Context 实例，因为在某些\r\n * 运行环境中，不能获得 Canvas 实例的引用，只能获得 Context。\r\n * @param {Object} [options]\r\n * @param {String} [options.renderer='canvas'] 'canvas' or 'svg'\r\n * @param {Number} [options.devicePixelRatio]\r\n * @param {Number|String} [options.width] Can be 'auto' (the same as null/undefined)\r\n * @param {Number|String} [options.height] Can be 'auto' (the same as null/undefined)\r\n * @return {QuarkRenderer}\r\n */\n\nfunction init(host, options) {\n  var qr = new QuarkRenderer(host, options);\n  instances[qr.id] = qr;\n  return qr;\n}\n/**\r\n * TODO: 不要export这个全局函数看起来也没有问题。\r\n * Dispose qrenderer instance\r\n * @param {QuarkRenderer} qr\r\n */\n\n\nfunction dispose(qr) {\n  if (qr) {\n    qr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\r\n * @static\r\n * @method getInstance\r\n * Get qrenderer instance by id.\r\n * @param {String} id\r\n * @return {QuarkRenderer}\r\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, PainterClass) {\n  painterMap[name] = PainterClass;\n}\n/**\r\n * @method constructor QuarkRenderer\r\n * @param {String} id\r\n * @param {HTMLElement} host\r\n * @param {Object} [options]\r\n * @param {String} [options.renderer='canvas'] 'canvas' or 'svg'\r\n * @param {Number} [options.devicePixelRatio]\r\n * @param {Number} [options.width] Can be 'auto' (the same as null/undefined)\r\n * @param {Number} [options.height] Can be 'auto' (the same as null/undefined)\r\n * @return {QuarkRenderer}\r\n */\n\n\nvar QuarkRenderer =\n/*#__PURE__*/\nfunction () {\n  function QuarkRenderer(host) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, QuarkRenderer);\n\n    /**\r\n     * @property {String}\r\n     */\n    this.id = guid();\n    /**\r\n     * @property {HTMLDomElement|Canvas|Context} host \r\n     * This can be a HTMLDomElement like a DIV, or a Canvas instance, \r\n     * or Context for Wechat mini-program.\r\n     * \r\n     * 此属性可以是 HTMLDomElement ，比如 DIV 标签；也可以是 Canvas 实例；或者是 Context 实例，因为在某些\r\n     * 运行环境中，不能获得 Canvas 实例的引用，只能获得 Context。\r\n     */\n\n    this.host = host;\n    var self = this;\n    /**\r\n     * @property {Storage}\r\n     */\n\n    this.storage = new Storage();\n    var rendererType = options.renderer; // TODO:WebGL\n    // TODO: remove vml\n\n    if (useVML) {\n      if (!painterMap.vml) {\n        throw new Error('You need to require \\'qrenderer/vml/vml\\' to support IE8');\n      }\n\n      rendererType = 'vml';\n    } else if (!rendererType || !painterMap[rendererType]) {\n      rendererType = 'canvas';\n    } //根据参数创建不同类型的 Painter 实例。\n\n\n    this.painter = new painterMap[rendererType](this.host, this.storage, options, this.id);\n    var handerProxy = null;\n\n    if (typeof this.host.moveTo !== 'function') {\n      //代理DOM事件。\n      if (!env.node && !env.worker && !env.wxa) {\n        handerProxy = new DomEventProxy(this.painter.getViewportRoot());\n      }\n    } else {\n      // host is Context instance, override function.\n      textContain.$override('measureText', function (text, font) {\n        self.font = font || textContain.DEFAULT_FONT;\n        return self.host.measureText(text);\n      });\n    } //QuarkRenderer 自己封装的事件机制。\n\n\n    this.eventHandler = new QRendererEventHandler(this.storage, this.painter, handerProxy, this.painter.root);\n    /**\r\n     * @property {GlobalAnimationMgr}\r\n     * 利用 GlobalAnimationMgr 动画的 frame 事件渲染下一张画面， QuarkRenderer 依赖此机制来刷新 canvas 画布。\r\n     * FROM MDN：\r\n     * The window.requestAnimationFrame() method tells the browser that you wish \r\n     * to perform an animation and requests that the browser calls a specified \r\n     * function to update an animation before the next repaint. The method takes \r\n     * a callback as an argument to be invoked before the repaint.\r\n     * \r\n     * https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\r\n     * \r\n     * NOTE: 这里有潜在的性能限制，由于 requestAnimationFrame 方法每秒回调60次，每次执行时间约 16ms\r\n     * 如果在 16ms 的时间内无法渲染完一帧画面，会出现卡顿。也就是说， QuarkRenderer 引擎在同一张 canvas 上\r\n     * 能够渲染的图形元素数量有上限。本机在 Chrome 浏览器中 Benchmark 的结果大约为 100 万个矩形会出现\r\n     * 明显的卡顿。\r\n     */\n\n    this.globalAnimationMgr = new GlobalAnimationMgr();\n    this.globalAnimationMgr.on(\"frame\", function () {\n      self.flush();\n    });\n    this.globalAnimationMgr.start();\n    /**\r\n     * @property {boolean}\r\n     * @private\r\n     */\n\n    this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n    // FIXME 有点ugly\n    // What's going on here?\n\n    var oldDelFromStorage = this.storage.delFromStorage;\n    var oldAddToStorage = this.storage.addToStorage;\n\n    this.storage.delFromStorage = function (el) {\n      oldDelFromStorage.call(self.storage, el);\n      el && el.removeSelfFromQr(self);\n    };\n\n    this.storage.addToStorage = function (el) {\n      oldAddToStorage.call(self.storage, el);\n      el.addSelfToQr(self);\n    };\n  }\n  /**\r\n   * @method\r\n   * 获取实例唯一标识\r\n   * @return {String}\r\n   */\n\n\n  _createClass(QuarkRenderer, [{\n    key: \"getId\",\n    value: function getId() {\n      return this.id;\n    }\n    /**\r\n     * @method\r\n     * 添加元素\r\n     * @param  {qrenderer/Element} el\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(el) {\n      this.storage.addRoot(el);\n      this._needsRefresh = true;\n    }\n    /**\r\n     * @method\r\n     * 删除元素\r\n     * @param  {qrenderer/Element} el\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(el) {\n      this.storage.delRoot(el);\n      this._needsRefresh = true;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Change configuration of layer\r\n     * @param {String} qLevel\r\n     * @param {Object} [config]\r\n     * @param {String} [config.clearColor=0] Clear color\r\n     * @param {String} [config.motionBlur=false] If enable motion blur\r\n     * @param {Number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\r\n    */\n\n  }, {\n    key: \"configLayer\",\n    value: function configLayer(qLevel, config) {\n      if (this.painter.configLayer) {\n        this.painter.configLayer(qLevel, config);\n      }\n\n      this._needsRefresh = true;\n    }\n    /**\r\n     * @method\r\n     * Set background color\r\n     * @param {String} backgroundColor\r\n     */\n\n  }, {\n    key: \"setBackgroundColor\",\n    value: function setBackgroundColor(backgroundColor) {\n      if (this.painter.setBackgroundColor) {\n        this.painter.setBackgroundColor(backgroundColor);\n      }\n\n      this._needsRefresh = true;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Repaint the canvas immediately\r\n     */\n\n  }, {\n    key: \"refreshImmediately\",\n    value: function refreshImmediately() {\n      // let start = new Date();\n      // Clear needsRefresh ahead to avoid something wrong happens in refresh\n      // Or it will cause qrenderer refreshes again and again.\n      this._needsRefresh = this._needsRefreshHover = false;\n      this.painter.refresh(); // Avoid trigger qr.refresh in Element#beforeUpdate hook\n\n      this._needsRefresh = this._needsRefreshHover = false; // let end = new Date();\n      // let log = document.getElementById('log');\n      // if (log) {\n      //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n      // }\n    }\n    /**\r\n     * @method\r\n     * Mark and repaint the canvas in the next frame of browser\r\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this._needsRefresh = true;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Perform all refresh\r\n     * 刷新 canvas 画面，此方法会在 window.requestAnimationFrame 方法中被不断调用。\r\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var triggerRendered;\n\n      if (this._needsRefresh) {\n        //是否需要全部重绘\n        triggerRendered = true;\n        this.refreshImmediately();\n      }\n\n      if (this._needsRefreshHover) {\n        //只重绘特定的元素，提升性能\n        triggerRendered = true;\n        this.refreshHoverImmediately();\n      }\n\n      triggerRendered && this.trigger('rendered');\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * 与 Hover 相关的6个方法用来处理浮动层，当鼠标悬停在 canvas 中的元素上方时，可能会需要\r\n     * 显示一些浮动的层来展现一些特殊的数据。\r\n     * TODO:这里可能有点问题，Hover 一词可能指的是遮罩层，而不是浮动层，如果确认是遮罩，考虑\r\n     * 把这里的 API 单词重构成 Mask。\r\n     * \r\n     * Add element to hover layer\r\n     * @param  {Element} el\r\n     * @param {Object} style\r\n     */\n\n  }, {\n    key: \"addHover\",\n    value: function addHover(el, style) {\n      if (this.painter.addHover) {\n        var elMirror = this.painter.addHover(el, style);\n        this.refreshHover();\n        return elMirror;\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Remove element from hover layer\r\n     * @param  {Element} el\r\n     */\n\n  }, {\n    key: \"removeHover\",\n    value: function removeHover(el) {\n      if (this.painter.removeHover) {\n        this.painter.removeHover(el);\n        this.refreshHover();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Find hovered element\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     * @return {Object} {target, topTarget}\r\n     */\n\n  }, {\n    key: \"findHover\",\n    value: function findHover(x, y) {\n      return this.eventHandler.findHover(x, y);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Clear all hover elements in hover layer\r\n     * @param  {Element} el\r\n     */\n\n  }, {\n    key: \"clearHover\",\n    value: function clearHover() {\n      if (this.painter.clearHover) {\n        this.painter.clearHover();\n        this.refreshHover();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Refresh hover in next frame\r\n     */\n\n  }, {\n    key: \"refreshHover\",\n    value: function refreshHover() {\n      this._needsRefreshHover = true;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * Refresh hover immediately\r\n     */\n\n  }, {\n    key: \"refreshHoverImmediately\",\n    value: function refreshHoverImmediately() {\n      this._needsRefreshHover = false;\n      this.painter.refreshHover && this.painter.refreshHover();\n    }\n    /**\r\n     * @method\r\n     * Resize the canvas.\r\n     * Should be invoked when container size is changed\r\n     * @param {Object} [options]\r\n     * @param {Number|String} [options.width] Can be 'auto' (the same as null/undefined)\r\n     * @param {Number|String} [options.height] Can be 'auto' (the same as null/undefined)\r\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(options) {\n      options = options || {};\n      this.painter.resize(options.width, options.height);\n      this.eventHandler.resize();\n    }\n    /**\r\n     * @method\r\n     * Stop and clear all animation immediately\r\n     */\n\n  }, {\n    key: \"clearAnimation\",\n    value: function clearAnimation() {\n      this.globalAnimationMgr.clear();\n    }\n    /**\r\n     * @method\r\n     * Get container width\r\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.painter.getWidth();\n    }\n    /**\r\n     * @method\r\n     * Get container height\r\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.painter.getHeight();\n    }\n    /**\r\n     * @method\r\n     * Converting a path to image.\r\n     * It has much better performance of drawing image rather than drawing a vector path.\r\n     * @param {graphic/Path} e\r\n     * @param {Number} width\r\n     * @param {Number} height\r\n     */\n\n  }, {\n    key: \"pathToImage\",\n    value: function pathToImage(e, dpr) {\n      return this.painter.pathToImage(e, dpr);\n    }\n    /**\r\n     * @method\r\n     * Set default cursor\r\n     * @param {String} [cursorStyle='default'] 例如 crosshair\r\n     */\n\n  }, {\n    key: \"setCursorStyle\",\n    value: function setCursorStyle(cursorStyle) {\n      this.eventHandler.setCursorStyle(cursorStyle);\n    }\n    /**\r\n     * @method\r\n     * Bind event\r\n     *\r\n     * @param {String} eventName Event name\r\n     * @param {Function} eventHandler Handler function\r\n     * @param {Object} [context] Context object\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, eventHandler, context) {\n      this.eventHandler.on(eventName, eventHandler, context);\n    }\n    /**\r\n     * @method\r\n     * Unbind event\r\n     * @param {String} eventName Event name\r\n     * @param {Function} [eventHandler] Handler function\r\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, eventHandler) {\n      this.eventHandler.off(eventName, eventHandler);\n    }\n    /**\r\n     * @method\r\n     * Trigger event manually\r\n     *\r\n     * @param {String} eventName Event name\r\n     * @param {event=} event Event object\r\n     */\n\n  }, {\n    key: \"trigger\",\n    value: function trigger(eventName, event) {\n      this.eventHandler.trigger(eventName, event);\n    }\n    /**\r\n     * @method\r\n     * Clear all objects and the canvas.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.storage.delRoot();\n      this.painter.clear();\n    }\n    /**\r\n     * @method\r\n     * Dispose self.\r\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.globalAnimationMgr.stop();\n      this.clear();\n      this.storage.dispose();\n      this.painter.dispose();\n      this.eventHandler.dispose();\n      this.globalAnimationMgr = this.storage = this.painter = this.eventHandler = null;\n      delete instances[this.id];\n    }\n  }]);\n\n  return QuarkRenderer;\n}(); // ---------------------------\n// Events of qrenderer instance.\n// ---------------------------\n\n/**\r\n * @event onclick\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onmouseover\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onmouseout\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onmousemove\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onmousewheel\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onmousedown\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onmouseup\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondrag\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondragstart\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondragend\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondragenter\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondragleave\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondragover\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event ondrop\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onpagemousemove\r\n * @param {Function} null\r\n */\n\n/**\r\n * @event onpagemouseup\r\n * @param {Function} null\r\n */\n\n\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;","/**\r\n * 生成唯一id\r\n * @author errorrik (errorrik@gmail.com)\r\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\r\n * echarts设备环境识别\r\n *\r\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\r\n * @author firede[firede@firede.us]\r\n * @desc thanks zepto.\r\n */\n// Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // 原生canvas支持，改极端点了\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11),\n    // passiveSupported: detectPassiveSupport()\n    domSupported: typeof document !== 'undefined'\n  };\n}\n\nvar env = {};\n\nif ((typeof wx === \"undefined\" ? \"undefined\" : _typeof(wx)) === 'object' && typeof wx.getSystemInfoSync === 'function') {\n  // In Weixin Application\n  env = {\n    browser: {},\n    os: {},\n    node: false,\n    wxa: true,\n    // Weixin Application\n    canvasSupported: true,\n    svgSupported: false,\n    touchEventsSupported: true,\n    domSupported: false\n  };\n} else if (typeof document === 'undefined' && typeof self !== 'undefined') {\n  // In worker\n  env = {\n    browser: {},\n    os: {},\n    node: false,\n    worker: true,\n    canvasSupported: true,\n    domSupported: false\n  };\n} else if (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    worker: false,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true,\n    domSupported: false\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env;\nmodule.exports = _default;","var dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../core/utils/class_util\");\n\nvar vec2 = require(\"../core/utils/vector\");\n\nvar eventTool = require(\"../core/utils/event_util\");\n\nvar MultiDragDrop = require(\"./MultiDragDrop\");\n\nvar Eventful = require(\"./Eventful\");\n\nvar GestureMgr = require(\"./GestureMgr\");\n\n/**\r\n * @class qrenderer.event.QRendererEventHandler\r\n * Canvas 内置的API只在 canvas 实例本身上面触发事件，对画布内部的画出来的元素没有提供事件支持。\r\n * QRendererEventHandler.js 用来封装画布内部元素的事件处理逻辑，核心思路是，在 canvas 收到事件之后，派发给指定的元素，\r\n * 然后再进行冒泡，从而模拟出原生 DOM 事件的行为。\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar SILENT = 'silent';\n/**\r\n * @private\r\n * @method\r\n * @param {String} eveType \r\n * @param {Object} targetInfo \r\n * @param {Event} event \r\n */\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.qrX,\n    offsetY: event.qrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.qrDelta,\n    qrByTouch: event.qrByTouch,\n    qrIsFromLocal: event.qrIsFromLocal,\n    which: event.which,\n    stop: stopEvent\n  };\n}\n/**\r\n * @private\r\n * @method\r\n * @param {Event} event  \r\n */\n\n\nfunction stopEvent(event) {\n  eventTool.stop(this.event);\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu', 'pagemousemove', 'pagemouseup', 'pagekeydown', 'pagekeyup'];\n/**\r\n * @method\r\n * 监听页面上触发的事件，转换成当前实例自己触发的事件\r\n * @param {String} pageEventName \r\n * @param {Event} event \r\n */\n\nfunction pageEventHandler(pageEventName, event) {\n  this.trigger(pageEventName, makeEventPacket(pageEventName, {}, event));\n}\n/**\r\n * @method\r\n * 鼠标是否在指定的元素上方。\r\n * @param {Displayable} displayable \r\n * @param {Number} x \r\n * @param {Number} y \r\n */\n\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n/**\r\n * @private\r\n * @method\r\n * @param {Function} handlerInstance \r\n */\n\n\nfunction afterListenerChanged(handlerInstance) {\n  //监听整个页面上的事件\n  var allSilent = handlerInstance.isSilent('pagemousemove') && handlerInstance.isSilent('pagemouseup') && handlerInstance.isSilent('pagekeydown') && handlerInstance.isSilent('pagekeyup');\n  var proxy = handlerInstance.proxy;\n  proxy && proxy.togglePageEvent && proxy.togglePageEvent(!allSilent);\n}\n/**\r\n * @method constructor QRendererEventHandler\r\n * @param {Storage} storage Storage instance.\r\n * @param {Painter} painter Painter instance.\r\n * @param {HandlerProxy} proxy HandlerProxy instance.\r\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\r\n */\n\n\nvar QRendererEventHandler = function QRendererEventHandler(storage, painter, proxy, painterRoot) {\n  Eventful.call(this, {\n    afterListenerChanged: dataUtil.bind(afterListenerChanged, null, this)\n  });\n  /**\r\n   * @property storage\r\n   */\n\n  this.storage = storage;\n  /**\r\n   * @property painter\r\n   */\n\n  this.painter = painter;\n  /**\r\n   * @property painterRoot\r\n   */\n\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\r\n   * @property proxy\r\n   * Proxy of event. can be Dom, WebGLSurface, etc.\r\n   */\n\n  this.proxy = null;\n  /**\r\n   * @private \r\n   * @property {Object} _hovered\r\n   */\n\n  this._hovered = {};\n  /**\r\n   * @private\r\n   * @property {Date} _lastTouchMoment\r\n   */\n\n  this._lastTouchMoment;\n  /**\r\n   * @private\r\n   * @property {Number} _lastX\r\n   */\n\n  this._lastX;\n  /**\r\n   * @private\r\n   * @property {Number} _lastY\r\n   */\n\n  this._lastY;\n  /**\r\n   * @private\r\n   * @property _gestureMgr\r\n   */\n\n  this._gestureMgr;\n  new MultiDragDrop(this);\n  this.setHandlerProxy(proxy);\n};\n\nQRendererEventHandler.prototype = {\n  constructor: QRendererEventHandler,\n\n  /**\r\n   * @method setHandlerProxy\r\n   * @param {*} proxy \r\n   */\n  setHandlerProxy: function setHandlerProxy(proxy) {\n    if (this.proxy) {\n      this.proxy.dispose();\n    }\n\n    if (proxy) {\n      dataUtil.each(handlerNames, function (name) {\n        // 监听 Proxy 上面派发的原生DOM事件，转发给本类的处理方法。\n        proxy.on && proxy.on(name, this[name], this);\n      }, this); // Attach handler\n\n      proxy.handler = this;\n    }\n\n    this.proxy = proxy;\n  },\n\n  /**\r\n   * @method mousemove\r\n   * @param {*} proxy \r\n   */\n  mousemove: function mousemove(event) {\n    var x = event.qrX;\n    var y = event.qrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from qr (detected by '__qr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__qr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n\n  /**\r\n   * @method mouseout\r\n   * @param {*} proxy \r\n   */\n  mouseout: function mouseout(event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType !== 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n  pagemousemove: dataUtil.curry(pageEventHandler, 'pagemousemove'),\n  pagemouseup: dataUtil.curry(pageEventHandler, 'pagemouseup'),\n  pagekeydown: dataUtil.curry(pageEventHandler, 'pagekeydown'),\n  pagekeyup: dataUtil.curry(pageEventHandler, 'pagekeyup'),\n\n  /**\r\n   * @method resize\r\n   * @param {Event} event \r\n   */\n  resize: function resize(event) {\n    this._hovered = {};\n  },\n\n  /**\r\n   * @method dispatch\r\n   * Dispatch event\r\n   * @param {String} eventName\r\n   * @param {Event} eventArgs\r\n   */\n  dispatch: function dispatch(eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\r\n   * @method dispose\r\n   */\n  dispose: function dispose() {\n    this.proxy.dispose();\n    this.storage = null;\n    this.proxy = null;\n    this.painter = null;\n  },\n\n  /**\r\n   * @method setCursorStyle\r\n   * 设置默认的cursor style\r\n   * @param {String} [cursorStyle='default'] 例如 crosshair\r\n   */\n  setCursorStyle: function setCursorStyle(cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\r\n   * @private\r\n   * @method dispatchToElement\r\n   * 事件分发代理，把事件分发给 canvas 中绘制的元素。\r\n   *\r\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\r\n   * @param {String} eventName 事件名称\r\n   * @param {Object} event 事件对象\r\n   */\n  dispatchToElement: function dispatchToElement(targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event); //模拟DOM中的事件冒泡行为，事件一直向上层传播，直到没有父层节点为止。\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 qrenderer 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] === 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\r\n   * @method findHover\r\n   * @param {Number} x\r\n   * @param {Number} y\r\n   * @param {Displayable} exclude\r\n   * @return {Element}\r\n   */\n  findHover: function findHover(x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    }; //NOTE: 在元素数量非常庞大的时候，如 100 万个元素，这里的 for 循环会很慢，基本不能响应鼠标事件。\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  },\n\n  /**\r\n   * @method processGesture\r\n   * @param {Event} event \r\n   * @param {String} phase \r\n   */\n  processGesture: function processGesture(event, phase) {\n    if (!this._gestureMgr) {\n      this._gestureMgr = new GestureMgr();\n    }\n\n    var gestureMgr = this._gestureMgr;\n    phase === 'start' && gestureMgr.clear();\n    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.qrX, event.qrY, null).target, this.proxy.dom);\n    phase === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n    if (gestureInfo) {\n      var type = gestureInfo.type;\n      event.gestureEvent = type;\n      this.dispatchToElement({\n        target: gestureInfo.target\n      }, type, gestureInfo.event);\n    }\n  }\n}; // Common handlers\n\ndataUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  QRendererEventHandler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.qrX, event.qrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.qrX, event.qrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mouseup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.qrX, event.qrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    } //把事件派发给目标元素\n\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\nclassUtil.mixin(QRendererEventHandler, Eventful);\nvar _default = QRendererEventHandler;\nmodule.exports = _default;","var _constants = require(\"../../graphic/constants\");\n\nvar mathFloor = _constants.mathFloor;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\r\n * 用来操作数据的一些工具函数。\r\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  // Clear ctx instance for different environment\n  if (name === 'createCanvas') {\n    _ctx = null;\n  }\n\n  methods[name] = fn;\n}\n/**\r\n * Those data types can be cloned:\r\n *     Plain object, Array, TypedArray, number, string, null, undefined.\r\n * Those data types will be assgined using the orginal data:\r\n *     BUILTIN_OBJECT\r\n * Instance of user defined class will be cloned to a plain object, without\r\n * properties in prototype.\r\n * Other data types is not supported (not sure what will happen).\r\n *\r\n * Caution: do not support clone Date, for performance consideration.\r\n * (There might be a large number of date in `series.data`).\r\n * So date should not be modified in and out of echarts.\r\n *\r\n * @param {*} source\r\n * @return {*} new\r\n */\n\n\nfunction clone(source) {\n  if (source == null || _typeof(source) !== 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    if (!isPrimitive(source)) {\n      result = [];\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    if (!isPrimitive(source)) {\n      var Ctor = source.constructor;\n\n      if (source.constructor.from) {\n        result = Ctor.from(source);\n      } else {\n        result = new Ctor(source.length);\n\n        for (var i = 0, len = source.length; i < len; i++) {\n          result[i] = clone(source[i]);\n        }\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * @param {*} target\r\n * @param {*} source\r\n * @param {boolean} [overwrite=false]\r\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\r\n * @param {Array} targetAndSources The first item is target, and the rests are source.\r\n * @param {boolean} [overwrite=false]\r\n * @return {*} target\r\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\r\n * @param {*} target\r\n * @param {*} source\r\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\r\n * 查询数组中元素的index\r\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\r\n * Consider typed array.\r\n * @param {Array|TypedArray} data\r\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data === 'string') {\n    return false;\n  }\n\n  return typeof data.length === 'number';\n}\n/**\r\n * 数组或对象遍历\r\n * @param {Object|Array} obj\r\n * @param {Function} cb\r\n * @param {*} [context]\r\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\r\n * 数组映射\r\n * @param {Array} obj\r\n * @param {Function} cb\r\n * @param {*} [context]\r\n * @return {Array}\r\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\r\n * @param {Array} obj\r\n * @param {Function} cb\r\n * @param {Object} [memo]\r\n * @param {*} [context]\r\n * @return {Array}\r\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\r\n * 数组过滤\r\n * @param {Array} obj\r\n * @param {Function} cb\r\n * @param {*} [context]\r\n * @return {Array}\r\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\r\n * 数组项查找\r\n * @param {Array} obj\r\n * @param {Function} cb\r\n * @param {*} [context]\r\n * @return {*}\r\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\r\n * @param {Function} func\r\n * @param {*} context\r\n * @return {Function}\r\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\r\n * @param {Function} func\r\n * @return {Function}\r\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = _typeof(value);\n\n  return type === 'function' || !!value && type === 'object';\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isTypedArray(value) {\n  return !!TYPED_ARRAY[objToString.call(value)];\n}\n/**\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction isDom(value) {\n  return _typeof(value) === 'object' && typeof value.nodeType === 'number' && _typeof(value.ownerDocument) === 'object';\n}\n/**\r\n * Whether is exactly NaN. Notice isNaN('a') returns true.\r\n * @param {*} value\r\n * @return {boolean}\r\n */\n\n\nfunction eqNaN(value) {\n  /* eslint-disable-next-line no-self-compare */\n  return value !== value;\n}\n/**\r\n * If value1 is not null, then return value1, otherwise judget rest of values.\r\n * Low performance.\r\n * @return {*} Final value\r\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\r\n * @param {Array} arr\r\n * @param {Number} startIndex\r\n * @param {Number} endIndex\r\n * @return {Array}\r\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\r\n * Normalize css liked array configuration\r\n * e.g.\r\n *  3 => [3, 3, 3, 3]\r\n *  [4, 2] => [4, 2, 4, 2]\r\n *  [4, 3, 2] => [4, 3, 2, 3]\r\n * @param {number|Array.<Number>} val\r\n * @return {Array<Number>}\r\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\r\n * @param {boolean} condition\r\n * @param {String} message\r\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\r\n * @param {String} str string to be trimed\r\n * @return {String} trimed string\r\n */\n\n\nfunction trim(str) {\n  if (str == null) {\n    return null;\n  } else if (typeof str.trim === 'function') {\n    return str.trim();\n  } else {\n    return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\r\n * Set an object as primitive to be ignored traversing children in clone or merge\r\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\r\n * @constructor\r\n * @param {Object} obj Only apply `ownProperty`.\r\n */\n\n\nfunction HashMap(obj) {\n  var isArr = isArray(obj); // Key should not be set on this, otherwise\n  // methods get/set/... may be overrided.\n\n  this.data = {};\n  var thisMap = this;\n  obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);\n\n  function visit(value, key) {\n    isArr ? thisMap.set(value, key) : thisMap.set(key, value);\n  }\n}\n\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function get(key) {\n    return this.data.hasOwnProperty(key) ? this.data[key] : null;\n  },\n  set: function set(key, value) {\n    // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n    return this.data[key] = value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function each(cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n    /* eslint-disable guard-for-in */\n\n    for (var key in this.data) {\n      this.data.hasOwnProperty(key) && cb(this.data[key], key);\n    }\n    /* eslint-enable guard-for-in */\n\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function removeKey(key) {\n    delete this.data[key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction concatArray(a, b) {\n  var newArray = new a.constructor(a.length + b.length);\n\n  for (var i = 0; i < a.length; i++) {\n    newArray[i] = a[i];\n  }\n\n  var offset = a.length;\n\n  for (i = 0; i < b.length; i++) {\n    newArray[i + offset] = b[i];\n  }\n\n  return newArray;\n}\n\nfunction noop() {}\n/**\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} percent\r\n * @return {Number}\r\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\r\n * @param  {String} p0\r\n * @param  {String} p1\r\n * @param  {Number} percent\r\n * @return {String}\r\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\r\n * @param  {Array} p0\r\n * @param  {Array} p1\r\n * @param  {Number} percent\r\n * @param  {Array} out\r\n * @param  {Number} arrDim\r\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n  if (!len) return;\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = p0[0].length;\n    if (!len2) return;\n\n    for (var i = 0; i < len; i++) {\n      if (out[i] === undefined) {\n        return;\n      }\n\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : Array.prototype.slice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\r\n * @param  {Array} arr0\r\n * @param  {Array} arr1\r\n * @param  {Number} arrDim\r\n * @return {boolean}\r\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\r\n * Catmull Rom interpolate array\r\n * @param  {Array} p0\r\n * @param  {Array} p1\r\n * @param  {Array} p2\r\n * @param  {Array} p3\r\n * @param  {Number} t\r\n * @param  {Number} t2\r\n * @param  {Number} t3\r\n * @param  {Array} out\r\n * @param  {Number} arrDim\r\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\r\n * Catmull Rom interpolate number\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} p3\r\n * @param  {Number} t\r\n * @param  {Number} t2\r\n * @param  {Number} t3\r\n * @return {Number}\r\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(Array.prototype.slice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return Array.prototype.slice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = mathFloor(rgba[0]);\n  rgba[1] = mathFloor(rgba[1]);\n  rgba[2] = mathFloor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.indexOf = indexOf;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isNumeric = isNumeric;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isTypedArray = isTypedArray;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.trim = trim;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.concatArray = concatArray;\nexports.noop = noop;\nexports.interpolateNumber = interpolateNumber;\nexports.interpolateString = interpolateString;\nexports.interpolateArray = interpolateArray;\nexports.fillArr = fillArr;\nexports.isArraySame = isArraySame;\nexports.catmullRomInterpolateArray = catmullRomInterpolateArray;\nexports.catmullRomInterpolate = catmullRomInterpolate;\nexports.cloneValue = cloneValue;\nexports.rgba2String = rgba2String;\nexports.getArrayDim = getArrayDim;\nexports.parseInt10 = parseInt10;","var ContextCachedBy = {\n  NONE: 0,\n  STYLE_BIND: 1,\n  PLAIN_TEXT: 2\n};\nvar WILL_BE_RESTORED = 9;\nvar E = Math.E;\nvar LN2 = Math.LN2;\nvar LN10 = Math.LN10;\nvar LOG2E = Math.LOG2E;\nvar LOG10E = Math.LOG10E;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar SQRT1_2 = Math.SQRT1_2;\nvar SQRT2 = Math.SQRT2;\nvar mathAbs = Math.abs;\nvar mathAcos = Math.acos;\nvar mathAcosh = Math.acosh;\nvar mathAsin = Math.asin;\nvar mathAsinh = Math.asinh;\nvar mathAtan = Math.atan;\nvar mathAtanh = Math.atanh;\nvar mathAtan2 = Math.atan2;\nvar mathCbrt = Math.cbrt;\nvar mathCeil = Math.ceil;\nvar mathClz32 = Math.clz32;\nvar mathCos = Math.cos;\nvar mathCosh = Math.cosh;\nvar mathExp = Math.exp;\nvar mathExpm1 = Math.expm1;\nvar mathFloor = Math.floor;\nvar matFround = Math.fround;\nvar mathHypot = Math.hypot;\nvar mathImul = Math.imul;\nvar mathLog = Math.log;\nvar mathLog1p = Math.log1p;\nvar mathLog10 = Math.log10;\nvar mathLog2 = Math.log2;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar mathPow = Math.pow;\nvar mathRandom = Math.random;\nvar mathRound = Math.round;\nvar mathSign = Math.sign;\nvar mathSin = Math.sin;\nvar mathSinh = Math.sinh;\nvar mathSqrt = Math.sqrt;\nvar mathTan = Math.tan;\nvar mathTanh = Math.tanh;\nvar mathTrunc = Math.trunc;\nexports.ContextCachedBy = ContextCachedBy;\nexports.WILL_BE_RESTORED = WILL_BE_RESTORED;\nexports.E = E;\nexports.LN2 = LN2;\nexports.LN10 = LN10;\nexports.LOG2E = LOG2E;\nexports.LOG10E = LOG10E;\nexports.PI = PI;\nexports.PI2 = PI2;\nexports.SQRT1_2 = SQRT1_2;\nexports.SQRT2 = SQRT2;\nexports.mathAbs = mathAbs;\nexports.mathAcos = mathAcos;\nexports.mathAcosh = mathAcosh;\nexports.mathAsin = mathAsin;\nexports.mathAsinh = mathAsinh;\nexports.mathAtan = mathAtan;\nexports.mathAtanh = mathAtanh;\nexports.mathAtan2 = mathAtan2;\nexports.mathCbrt = mathCbrt;\nexports.mathCeil = mathCeil;\nexports.mathClz32 = mathClz32;\nexports.mathCos = mathCos;\nexports.mathCosh = mathCosh;\nexports.mathExp = mathExp;\nexports.mathExpm1 = mathExpm1;\nexports.mathFloor = mathFloor;\nexports.matFround = matFround;\nexports.mathHypot = mathHypot;\nexports.mathImul = mathImul;\nexports.mathLog = mathLog;\nexports.mathLog1p = mathLog1p;\nexports.mathLog10 = mathLog10;\nexports.mathLog2 = mathLog2;\nexports.mathMax = mathMax;\nexports.mathMin = mathMin;\nexports.mathPow = mathPow;\nexports.mathRandom = mathRandom;\nexports.mathRound = mathRound;\nexports.mathSign = mathSign;\nexports.mathSin = mathSin;\nexports.mathSinh = mathSinh;\nexports.mathSqrt = mathSqrt;\nexports.mathTan = mathTan;\nexports.mathTanh = mathTanh;\nexports.mathTrunc = mathTrunc;","/**\r\n * 构造类继承关系\r\n *\r\n * @param {Function} clazz 源类\r\n * @param {Function} baseClazz 基类\r\n */\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    if (clazzPrototype.hasOwnProperty(prop)) {\n      clazz.prototype[prop] = clazzPrototype[prop];\n    }\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\r\n * 这里的 mixin 只拷贝 prototype 上的属性。\r\n * @param {Object|Function} target\r\n * @param {Object|Function} sorce\r\n * @param {boolean} overlay\r\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\r\n * @method inheritProperties\r\n * \r\n * Copy properties from super class, this method is designed for the classes which were not written in ES6 syntax.\r\n * \r\n * 拷贝父类上的属性，此方法用来支持那么没有按照 ES6 语法编写的类。\r\n * \r\n * @param {*} subInstance 子类的实例\r\n * @param {*} SuperClass 父类的类型\r\n * @param {*} opts 构造参数\r\n */\n\n\nfunction inheritProperties(subInstance, SuperClass, opts) {\n  var sp = new SuperClass(opts);\n\n  for (var name in sp) {\n    if (sp.hasOwnProperty(name)) {\n      subInstance[name] = sp[name];\n    }\n  }\n}\n/**\r\n * @param {*} target\r\n * @param {*} source\r\n * @param {boolean} [overlay=false]\r\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\r\n * @method copyOwnProperties\r\n * \r\n * Copy own properties from source object to target object, exclude inherited ones.\r\n * \r\n * 从目标对象上拷贝属性，拷贝过程中排除那些通过继承而来的属性。\r\n * \r\n * @param {Object} target \r\n * @param {Object} source \r\n * @param {Array} excludes \r\n */\n\n\nfunction copyOwnProperties(target, source) {\n  var excludes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (excludes && excludes.length) {\n        if (excludes.indexOf(key) != -1) {\n          continue;\n        }\n      }\n\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.inheritProperties = inheritProperties;\nexports.defaults = defaults;\nexports.copyOwnProperties = copyOwnProperties;","var _constants = require(\"../../graphic/constants\");\n\nvar mathSqrt = _constants.mathSqrt;\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\n\n/* global Float32Array */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\r\n * 创建一个向量\r\n * @param {Number} [x=0]\r\n * @param {Number} [y=0]\r\n * @return {Vector2}\r\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * 复制向量数据\r\n * @param {Vector2} out\r\n * @param {Vector2} v\r\n * @return {Vector2}\r\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\r\n * 克隆一个向量\r\n * @param {Vector2} v\r\n * @return {Vector2}\r\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\r\n * 设置向量的两个项\r\n * @param {Vector2} out\r\n * @param {Number} a\r\n * @param {Number} b\r\n * @return {Vector2} 结果\r\n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\r\n * 向量相加\r\n * @param {Vector2} out\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\r\n * 向量缩放后相加\r\n * @param {Vector2} out\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n * @param {Number} a\r\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\r\n * 向量相减\r\n * @param {Vector2} out\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\r\n * 向量长度\r\n * @param {Vector2} v\r\n * @return {Number}\r\n */\n\n\nfunction len(v) {\n  return mathSqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\r\n * 向量长度平方\r\n * @param {Vector2} v\r\n * @return {Number}\r\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\r\n * 向量乘法\r\n * @param {Vector2} out\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\r\n * 向量除法\r\n * @param {Vector2} out\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\r\n * 向量点乘\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n * @return {Number}\r\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\r\n * 向量缩放\r\n * @param {Vector2} out\r\n * @param {Vector2} v\r\n * @param {Number} s\r\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\r\n * 向量归一化\r\n * @param {Vector2} out\r\n * @param {Vector2} v\r\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\r\n * 计算向量间距离\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n * @return {Number}\r\n */\n\n\nfunction distance(v1, v2) {\n  return mathSqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\r\n * 向量距离平方\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n * @return {Number}\r\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\r\n * 求负向量\r\n * @param {Vector2} out\r\n * @param {Vector2} v\r\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\r\n * 插值两个点\r\n * @param {Vector2} out\r\n * @param {Vector2} v1\r\n * @param {Vector2} v2\r\n * @param {Number} t\r\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\r\n * 矩阵左乘向量\r\n * @param {Vector2} out\r\n * @param {Vector2} v\r\n * @param {Vector2} m\r\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * 求两个向量最小值\r\n * @param  {Vector2} out\r\n * @param  {Vector2} v1\r\n * @param  {Vector2} v2\r\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = mathMin(v1[0], v2[0]);\n  out[1] = mathMin(v1[1], v2[1]);\n  return out;\n}\n/**\r\n * 求两个向量最大值\r\n * @param  {Vector2} out\r\n * @param  {Vector2} v1\r\n * @param  {Vector2} v2\r\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = mathMax(v1[0], v2[0]);\n  out[1] = mathMax(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;","var Eventful = require(\"../../event/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"../env\");\n\nvar _four_points_transform = require(\"./four_points_transform\");\n\nvar buildTransformer = _four_points_transform.buildTransformer;\n\n/**\r\n * Utilities for mouse or touch events.\r\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\nvar EVENT_SAVED_PROP = '___qrEVENTSAVED';\nvar _calcOut = [];\n/**\r\n * Get the `qrX` and `qrY`, which are relative to the top-left of\r\n * the input `el`.\r\n * CSS transform (2D & 3D) is supported.\r\n *\r\n * The strategy to fetch the coords:\r\n * + If `calculate` is not set as `true`, users of this method should\r\n * ensure that `el` is the same or the same size & location as `e.target`.\r\n * Otherwise the result coords are probably not expected. Because we\r\n * firstly try to get coords from e.offsetX/e.offsetY.\r\n * + If `calculate` is set as `true`, the input `el` can be any element\r\n * and we force to calculate the coords based on `el`.\r\n * + The input `el` should be positionable (not position:static).\r\n *\r\n * The force `calculate` can be used in case like:\r\n * When mousemove event triggered on ec tooltip, `e.target` is not `el`(qr painter.dom).\r\n *\r\n * @param {HTMLElement} el DOM element.\r\n * @param {Event} e Mouse event or touch event.\r\n * @param {Object} out Get `out.qrX` and `out.qrY` as the result.\r\n * @param {boolean} [calculate=false] Whether to force calculate\r\n *        the coordinates but not use ones provided by browser.\r\n */\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In qr painter.dom, padding edge equals to border edge.\n\n  if (calculate || !env.canvasSupported) {\n    calculateQrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.qrX = e.layerX;\n      out.qrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.qrX = e.offsetX;\n        out.qrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          calculateQrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction calculateQrXY(el, e, out) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.\n  if (el.getBoundingClientRect && env.domSupported) {\n    var ex = e.clientX;\n    var ey = e.clientY;\n\n    if (el.nodeName.toUpperCase() === 'CANVAS') {\n      // Original approach, which do not support CSS transform.\n      // marker can not be locationed in a canvas container\n      // (getBoundingClientRect is always 0). We do not support\n      // that input a pre-created canvas to qr while using css\n      // transform in iOS.\n      var box = el.getBoundingClientRect();\n      out.qrX = ex - box.left;\n      out.qrY = ey - box.top;\n      return;\n    } else {\n      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n      var transformer = preparePointerTransformer(prepareCoordMarkers(el, saved), saved);\n\n      if (transformer) {\n        transformer(_calcOut, ex, ey);\n        out.qrX = _calcOut[0];\n        out.qrY = _calcOut[1];\n        return;\n      }\n    }\n  }\n\n  out.qrX = out.qrY = 0;\n}\n\nfunction prepareCoordMarkers(el, saved) {\n  var markers = saved.markers;\n\n  if (markers) {\n    return markers;\n  }\n\n  markers = saved.markers = [];\n  var propLR = ['left', 'right'];\n  var propTB = ['top', 'bottom'];\n\n  for (var i = 0; i < 4; i++) {\n    var marker = document.createElement('div');\n    var stl = marker.style;\n    var idxLR = i % 2;\n    var idxTB = (i >> 1) % 2;\n    stl.cssText = ['position:absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'width:0', 'height:0', // 'width: 5px',\n    // 'height: 5px',\n    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');\n    el.appendChild(marker);\n    markers.push(marker);\n  }\n\n  return markers;\n}\n\nfunction preparePointerTransformer(markers, saved) {\n  var transformer = saved.transformer;\n  var oldSrcCoords = saved.srcCoords;\n  var useOld = true;\n  var srcCoords = [];\n  var destCoords = [];\n\n  for (var i = 0; i < 4; i++) {\n    var rect = markers[i].getBoundingClientRect();\n    var ii = 2 * i;\n    var x = rect.left;\n    var y = rect.top;\n    srcCoords.push(x, y);\n    useOld &= oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n  } // Cache to avoid time consuming of `buildTransformer`.\n\n\n  return useOld ? transformer : (saved.srcCoords = srcCoords, saved.transformer = buildTransformer(srcCoords, destCoords));\n}\n/**\r\n * Find native event compat for legency IE.\r\n * Should be called at the begining of a native event listener.\r\n *\r\n * @param {Event} [e] Mouse event or touch event or pointer event.\r\n *        For lagency IE, we use `window.event` is used.\r\n * @return {Event} The native event.\r\n */\n\n\nfunction getNativeEvent(e) {\n  return e || window.event;\n}\n/**\r\n * Normalize the coordinates of the input event.\r\n *\r\n * Get the `e.qrX` and `e.qrY`, which are relative to the top-left of\r\n * the input `el`.\r\n * Get `e.qrDelta` if using mouse wheel.\r\n * Get `e.which`, see the comment inside this function.\r\n *\r\n * Do not calculate repeatly if `qrX` and `qrY` already exist.\r\n *\r\n * Notice: see comments in `clientToLocal`. check the relationship\r\n * between the result coords and the parameters `el` and `calculate`.\r\n *\r\n * @param {HTMLElement} el DOM element.\r\n * @param {Event} [e] See `getNativeEvent`.\r\n * @param {boolean} [calculate=false] Whether to force calculate\r\n *        the coordinates but not use ones provided by browser.\r\n * @return {UIEvent} The normalized native UIEvent.\r\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = getNativeEvent(e);\n\n  if (e.qrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.qrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, it may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  } // [Caution]: `e.which` from browser is not always reliable. For example,\n  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`\n  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and\n  // `mousedown (pointerdown)` is the same as Chrome does.\n\n\n  return e;\n}\n/**\r\n * @param {HTMLElement} el\r\n * @param {String} name\r\n * @param {Function} handler\r\n */\n\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    // Reproduct the console warning:\n    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.\n    // Consider marking event handler as 'passive' to make the page more responsive.\n    // Just set console log level: verbose in chrome dev tool.\n    // then the warning log will be printed when addEventListener called.\n    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    // We have not yet found a neat way to using passive. Because in qrenderer the dom event\n    // listener delegate all of the upper events of element. Some of those events need\n    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.\n    // Before passive can be adopted, these issues should be considered:\n    // (1) Whether and how a qrenderer user specifies an event listener passive. And by default,\n    // passive or not.\n    // (2) How to tread that some qrenderer event listener is passive, and some is not. If\n    // we use other way but not preventDefault of mousewheel and touchmove, browser\n    // compatibility should be handled.\n    // var opts = (env.passiveSupported && name === 'mousewheel')\n    //     ? {passive: true}\n    //     // By default, the third param of el.addEventListener is `capture: false`.\n    //     : void 0;\n    // el.addEventListener(name, handler /* , opts */);\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\r\n * preventDefault and stopPropagation.\r\n * Notice: do not use this method in qrenderer. It can only be\r\n * used by upper applications if necessary.\r\n *\r\n * @param {Event} e A mouse or touch event.\r\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n/**\r\n * This method only works for mouseup and mousedown. The functionality is restricted\r\n * for fault tolerance, See the `e.which` compatibility above.\r\n *\r\n * @param {MouseEvent} e\r\n * @return {boolean}\r\n */\n\nfunction isMiddleOrRightButtonOnMouseUpDown(e) {\n  return e.which === 2 || e.which === 3;\n}\n/**\r\n * To be removed.\r\n * @deprecated\r\n */\n\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // For backward compatibility\n\n\nexports.clientToLocal = clientToLocal;\nexports.getNativeEvent = getNativeEvent;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;\nexports.notLeftMouse = notLeftMouse;","/**\r\n * @abstract\r\n * @class qrenderer.event.Eventful\r\n * \r\n * Provide event system for the classes that do not support events, the implementation here\r\n * is similar to DOM events, the classes which need event support should mixin the functions\r\n * here.\r\n * \r\n * 为不支持事件机制的类提供事件支持，基本机制类似 DOM 事件，需要事件机制的类可以 mixin 此类中的工具函数。\r\n * \r\n * @author @Kener-林峰 <kener.linfeng@gmail.com>\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar arrySlice = Array.prototype.slice;\n/**\r\n * @method constructor Eventful\r\n * @param {Object} [eventProcessor] The object eventProcessor is the scope when\r\n *        `eventProcessor.xxx` called. 事件处理者，也就是当前事件处理函数执行时的作用域。\r\n * @param {Function} [eventProcessor.normalizeQuery]\r\n *        param: {String|Object} Raw query.\r\n *        return: {String|Object} Normalized query.\r\n * @param {Function} [eventProcessor.filter] Event will be dispatched only\r\n *        if it returns `true`.\r\n *        param: {String} eventType\r\n *        param: {String|Object} query\r\n *        return: {Boolean}\r\n * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.\r\n *        param: {String} eventType\r\n * @param {Function} [eventProcessor.afterListenerChanged] Called when any listener added or removed.\r\n *        param: {String} eventType\r\n */\n\nvar Eventful = function Eventful(eventProcessor) {\n  this._$handlers = {};\n  this._$eventProcessor = eventProcessor;\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\r\n   * @method\r\n   * The handler can only be triggered once, then removed.\r\n   *\r\n   * @param {String} event The event name.\r\n   * @param {String|Object} [query] Condition used on event filter.\r\n   * @param {Function} handler The event handler.\r\n   * @param {Object} context\r\n   */\n  one: function one(event, query, handler, context) {\n    return _on(this, event, query, handler, context, true);\n  },\n\n  /**\r\n   * @method\r\n   * Bind a handler.\r\n   *\r\n   * @param {String} event The event name.\r\n   * @param {String|Object} [query] Condition used on event filter.\r\n   * @param {Function} handler The event handler.\r\n   * @param {Object} [context]\r\n   */\n  on: function on(event, query, handler, context) {\n    return _on(this, event, query, handler, context, false);\n  },\n\n  /**\r\n   * @method\r\n   * Whether any handler has bound.\r\n   *\r\n   * @param  {String}  event\r\n   * @return {Boolean}\r\n   */\n  isSilent: function isSilent(event) {\n    var _h = this._$handlers;\n    return !_h[event] || !_h[event].length;\n  },\n\n  /**\r\n   * @method\r\n   * Unbind a event.\r\n   *\r\n   * @param {String} [event] The event name.\r\n   *        If no `event` input, \"off\" all listeners.\r\n   * @param {Function} [handler] The event handler.\r\n   *        If no `handler` input, \"off\" all listeners of the `event`.\r\n   */\n  off: function off(event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i].h !== handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    callListenerChanged(this, event);\n    return this;\n  },\n\n  /**\r\n   * @method\r\n   * Dispatch a event.\r\n   *\r\n   * @param {String} type The event name.\r\n   */\n  trigger: function trigger(type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(hItem.ctx);\n            break;\n\n          case 2:\n            hItem.h.call(hItem.ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(hItem.ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(hItem.ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  },\n\n  /**\r\n   * @method\r\n   * Dispatch a event with context, which is specified at the last parameter.\r\n   *\r\n   * @param {String} type The event name.\r\n   */\n  triggerWithContext: function triggerWithContext(type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(ctx);\n            break;\n\n          case 2:\n            hItem.h.call(ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  }\n};\n/**\r\n * @private\r\n * @method\r\n * @param {Element} eventful \r\n * @param {String} eventType \r\n */\n\nfunction callListenerChanged(eventful, eventType) {\n  var eventProcessor = eventful._$eventProcessor;\n\n  if (eventProcessor && eventProcessor.afterListenerChanged) {\n    eventProcessor.afterListenerChanged(eventType);\n  }\n}\n/**\r\n * @private\r\n * @method\r\n * @param {*} host \r\n * @param {*} query \r\n */\n\n\nfunction normalizeQuery(host, query) {\n  var eventProcessor = host._$eventProcessor;\n\n  if (query != null && eventProcessor && eventProcessor.normalizeQuery) {\n    query = eventProcessor.normalizeQuery(query);\n  }\n\n  return query;\n}\n/**\r\n * @private\r\n * @method\r\n * @param {Element} eventful \r\n * @param {Event} event \r\n * @param {*} query \r\n * @param {Function} handler \r\n * @param {Object} context \r\n * @param {Boolean} isOnce \r\n */\n\n\nfunction _on(eventful, event, query, handler, context, isOnce) {\n  var _h = eventful._$handlers;\n\n  if (typeof query === 'function') {\n    context = handler;\n    handler = query;\n    query = null;\n  }\n\n  if (!handler || !event) {\n    return eventful;\n  }\n\n  query = normalizeQuery(eventful, query);\n\n  if (!_h[event]) {\n    _h[event] = [];\n  }\n\n  for (var i = 0; i < _h[event].length; i++) {\n    if (_h[event][i].h === handler) {\n      return eventful;\n    }\n  }\n\n  var wrap = {\n    h: handler,\n    one: isOnce,\n    query: query,\n    ctx: context || eventful,\n    // FIXME\n    // Do not publish this feature util it is proved that it makes sense.\n    callAtLast: handler.qrEventfulCallAtLast\n  };\n  var lastIndex = _h[event].length - 1;\n  var lastWrap = _h[event][lastIndex];\n  lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);\n  callListenerChanged(eventful, event);\n  return eventful;\n}\n\nvar _default = Eventful;\nmodule.exports = _default;","var _constants = require(\"../../graphic/constants\");\n\nvar mathLog = _constants.mathLog;\nvar mathRound = _constants.mathRound;\n\n/**\r\n * The algoritm is learnt from\r\n * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/\r\n * And we made some optimization for matrix inversion.\r\n * Other similar approaches:\r\n * \"cv::getPerspectiveTransform\", \"Direct Linear Transformation\".\r\n */\nvar LN2 = mathLog(2);\n\nfunction determinant(rows, rank, rowStart, rowMask, colMask, detCache) {\n  var cacheKey = rowMask + '-' + colMask;\n  var fullRank = rows.length;\n\n  if (detCache.hasOwnProperty(cacheKey)) {\n    return detCache[cacheKey];\n  }\n\n  if (rank === 1) {\n    // In this case the colMask must be like: `11101111`. We can find the place of `0`.\n    var colStart = mathRound(mathLog((1 << fullRank) - 1 & ~colMask) / LN2);\n    return rows[rowStart][colStart];\n  }\n\n  var subRowMask = rowMask | 1 << rowStart;\n  var subRowStart = rowStart + 1;\n\n  while (rowMask & 1 << subRowStart) {\n    subRowStart++;\n  }\n\n  var sum = 0;\n\n  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {\n    var colTag = 1 << j;\n\n    if (!(colTag & colMask)) {\n      sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] // det(subMatrix(0, j))\n      * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);\n      colLocalIdx++;\n    }\n  }\n\n  detCache[cacheKey] = sum;\n  return sum;\n}\n/**\r\n * Usage:\r\n * ```js\r\n * var transformer = buildTransformer(\r\n *     [10, 44, 100, 44, 100, 300, 10, 300],\r\n *     [50, 54, 130, 14, 140, 330, 14, 220]\r\n * );\r\n * var out = [];\r\n * transformer && transformer([11, 33], out);\r\n * ```\r\n *\r\n * Notice: `buildTransformer` may take more than 10ms in some Android device.\r\n *\r\n * @param {Array<Number>} src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]\r\n * @param {Array<Number>} dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]\r\n * @return {Function} transformer If fail, return null/undefined.\r\n */\n\n\nfunction buildTransformer(src, dest) {\n  var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];\n  var detCache = {};\n  var det = determinant(mA, 8, 0, 0, 0, detCache);\n\n  if (det === 0) {\n    return;\n  } // `invert(mA) * dest`, that is, `adj(mA) / det * dest`.\n\n\n  var vh = [];\n\n  for (var i = 0; i < 8; i++) {\n    for (var j = 0; j < 8; j++) {\n      vh[j] == null && (vh[j] = 0);\n      vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))\n      determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];\n    }\n  }\n\n  return function (out, srcPointX, srcPointY) {\n    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;\n    out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;\n    out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;\n  };\n}\n\nexports.buildTransformer = buildTransformer;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.event.MultiDragDrop\r\n * 支持同时拖拽多个元素，按住 Ctrl 键可以多选。\r\n * \r\n * @author 大漠穷秋 <damoqiongqiu@126.com>\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar MultiDragDrop =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor MultiDragDrop\r\n   * @param {QRendererEventHandler} handler \r\n   */\n  function MultiDragDrop(handler) {\n    _classCallCheck(this, MultiDragDrop);\n\n    this.selectionMap = new Map();\n    this.handler = handler;\n    this.handler.on('mousedown', this._dragStart, this);\n  }\n  /**\r\n   * @private\r\n   * @method param\r\n   * @param {Element} target \r\n   * @param {Event} e \r\n   */\n\n\n  _createClass(MultiDragDrop, [{\n    key: \"param\",\n    value: function param(target, e) {\n      return {\n        target: target,\n        topTarget: e && e.topTarget\n      };\n    }\n    /**\r\n     * @method getSelectedItems\r\n     * 获取当前选中的元素\r\n     * @return {Map} selectionMap\r\n     */\n\n  }, {\n    key: \"getSelectedItems\",\n    value: function getSelectedItems() {\n      return this.selectionMap;\n    }\n    /**\r\n     * @method clearSelectionMap\r\n     * 清除选中\r\n     */\n\n  }, {\n    key: \"clearSelectionMap\",\n    value: function clearSelectionMap() {\n      this.selectionMap.forEach(function (el, key) {\n        el.dragging = false;\n      });\n      this.selectionMap.clear();\n    }\n    /**\r\n     * @private\r\n     * @method _dragStart\r\n     * 开始拖动\r\n     * @param {Event} e \r\n     */\n\n  }, {\n    key: \"_dragStart\",\n    value: function _dragStart(e) {\n      var _this = this;\n\n      var el = e.target;\n      var event = e.event;\n      this._draggingItem = el;\n\n      if (!el) {\n        this.clearSelectionMap();\n        return;\n      }\n\n      if (!el.draggable) {\n        return;\n      }\n\n      if (!event.ctrlKey && !this.selectionMap.get(el.id)) {\n        this.clearSelectionMap();\n      }\n\n      el.dragging = true;\n      this.selectionMap.set(el.id, el);\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.handler.on('pagemousemove', this._drag, this);\n      this.handler.on('pagemouseup', this._dragEnd, this);\n      this.selectionMap.forEach(function (el, key) {\n        console.log(el);\n\n        _this.handler.dispatchToElement(_this.param(el, e), 'dragstart', e.event);\n      });\n    }\n    /**\r\n     * @private\r\n     * @method _drag\r\n     * 拖动过程中\r\n     * @param {Event} e \r\n     */\n\n  }, {\n    key: \"_drag\",\n    value: function _drag(e) {\n      var _this2 = this;\n\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      this.selectionMap.forEach(function (el, key) {\n        el.drift(dx, dy, e);\n\n        _this2.handler.dispatchToElement(_this2.param(el, e), 'drag', e.event);\n      });\n      var dropTarget = this.handler.findHover(x, y, this._draggingItem).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (this._draggingItem !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.handler.dispatchToElement(this.param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.handler.dispatchToElement(this.param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n    /**\r\n     * @private\r\n     * @method _dragEnd\r\n     * 拖动结束\r\n     * @param {Event} e \r\n     */\n\n  }, {\n    key: \"_dragEnd\",\n    value: function _dragEnd(e) {\n      var _this3 = this;\n\n      this.selectionMap.forEach(function (el, key) {\n        el.dragging = false;\n\n        _this3.handler.dispatchToElement(_this3.param(el, e), 'dragend', e.event);\n      });\n      this.handler.off('pagemousemove', this._drag);\n      this.handler.off('pagemouseup', this._dragEnd);\n\n      if (this._dropTarget) {\n        this.handler.dispatchToElement(this.param(this._dropTarget, e), 'drop', e.event);\n      }\n\n      this._dropTarget = null;\n    }\n  }]);\n\n  return MultiDragDrop;\n}();\n\nmodule.exports = MultiDragDrop;","var eventUtil = require(\"../core/utils/event_util\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.event.GestureMgr\r\n * \r\n * Implement necessary gestures for mobile platform.\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function pinch(track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\n\nvar GestureMgr =\n/*#__PURE__*/\nfunction () {\n  function GestureMgr() {\n    _classCallCheck(this, GestureMgr);\n\n    /**\r\n     * @private\r\n     * @property {Array<Object>}\r\n     */\n    this._track = [];\n  }\n\n  _createClass(GestureMgr, [{\n    key: \"recognize\",\n    value: function recognize(event, target, root) {\n      this._doTrack(event, target, root);\n\n      return this._recognize(event);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._track.length = 0;\n      return this;\n    }\n  }, {\n    key: \"_doTrack\",\n    value: function _doTrack(event, target, root) {\n      var touches = event.touches;\n\n      if (!touches) {\n        return;\n      }\n\n      var trackItem = {\n        points: [],\n        touches: [],\n        target: target,\n        event: event\n      };\n\n      for (var i = 0, len = touches.length; i < len; i++) {\n        var touch = touches[i];\n        var pos = eventUtil.clientToLocal(root, touch, {});\n        trackItem.points.push([pos.qrX, pos.qrY]);\n        trackItem.touches.push(touch);\n      }\n\n      this._track.push(trackItem);\n    }\n  }, {\n    key: \"_recognize\",\n    value: function _recognize(event) {\n      for (var eventName in recognizers) {\n        if (recognizers.hasOwnProperty(eventName)) {\n          var gestureInfo = recognizers[eventName](this._track, event);\n\n          if (gestureInfo) {\n            return gestureInfo;\n          }\n        }\n      }\n    }\n  }]);\n\n  return GestureMgr;\n}();\n\nvar _default = GestureMgr;\nmodule.exports = _default;","var util = require(\"./core/utils/data_structure_util\");\n\nvar env = require(\"./core/env\");\n\nvar Group = require(\"./graphic/Group\");\n\nvar timsort = require(\"./core/utils/timsort\");\n\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\n\n/**\r\n * @class qrenderer.core.Storage\r\n * 内容仓库 (M)，用来存储和管理画布上的所有对象，同时提供绘制和更新队列的功能。\r\n * 需要绘制的对象首先存储在 Storage 中，然后 Painter 类会从 Storage 中依次取出进行绘图。\r\n * 利用 Storage 作为内存中转站，对于不需要刷新的对象可以不进行绘制，从而可以提升整体性能。\r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n/**\r\n * @method constructor Storage\r\n */\nvar Storage = function Storage() {\n  // jshint ignore:line\n\n  /**\r\n   * @private\r\n   * @property _roots\r\n   */\n  this._roots = []; //直接放在画布上的对象为根对象\n\n  /**\r\n   * @private\r\n   * @property _displayList\r\n   */\n\n  this._displayList = [];\n  /**\r\n   * @private\r\n   * @property _displayListLen\r\n   */\n\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\r\n   * @method traverse\r\n   * @param  {Function} cb\r\n   * @param  {Object} context\r\n   */\n  traverse: function traverse(cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\r\n   * @method getDisplayList\r\n   * 返回所有图形的绘制队列\r\n   * @param {boolean} [update=false] 是否在返回前更新该数组\r\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\r\n   *\r\n   * 详见{@link Displayable.prototype.updateDisplayList}\r\n   * @return {Array<Displayable>}\r\n   */\n  getDisplayList: function getDisplayList(update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\r\n   * @method updateDisplayList\r\n   * 更新图形的绘制队列。\r\n   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\r\n   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\r\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\r\n   */\n  updateDisplayList: function updateDisplayList(includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen;\n    env.canvasSupported && timsort(displayList, this.displayableSortFunc);\n  },\n\n  /**\r\n   * @method _updateAndAddDisplayable\r\n   * @param {*} el \r\n   * @param {*} clipPaths \r\n   * @param {*} includeIgnore \r\n   */\n  _updateAndAddDisplayable: function _updateAndAddDisplayable(el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME 效率影响\n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath 的变换是基于使用这个 clipPath 的元素\n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\r\n   * @method addRoot\r\n   * 添加图形(Shape)或者组(Group)到根节点\r\n   * @param {Element} el\r\n   */\n  addRoot: function addRoot(el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\r\n   * @method\r\n   * 删除指定的图形(Shape)或者组(Group)\r\n   * @param {string|Array.<String>} [el] 如果为空清空整个Storage\r\n   */\n  delRoot: function delRoot(el) {\n    if (el == null) {\n      // 不指定el清空\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var _i = 0, l = el.length; _i < l; _i++) {\n        this.delRoot(el[_i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n\n  /**\r\n   * @method addToStorage\r\n   * @param {Element} el \r\n   */\n  addToStorage: function addToStorage(el) {\n    if (el) {\n      el.__storage = this;\n      el.dirty(false);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @method delFromStorage\r\n   * @param {Element} el \r\n   */\n  delFromStorage: function delFromStorage(el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @method dispose\r\n   * 清空并且释放Storage\r\n   */\n  dispose: function dispose() {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: function displayableSortFunc(a, b) {\n    if (a.qlevel === b.qlevel) {\n      if (a.z === b.z) {\n        // if (a.z2 === b.z2) {\n        //     // FIXME Slow has renderidx compare\n        //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n        //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n        //     return a.__renderidx - b.__renderidx;\n        // }\n        return a.z2 - b.z2;\n      }\n\n      return a.z - b.z;\n    }\n\n    return a.qlevel - b.qlevel;\n  }\n};\nvar _default = Storage;\nmodule.exports = _default;","var classUtil = require(\"../core/utils/class_util\");\n\nvar Element = require(\"./Element\");\n\nvar BoundingRect = require(\"./transform/BoundingRect\");\n\nvar _data_structure_util = require(\"../core/utils/data_structure_util\");\n\nvar extend = _data_structure_util.extend;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.Group\r\n * \r\n * - Group is a container, it's not visible.\r\n * - Group can have child nodes, not the other Element types.\r\n * - The transformations applied to Group will apply to its children too.\r\n * \r\n * - Group 是一个容器，本身不可见。\r\n * - Group 可以插入子节点，其它类型不能。\r\n * - Group 上的变换也会被应用到子节点上。\r\n * \r\n *      @example small frame\r\n *      let Group = require('qrenderer/Group');\r\n *      let Circle = require('qrenderer/graphic/shape/Circle');\r\n *      let g = new Group();\r\n *      g.position[0] = 100;\r\n *      g.position[1] = 100;\r\n *      g.add(new Circle({\r\n *          style: {\r\n *              x: 100,\r\n *              y: 100,\r\n *              r: 20,\r\n *          }\r\n *      }));\r\n *      qr.add(g);\r\n */\nvar Group =\n/*#__PURE__*/\nfunction (_Element) {\n  _inherits(Group, _Element);\n\n  /**\r\n   * @method constructor Group\r\n   */\n  function Group() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Group);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Group).call(this, options));\n    /**\r\n     * @private\r\n     * @property _children\r\n     */\n\n    _this._children = [];\n    /**\r\n     * @private\r\n     * @property __storage\r\n     */\n\n    _this.__storage = null;\n    /**\r\n     * @private\r\n     * @property __dirty\r\n     */\n\n    _this.__dirty = true;\n    /**\r\n     * @property isGroup\r\n     */\n\n    _this.isGroup = true;\n    /**\r\n     * @property {String}\r\n     */\n\n    _this.type = 'group';\n    /**\r\n     * @property {Boolean} 所有子孙元素是否响应鼠标事件\r\n     */\n\n    _this.silent = false;\n    classUtil.copyOwnProperties(_assertThisInitialized(_this), options);\n    return _this;\n  }\n  /**\r\n   * @method children\r\n   * @return {Array<Element>}\r\n   */\n\n\n  _createClass(Group, [{\n    key: \"children\",\n    value: function children() {\n      return this._children.slice();\n    }\n    /**\r\n     * @method childAt\r\n     * 获取指定 index 的儿子节点\r\n     * @param  {Number} idx\r\n     * @return {Element}\r\n     */\n\n  }, {\n    key: \"childAt\",\n    value: function childAt(idx) {\n      return this._children[idx];\n    }\n    /**\r\n     * @method childOfName\r\n     * 获取指定名字的儿子节点\r\n     * @param  {String} name\r\n     * @return {Element}\r\n     */\n\n  }, {\n    key: \"childOfName\",\n    value: function childOfName(name) {\n      var children = this._children;\n\n      for (var i = 0; i < children.length; i++) {\n        if (children[i].name === name) {\n          return children[i];\n        }\n      }\n    }\n    /**\r\n     * @method childCount\r\n     * @return {Number}\r\n     */\n\n  }, {\n    key: \"childCount\",\n    value: function childCount() {\n      return this._children.length;\n    }\n    /**\r\n     * @method add\r\n     * 添加子节点到最后\r\n     * @param {Element} child\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(child) {\n      if (child && child !== this && child.parent !== this) {\n        this._children.push(child);\n\n        this._doAdd(child);\n      }\n\n      return this;\n    }\n    /**\r\n     * @method addBefore\r\n     * 添加子节点在 nextSibling 之前\r\n     * @param {Element} child\r\n     * @param {Element} nextSibling\r\n     */\n\n  }, {\n    key: \"addBefore\",\n    value: function addBefore(child, nextSibling) {\n      if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n        var children = this._children;\n        var idx = children.indexOf(nextSibling);\n\n        if (idx >= 0) {\n          children.splice(idx, 0, child);\n\n          this._doAdd(child);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * @private\r\n     * @method _doAdd\r\n     * @param {*} child \r\n     */\n\n  }, {\n    key: \"_doAdd\",\n    value: function _doAdd(child) {\n      if (child.parent) {\n        child.parent.remove(child);\n      }\n\n      child.parent = this; //把子节点的 parent 属性指向自己，在事件冒泡的时候会使用 parent 属性。\n\n      var storage = this.__storage;\n      var qr = this.__qr;\n\n      if (storage && storage !== child.__storage) {\n        storage.addToStorage(child);\n\n        if (child instanceof Group) {\n          child.addChildrenToStorage(storage);\n        }\n      }\n\n      qr && qr.refresh();\n    }\n    /**\r\n     * @method remove\r\n     * 移除子节点\r\n     * @param {Element} child\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(child) {\n      var qr = this.__qr;\n      var storage = this.__storage;\n      var children = this._children;\n      var idx = dataUtil.indexOf(children, child);\n\n      if (idx < 0) {\n        return this;\n      }\n\n      children.splice(idx, 1);\n      child.parent = null;\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      qr && qr.refresh();\n      return this;\n    }\n    /**\r\n     * @method removeAll\r\n     * 移除所有子节点\r\n     */\n\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      var children = this._children;\n      var storage = this.__storage;\n      var child;\n      var i;\n\n      for (i = 0; i < children.length; i++) {\n        child = children[i];\n\n        if (storage) {\n          storage.delFromStorage(child);\n\n          if (child instanceof Group) {\n            child.delChildrenFromStorage(storage);\n          }\n        }\n\n        child.parent = null;\n      }\n\n      children.length = 0;\n      return this;\n    }\n    /**\r\n     * @method eachChild\r\n     * 遍历所有子节点\r\n     * @param  {Function} cb\r\n     * @param  {Object}   context\r\n     */\n\n  }, {\n    key: \"eachChild\",\n    value: function eachChild(cb, context) {\n      var children = this._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        cb.call(context, child, i);\n      }\n\n      return this;\n    }\n    /**\r\n     * @method traverse\r\n     * 深度优先遍历所有子孙节点\r\n     * @param  {Function} cb\r\n     * @param  {Object}   context\r\n     */\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(cb, context) {\n      for (var i = 0; i < this._children.length; i++) {\n        var child = this._children[i];\n        cb.call(context, child);\n\n        if (child.type === 'group') {\n          child.traverse(cb, context);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * @method addChildrenToStorage\r\n     * @param {Storage} storage \r\n     */\n\n  }, {\n    key: \"addChildrenToStorage\",\n    value: function addChildrenToStorage(storage) {\n      for (var i = 0; i < this._children.length; i++) {\n        var child = this._children[i];\n        storage.addToStorage(child);\n\n        if (child instanceof Group) {\n          child.addChildrenToStorage(storage);\n        }\n      }\n    }\n    /**\r\n     * @method delChildrenFromStorage\r\n     * @param {Storage} storage \r\n     */\n\n  }, {\n    key: \"delChildrenFromStorage\",\n    value: function delChildrenFromStorage(storage) {\n      for (var i = 0; i < this._children.length; i++) {\n        var child = this._children[i];\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n    }\n    /**\r\n     * @method dirty\r\n     * @return {Group}\r\n     */\n\n  }, {\n    key: \"dirty\",\n    value: function dirty() {\n      this.__dirty = true;\n      this.__qr && this.__qr.refresh();\n      return this;\n    }\n    /**\r\n     * @method getBoundingRect\r\n     * @return {BoundingRect}\r\n     */\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect(includeChildren) {\n      // TODO Caching\n      var rect = null;\n      var tmpRect = new BoundingRect(0, 0, 0, 0);\n      var children = includeChildren || this._children;\n      var tmpMat = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n\n        if (child.ignore || child.invisible) {\n          continue;\n        }\n\n        var childRect = child.getBoundingRect();\n        var transform = child.getLocalTransform(tmpMat); // TODO\n        // The boundingRect cacluated by transforming original\n        // rect may be bigger than the actual bundingRect when rotation\n        // is used. (Consider a circle rotated aginst its center, where\n        // the actual boundingRect should be the same as that not be\n        // rotated.) But we can not find better approach to calculate\n        // actual boundingRect yet, considering performance.\n\n        if (transform) {\n          tmpRect.copy(childRect);\n          tmpRect.applyTransform(transform);\n          rect = rect || tmpRect.clone();\n          rect.union(tmpRect);\n        } else {\n          rect = rect || childRect.clone();\n          rect.union(childRect);\n        }\n      }\n\n      return rect || tmpRect;\n    }\n  }]);\n\n  return Group;\n}(Element);\n\nvar _default = Group;\nmodule.exports = _default;","var guid = require(\"../core/utils/guid\");\n\nvar Eventful = require(\"../event/Eventful\");\n\nvar Transformable = require(\"./transform/Transformable\");\n\nvar Animatable = require(\"../animation/Animatable\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../core/utils/class_util\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.graphic.Element\r\n * \r\n * Root class, everything in QuarkRenderer is an Element. \r\n * This is an abstract class, please don't creat an instance directly.\r\n * \r\n * 根类，QRenderer 中所有对象都是 Element 的子类。这是一个抽象类，请不要直接创建这个类的实例。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Element =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor Element\r\n   */\n  function Element(options) {\n    _classCallCheck(this, Element);\n\n    /**\r\n     * @protected\r\n     * @property options 配置项\r\n     */\n    this.options = options;\n    /**\r\n     * @property {String} id\r\n     */\n\n    this.id = this.options.id || guid();\n    /**\r\n     * @property {String} type 元素类型\r\n     */\n\n    this.type = 'element';\n    /**\r\n     * @property {String} name 元素名字\r\n     */\n\n    this.name = '';\n    /**\r\n     * @private\r\n     * @property {QuarkRenderer} __qr\r\n     * \r\n     * QuarkRenderer instance will be assigned when element is associated with qrenderer\r\n     * \r\n     * QuarkRenderer 实例对象，会在 element 添加到 qrenderer 实例中后自动赋值\r\n     */\n\n    this.__qr = null;\n    /**\r\n     * @private\r\n     * @property {Boolean} __dirty\r\n     * \r\n     * Dirty flag. From which painter will determine if this displayable object needs to be repainted.\r\n     * \r\n     * 这是一个非常重要的标志位，在绘制大量对象的时候，把 __dirty 标记为 false 可以节省大量操作。\r\n     */\n\n    this.__dirty = true;\n    /**\r\n     * @private\r\n     * @property  _rect\r\n     */\n\n    this._rect = null;\n    /**\r\n     * @property {Boolean} ignore\r\n     * \r\n     * Whether ignore drawing and events of this object.\r\n     * \r\n     * 为 true 时忽略图形的绘制以及事件触发\r\n     */\n\n    this.ignore = false;\n    /**\r\n     * @property {Path} clipPath\r\n     * \r\n     * This is used for clipping path, all the paths inside Group will be clipped by this path, \r\n     * which will inherit the transformation of the clipped object.\r\n     * \r\n     * 用于裁剪的路径，所有 Group 内的路径在绘制时都会被这个路径裁剪，该路径会继承被裁减对象的变换。\r\n     * \r\n     * @readOnly\r\n     * @see http://www.w3.org/TR/2dcontext/#clipping-region\r\n     */\n\n    this.clipPath = null;\n    /**\r\n     * @property {Boolean} isGroup\r\n     * \r\n     * Whether this object is a Group.\r\n     * \r\n     * 是否是 Group\r\n     */\n\n    this.isGroup = false;\n    classUtil.inheritProperties(this, Transformable, this.options);\n    classUtil.inheritProperties(this, Eventful, this.options);\n    classUtil.inheritProperties(this, Animatable, this.options);\n    classUtil.copyOwnProperties(this, this.options);\n  }\n  /**\r\n   * @method\r\n   * \r\n   * Drift element\r\n   * \r\n   * 移动元素\r\n   * \r\n   * @param  {Number} dx dx on the global space\r\n   * @param  {Number} dy dy on the global space\r\n   */\n\n\n  _createClass(Element, [{\n    key: \"drift\",\n    value: function drift(dx, dy) {\n      switch (this.draggable) {\n        case 'horizontal':\n          dy = 0;\n          break;\n\n        case 'vertical':\n          dx = 0;\n          break;\n      }\n\n      var m = this.transform;\n\n      if (!m) {\n        m = this.transform = [1, 0, 0, 1, 0, 0];\n      }\n\n      m[4] += dx;\n      m[5] += dy;\n      this.decomposeTransform();\n      this.dirty(false);\n    }\n    /**\r\n     * @property {Function} beforeUpdate\r\n     * \r\n     * Hook before update.\r\n     * \r\n     * 刷新之前回调。\r\n     */\n\n  }, {\n    key: \"beforeUpdate\",\n    value: function beforeUpdate() {}\n    /**\r\n     * @property {Function} update\r\n     * \r\n     * Update each frame.\r\n     * \r\n     * 刷新，每一帧回调。\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.updateTransform();\n    }\n    /**\r\n     * @property {Function} afterUpdate\r\n     * \r\n     * Hook after update.\r\n     * \r\n     * 刷新之后回调。\r\n     */\n\n  }, {\n    key: \"afterUpdate\",\n    value: function afterUpdate() {}\n    /**\r\n     * @property {Function} traverse\r\n     * @param  {Function} cb\r\n     * @param  {Object}   context\r\n     */\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(cb, context) {}\n    /**\r\n     * @protected\r\n     * @method attrKV\r\n     * @param {String} key\r\n     * @param {Object} value\r\n     */\n\n  }, {\n    key: \"attrKV\",\n    value: function attrKV(key, value) {\n      if (key === 'position' || key === 'scale' || key === 'origin') {\n        // Copy the array\n        if (value) {\n          var target = this[key];\n\n          if (!target) {\n            target = this[key] = [];\n          }\n\n          target[0] = value[0];\n          target[1] = value[1];\n        }\n      } else {\n        this[key] = value;\n      }\n    }\n    /**\r\n     * @method hide\r\n     * \r\n     * Hide the element.\r\n     * \r\n     * 隐藏元素。\r\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.ignore = true;\n      this.__qr && this.__qr.refresh();\n    }\n    /**\r\n     * @method show\r\n     * \r\n     * Show the element.\r\n     * \r\n     * 显示元素。\r\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.ignore = false;\n      this.__qr && this.__qr.refresh();\n    }\n    /**\r\n     * @method attr\r\n     * \r\n     * Modify attribute.\r\n     * \r\n     * 修改对象上的属性。\r\n     * \r\n     * @param {String|Object} key\r\n     * @param {*} value\r\n     */\n\n  }, {\n    key: \"attr\",\n    value: function attr(key, value) {\n      if (typeof key === 'String') {\n        this.attrKV(key, value);\n      } else if (dataUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            this.attrKV(name, key[name]);\n          }\n        }\n      }\n\n      this.dirty(false);\n      return this;\n    }\n    /**\r\n     * @method setClipPath\r\n     * \r\n     * Set the clip path.\r\n     * \r\n     * 设置剪裁路径。\r\n     * \r\n     * @param {Path} clipPath\r\n     */\n\n  }, {\n    key: \"setClipPath\",\n    value: function setClipPath(clipPath) {\n      var qr = this.__qr;\n\n      if (qr) {\n        clipPath.addSelfToQr(qr);\n      } // Remove previous clip path\n\n\n      if (this.clipPath && this.clipPath !== clipPath) {\n        this.removeClipPath();\n      }\n\n      this.clipPath = clipPath;\n      clipPath.__qr = qr;\n      clipPath.__clipTarget = this; //TODO: FIX this，需要重写一下，考虑把 Element 类和 Displayable 类合并起来。\n      //dirty() 方法定义在子类 Displayable 中，这里似乎不应该直接调用，作为父类的 Element 不应该了解子类的实现，否则不易理解和维护。\n      //另，Displayable 中的 dirty() 方法没有参数，而孙类 Path 中的 dirty() 方法有参数。\n\n      this.dirty(false);\n    }\n    /**\r\n     * @method removeClipPath\r\n     * \r\n     * Remove the clip path.\r\n     * \r\n     * 删除剪裁路径。\r\n     * \r\n     */\n\n  }, {\n    key: \"removeClipPath\",\n    value: function removeClipPath() {\n      var clipPath = this.clipPath;\n\n      if (clipPath) {\n        if (clipPath.__qr) {\n          clipPath.removeSelfFromQr(clipPath.__qr);\n        }\n\n        clipPath.__qr = null;\n        clipPath.__clipTarget = null;\n        this.clipPath = null;\n        this.dirty(false);\n      }\n    }\n    /**\r\n     * @protected\r\n     * @method dirty\r\n     * \r\n     * Mark displayable element dirty and refresh next frame.\r\n     * \r\n     * 把元素标记成脏的，在下一帧中刷新。\r\n     */\n\n  }, {\n    key: \"dirty\",\n    value: function dirty() {\n      this.__dirty = this.__dirtyText = true;\n      this._rect = null;\n      this.__qr && this.__qr.refresh();\n    }\n    /**\r\n     * @method addSelfToQr\r\n     * Add self to qrenderer instance.\r\n     * Not recursively because it will be invoked when element added to storage.\r\n     * \r\n     * 把当前对象添加到 qrenderer 实例中去。\r\n     * 不会递归添加，因为当元素被添加到 storage 中的时候会执行递归操作。\r\n     * \r\n     * @param {QuarkRenderer} qr\r\n     */\n\n  }, {\n    key: \"addSelfToQr\",\n    value: function addSelfToQr(qr) {\n      this.__qr = qr; // 添加动画\n\n      var animationProcessList = this.animationProcessList;\n\n      if (animationProcessList) {\n        for (var i = 0; i < animationProcessList.length; i++) {\n          qr.globalAnimationMgr.addAnimationProcess(animationProcessList[i]);\n        }\n      }\n\n      if (this.clipPath) {\n        this.clipPath.addSelfToQr(qr);\n      }\n    }\n    /**\r\n     * @method removeSelfFromQr\r\n     * Remove self from qrenderer instance.\r\n     * \r\n     * 把当前对象从 qrenderer 实例中删除。\r\n     * \r\n     * @param {QuarkRenderer} qr\r\n     */\n\n  }, {\n    key: \"removeSelfFromQr\",\n    value: function removeSelfFromQr(qr) {\n      this.__qr = null; // 移除动画\n\n      var animationProcessList = this.animationProcessList;\n\n      if (animationProcessList) {\n        for (var i = 0; i < animationProcessList.length; i++) {\n          qr.globalAnimationMgr.removeAnimationProcess(animationProcessList[i]);\n        }\n      }\n\n      if (this.clipPath) {\n        this.clipPath.removeSelfFromQr(qr);\n      }\n    }\n  }]);\n\n  return Element;\n}();\n\nclassUtil.mixin(Element, Animatable);\nclassUtil.mixin(Element, Transformable);\nclassUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;","var matrix = require(\"../../core/utils/matrix\");\n\nvar vector = require(\"../../core/utils/vector\");\n\nvar _constants = require(\"../constants\");\n\nvar mathSqrt = _constants.mathSqrt;\nvar mathAtan2 = _constants.mathAtan2;\n\nvar classUtil = require(\"../../core/utils/class_util\");\n\n/**\r\n * @abstract\r\n * @class qrenderer.graphic.Transformable\r\n * 提供变换扩展\r\n * @author pissang (https://www.github.com/pissang)\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\nvar scaleTmp = [];\nvar tmpTransform = [];\nvar originTransform = matrix.create();\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\r\n * @method constructor Transformable\r\n */\n\n\nvar Transformable = function Transformable() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  /**\r\n   * @property {Array<Number>}\r\n   * 旋转角度\r\n   */\n  this.rotation = 0;\n  /**\r\n   * @property {Array<Number>}\r\n   * 平移\r\n   */\n\n  this.position = [0, 0];\n  /**\r\n   * @property {Array<Number>}\r\n   * 缩放\r\n   */\n\n  this.scale = [1, 1];\n  /**\r\n   * @property {Array<Number>}\r\n   * 扭曲\r\n   */\n\n  this.skew = [1, 1];\n  /**\r\n   * @property {Array<Number>}\r\n   * 翻转\r\n   */\n\n  this.flip = [1, 1];\n  /**\r\n   * @property {Array<Number>}\r\n   * 变换的原点，默认为最左上角的(0,0)点\r\n   */\n\n  this.origin = [0, 0];\n  classUtil.copyOwnProperties(this, opts);\n};\n\nTransformable.prototype.transform = null;\n/**\r\n * @method needLocalTransform\r\n * 判断是否需要有坐标变换\r\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\r\n */\n\nTransformable.prototype.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\nTransformable.prototype.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  var globalScaleRatio = this.globalScaleRatio;\n\n  if (globalScaleRatio != null && globalScaleRatio !== 1) {\n    this.getGlobalScale(scaleTmp);\n    var relX = scaleTmp[0] < 0 ? -1 : 1;\n    var relY = scaleTmp[1] < 0 ? -1 : 1;\n    var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;\n    var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;\n    m[0] *= sx;\n    m[1] *= sx;\n    m[2] *= sy;\n    m[3] *= sy;\n  }\n\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\nTransformable.prototype.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\r\n * @method setTransform\r\n * 将自己的transform应用到context上\r\n * @param {CanvasRenderingContext2D} ctx\r\n */\n\n\nTransformable.prototype.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\nTransformable.prototype.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nTransformable.prototype.setLocalTransform = function (m) {\n  if (!m) {\n    // TODO return or set identity?\n    return;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = mathSqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = mathSqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = mathAtan2(-m[1] / sy, m[0] / sx);\n};\n/**\r\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\r\n */\n\n\nTransformable.prototype.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var origin = this.origin;\n\n  if (origin && (origin[0] || origin[1])) {\n    originTransform[4] = origin[0];\n    originTransform[5] = origin[1];\n    matrix.mul(tmpTransform, m, originTransform);\n    tmpTransform[4] -= origin[0];\n    tmpTransform[5] -= origin[1];\n    m = tmpTransform;\n  }\n\n  this.setLocalTransform(m);\n};\n/**\r\n * @method getGlobalScale\r\n * Get global scale\r\n * @return {Array<Number>}\r\n */\n\n\nTransformable.prototype.getGlobalScale = function (out) {\n  var m = this.transform;\n  out = out || [];\n\n  if (!m) {\n    out[0] = 1;\n    out[1] = 1;\n    return out;\n  }\n\n  out[0] = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n  out[1] = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    out[0] = -out[0];\n  }\n\n  if (m[3] < 0) {\n    out[1] = -out[1];\n  }\n\n  return out;\n};\n/**\r\n * @method transformCoordToLocal\r\n * 变换坐标位置到 shape 的局部坐标空间\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Array<Number>}\r\n */\n\n\nTransformable.prototype.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\r\n * @method transformCoordToGlobal\r\n * 变换局部坐标位置到全局坐标空间\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Array<Number>}\r\n */\n\n\nTransformable.prototype.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\r\n * @static\r\n * @method getLocalTransform\r\n * @param {Object} target\r\n * @param {Array<Number>} target.origin\r\n * @param {Number} target.rotation\r\n * @param {Array<Number>} target.position\r\n * @param {Array<Number>} [m]\r\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;","var _constants = require(\"../../graphic/constants\");\n\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\n\n/**\r\n * 3x2矩阵操作类\r\n * @exports qrenderer/core/matrix\r\n */\n\n/* global Float32Array */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\r\n * Create a identity matrix.\r\n * @return {Float32Array|Array.<Number>}\r\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\r\n * 设置矩阵为单位矩阵\r\n * @param {Float32Array|Array.<Number>} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * 复制矩阵\r\n * @param {Float32Array|Array.<Number>} out\r\n * @param {Float32Array|Array.<Number>} m\r\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\r\n * 矩阵相乘\r\n * @param {Float32Array|Array.<Number>} out\r\n * @param {Float32Array|Array.<Number>} m1\r\n * @param {Float32Array|Array.<Number>} m2\r\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\r\n * 平移变换\r\n * @param {Float32Array|Array.<Number>} out\r\n * @param {Float32Array|Array.<Number>} a\r\n * @param {Float32Array|Array.<Number>} v\r\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\r\n * 旋转变换\r\n * @param {Float32Array|Array.<Number>} out\r\n * @param {Float32Array|Array.<Number>} a\r\n * @param {Number} rad\r\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = mathSin(rad);\n  var ct = mathCos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\r\n * 缩放变换\r\n * @param {Float32Array|Array.<Number>} out\r\n * @param {Float32Array|Array.<Number>} a\r\n * @param {Float32Array|Array.<Number>} v\r\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\r\n * 求逆矩阵\r\n * @param {Float32Array|Array.<Number>} out\r\n * @param {Float32Array|Array.<Number>} a\r\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\r\n * Clone a new matrix.\r\n * @param {Float32Array|Array.<Number>} a\r\n */\n\n\nfunction clone(a) {\n  var b = create();\n  copy(b, a);\n  return b;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\nexports.clone = clone;","var AnimationProcess = require(\"./AnimationProcess\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\n/**\r\n * @class qrenderer.animation.Animatable\r\n * \r\n * 动画接口类，在 Element 类中 mixin 此类提供的功能，为元素提供动画功能。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n\n/**\r\n * @abstract\r\n * @method constructor Animatable\r\n */\nvar Animatable = function Animatable() {\n  /**\r\n   * @property {qrenderer.animation.AnimationProcess}\r\n   * @readOnly\r\n   */\n  this.animationProcessList = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\r\n   * @method \r\n   * 创建动画实例\r\n   * @param {String} path The path to fetch value from object, like 'a.b.c'.\r\n   * @param {Boolean} [loop=false] Whether to loop animation.\r\n   * @return {qrenderer.animation.AnimationProcess}\r\n   * @example\r\n   * el.animate('style', false)\r\n   *   .when(1000, {x: 10} )\r\n   *   .done(function(){ // Animation done })\r\n   *   .start()\r\n   */\n  animate: function animate(path, loop) {\n    var target;\n    var animatingShape = false;\n    var animatable = this;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = animatable; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = animatable;\n    }\n\n    if (!target) {\n      console.log('Property \"' + path + '\" is not existed in element ' + animatable.id);\n      return;\n    }\n\n    var animationProcess = new AnimationProcess(target, loop);\n    animationProcess.during(function (target) {\n      animatable.dirty(animatingShape);\n    }).done(function () {\n      // FIXME AnimationProcess will not be removed if use `AnimationProcess#stop` to stop animation\n      animatable.animationProcessList.splice(dataUtil.indexOf(animatable.animationProcessList, animationProcess), 1);\n    });\n    animatable.animationProcessList.push(animationProcess); // If animate after added to the qrenderer\n\n    if (this.__qr) {\n      this.__qr.globalAnimationMgr.addAnimationProcess(animationProcess);\n    }\n\n    return animationProcess;\n  },\n\n  /**\r\n   * @method\r\n   * 停止动画\r\n   * @param {Boolean} forwardToLast If move to last frame before stop\r\n   */\n  stopAnimation: function stopAnimation(forwardToLast) {\n    this.animationProcessList.forEach(function (ap, index) {\n      ap.stop(forwardToLast);\n    });\n    this.animationProcessList.length = 0;\n    return this;\n  },\n\n  /**\r\n   * @method\r\n   * Caution: this method will stop previous animation.\r\n   * So do not use this method to one element twice before\r\n   * animation starts, unless you know what you are doing.\r\n   * @param {Object} [target]\r\n   * @param {Number} [time=500] Time in ms\r\n   * @param {String} [easing='linear']\r\n   * @param {Number} [delay=0]\r\n   * @param {Function} [callback]\r\n   * @param {Function} [forceAnimate] Prevent stop animation and callbackm immediently when target values are the same as current values.\r\n   *\r\n   * @example\r\n   *  // Animate position\r\n   *  el.animateTo({\r\n   *      position: [10, 10]\r\n   *  }, function () { // done })\r\n   *\r\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\r\n   *  el.animateTo({\r\n   *      shape: {\r\n   *          width: 500\r\n   *      },\r\n   *      style: {\r\n   *          fill: 'red'\r\n   *      }\r\n   *      position: [10, 10]\r\n   *  }, 100, 100, 'cubicOut', function () { // done })\r\n   */\n  animateTo: function animateTo(target, time, delay, easing, callback, forceAnimate) {\n    _doAnimation(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\r\n   * @method\r\n   * Animate from the target state to current state.\r\n   * The params and the return value are the same as `this.animateTo`.\r\n   * @param {Object} [target]\r\n   * @param {Number} [time=500] Time in ms\r\n   * @param {String} [easing='linear']\r\n   * @param {Number} [delay=0]\r\n   * @param {Function} [callback]\r\n   * @param {Function} [forceAnimate] Prevent stop animation and callbackm immediently when target values are the same as current values.\r\n   *\r\n   */\n  animateFrom: function animateFrom(target, time, delay, easing, callback, forceAnimate) {\n    _doAnimation(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n/**\r\n * @private\r\n * @method\r\n * @param {Element} animatable \r\n * @param {Element} target \r\n * @param {Number} time \r\n * @param {Number} delay \r\n * @param {String} easing \r\n * @param {Function} callback \r\n * @param {Boolean} forceAnimate \r\n * @param {Boolean} reverse \r\n */\n\nfunction _doAnimation(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (dataUtil.isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (dataUtil.isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (dataUtil.isFunction(delay)) {\n        callback = delay;\n        delay = 0;\n      } // animateTo(target, callback)\n      else if (dataUtil.isFunction(time)) {\n          callback = time;\n          time = 500;\n        } // animateTo(target)\n        else if (!time) {\n            time = 500;\n          } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // AnimationProcess may be removed immediately after start\n  // if there is nothing to animate\n\n  var animationProcessList = animatable.animationProcessList.slice();\n  var count = animationProcessList.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animationProcessList. This should be checked before animationProcessList[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animationProcessList created\n  // Incase any animationProcess is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animationProcessList.length; i++) {\n    animationProcessList[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\r\n * @private\r\n * @method\r\n * \r\n * @param {Element} animatable\r\n * @param {String} path=''\r\n * @param {Object} source=animatable\r\n * @param {Object} target\r\n * @param {Number} [time=500]\r\n * @param {Number} [delay=0]\r\n * @param {Boolean} [reverse] If `true`, animate\r\n *        from the `target` to current state.\r\n *\r\n * @example\r\n *  // Animate position\r\n *  el._animateToShallow({\r\n *      position: [10, 10]\r\n *  })\r\n *\r\n *  // Animate shape, style and position in 100ms, delayed 100ms\r\n *  el._animateToShallow({\r\n *      shape: {\r\n *          width: 500\r\n *      },\r\n *      style: {\r\n *          fill: 'red'\r\n *      }\r\n *      position: [10, 10]\r\n *  }, 100, 100)\r\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var prop in target) {\n    if (!target.hasOwnProperty(prop)) {\n      continue;\n    }\n\n    if (source[prop] != null) {\n      if (dataUtil.isObject(target[prop]) && !dataUtil.isArrayLike(target[prop])) {\n        animateToShallow(animatable, path ? path + '.' + prop : prop, source[prop], target[prop], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[prop] = source[prop];\n          setAttrByPath(animatable, path, prop, target[prop]);\n        } else {\n          objShallow[prop] = target[prop];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[prop] != null && !reverse) {\n      setAttrByPath(animatable, path, prop, target[prop]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, prop, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(prop, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][prop] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;","var dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar Track = require(\"./Track\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.animation.AnimationProcess\r\n * \r\n * AnimationProcess 表示一次完整的动画过程，每一个元素（Element）中都有一个列表，用来存储本实例上的动画过程。\r\n * GlobalAnimationMgr 负责维护和调度所有 AnimationProcess 实例。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n\n/**\r\n * @method constructor AnimationProcess\r\n * @param {Object} target 需要进行动画的元素\r\n * @param {Boolean} loop 动画是否循环播放\r\n * @param {Function} getter\r\n * @param {Function} setter\r\n */\n// let AnimationProcess = function (target, loop, getter, setter) {\n// };\n// AnimationProcess.prototype = {};\nvar AnimationProcess =\n/*#__PURE__*/\nfunction () {\n  function AnimationProcess(target, loop, getter, setter) {\n    _classCallCheck(this, AnimationProcess);\n\n    this._trackCacheMap = new Map();\n    this._target = target;\n    this._loop = loop || false;\n\n    this._getter = getter || function (target, key) {\n      return target[key];\n    };\n\n    this._setter = setter || function (target, key, value) {\n      target[key] = value;\n    };\n\n    this._delay = 0;\n    this._paused = false;\n    this._doneList = []; //callback list when the entire animation process is finished\n\n    this._onframeList = []; //callback list for each frame\n  }\n  /**\r\n   * @method when\r\n   * 为每一种需要进行动画的属性创建一条轨道\r\n   * @param  {Number} time 关键帧时间，单位ms\r\n   * @param  {Object} props 关键帧的属性值，key-value表示\r\n   * @return {qrenderer.animation.AnimationProcess}\r\n   */\n\n\n  _createClass(AnimationProcess, [{\n    key: \"when\",\n    value: function when(time, props) {\n      for (var propName in props) {\n        if (!props.hasOwnProperty(propName)) {\n          continue;\n        } // Invalid value\n\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // qrLog('Invalid property ' + propName);\n          continue;\n        }\n\n        var track = this._trackCacheMap.get(propName);\n\n        if (!track) {\n          track = new Track({\n            _target: this._target,\n            _getter: this._getter,\n            _setter: this._setter,\n            _loop: this._loop,\n            _delay: this._delay\n          });\n        }\n\n        if (time !== 0) {\n          track.addKeyFrame({\n            time: 0,\n            value: dataUtil.cloneValue(value)\n          });\n        }\n\n        track.addKeyFrame({\n          time: time,\n          value: props[propName]\n        });\n\n        this._trackCacheMap.set(propName, track);\n      }\n\n      return this;\n    }\n    /**\r\n     * @method during\r\n     * 添加动画每一帧的回调函数\r\n     * @param  {Function} callback\r\n     * @return {qrenderer.animation.AnimationProcess}\r\n     */\n\n  }, {\n    key: \"during\",\n    value: function during(callback) {\n      this._onframeList.push(callback);\n\n      return this;\n    }\n    /**\r\n     * @private\r\n     * @method _doneCallback\r\n     * 动画过程整体结束的时候回调此函数\r\n     */\n\n  }, {\n    key: \"_doneCallback\",\n    value: function _doneCallback() {\n      var _this = this;\n\n      this._doneList.forEach(function (fn, index) {\n        fn.call(_this);\n      });\n\n      this._trackCacheMap = new Map();\n    }\n    /**\r\n     * @method isFinished\r\n     * 判断整个动画过程是否已经完成，所有 Track 上的动画都完成则整个动画过程完成\r\n     */\n\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      var isFinished = true;\n\n      _toConsumableArray(this._trackCacheMap.values()).forEach(function (track, index) {\n        if (!track.isFinished) {\n          isFinished = false;\n        }\n      });\n\n      return isFinished;\n    }\n    /**\r\n     * @method start\r\n     * 开始执行动画\r\n     * @param  {String|Function} [easing] 缓动函数名称，详见{@link qrenderer.animation.easing 缓动引擎}\r\n     * @param  {Boolean} forceAnimate\r\n     * @return {qrenderer.animation.AnimationProcess}\r\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(easing, forceAnimate) {\n      var _this2 = this;\n\n      var self = this;\n\n      var keys = _toConsumableArray(this._trackCacheMap.keys());\n\n      keys.forEach(function (propName, index) {\n        if (!_this2._trackCacheMap.get(propName)) {\n          return;\n        }\n\n        var track = _this2._trackCacheMap.get(propName);\n\n        track.start(easing, propName, forceAnimate);\n      }); // This optimization will help the case that in the upper application\n      // the view may be refreshed frequently, where animation will be\n      // called repeatly but nothing changed.\n\n      if (!keys.length) {\n        this._doneCallback();\n      }\n\n      return this;\n    }\n    /**\r\n     * @method stop\r\n     * 停止动画\r\n     * @param {Boolean} forwardToLast If move to last frame before stop\r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(forwardToLast) {\n      var _this3 = this;\n\n      _toConsumableArray(this._trackCacheMap.values()).forEach(function (track, index) {\n        track.stop(_this3._target, 1);\n      });\n\n      this._trackCacheMap = new Map();\n    }\n    /**\r\n     * @method nextFrame\r\n     * 进入下一帧\r\n     * @param {Number} time  当前时间\r\n     * @param {Number} delta 时间偏移量\r\n     */\n\n  }, {\n    key: \"nextFrame\",\n    value: function nextFrame(time, delta) {\n      var deferredEvents = [];\n      var deferredTracks = [];\n      var percent = \"\";\n\n      _toConsumableArray(this._trackCacheMap.values()).forEach(function (track, index) {\n        var result = track.nextFrame(time, delta);\n\n        if (dataUtil.isString(result)) {\n          deferredEvents.push(result);\n          deferredTracks.push(track);\n        } else if (dataUtil.isNumeric(result)) {\n          percent = result;\n        }\n      });\n\n      var len = deferredEvents.length;\n\n      for (var i = 0; i < len; i++) {\n        deferredTracks[i].fire(deferredEvents[i]);\n      }\n\n      if (dataUtil.isNumeric(percent)) {\n        for (var _i = 0; _i < this._onframeList.length; _i++) {\n          this._onframeList[_i](this._target, percent);\n        }\n      }\n\n      if (this.isFinished()) {\n        this._doneCallback();\n      }\n    }\n    /**\r\n     * @method pause\r\n     * 暂停动画\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      _toConsumableArray(this._trackCacheMap.values()).forEach(function (track, index) {\n        track.pause();\n      });\n\n      this._paused = true;\n    }\n    /**\r\n     * @method resume\r\n     * 恢复动画\r\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      _toConsumableArray(this._trackCacheMap.values()).forEach(function (track, index) {\n        track.resume();\n      });\n\n      this._paused = false;\n    }\n    /**\r\n     * @method isPaused\r\n     * 是否暂停\r\n     */\n\n  }, {\n    key: \"isPaused\",\n    value: function isPaused() {\n      return !!this._paused;\n    }\n    /**\r\n     * @method delay\r\n     * 设置动画延迟开始的时间\r\n     * @param  {Number} time 单位ms\r\n     * @return {qrenderer.animation.AnimationProcess}\r\n     */\n\n  }, {\n    key: \"delay\",\n    value: function delay(time) {\n      this._delay = time;\n      return this;\n    }\n    /**\r\n     * @method done\r\n     * 添加动画结束的回调\r\n     * @param  {Function} cb\r\n     * @return {qrenderer.animation.AnimationProcess}\r\n     */\n\n  }, {\n    key: \"done\",\n    value: function done(cb) {\n      if (cb) {\n        this._doneList.push(cb);\n      }\n\n      return this;\n    }\n  }]);\n\n  return AnimationProcess;\n}();\n\nvar _default = AnimationProcess;\nmodule.exports = _default;","var Timeline = require(\"./Timeline\");\n\nvar colorUtil = require(\"../core/utils/color_util\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar _constants = require(\"../graphic/constants\");\n\nvar mathMin = _constants.mathMin;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.animation.Track\r\n * \r\n * Track, 轨道，与元素（Element）上可以用来进行动画的属性一一对应。\r\n * 元素上存在很多种属性，在动画过程中，可能会有多种属性同时发生变化，\r\n * 每一种属性天然成为一条动画轨道，把这些轨道上的变化过程封装在 Timeline 中。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Track =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor Track\r\n   * @param {Object} options \r\n   */\n  function Track(options) {\n    _classCallCheck(this, Track);\n\n    this._target = options._target;\n    this._getter = options._getter;\n    this._setter = options._setter;\n    this._loop = options._loop;\n    this._delay = options._delay;\n    this.isFinished = false;\n    this.keyframes = [];\n    this.timeline;\n  }\n  /**\r\n   * @method addKeyFrame\r\n   * 添加关键帧\r\n   * @param {Object} kf 数据结构为 {time:0,value:0}\r\n   */\n\n\n  _createClass(Track, [{\n    key: \"addKeyFrame\",\n    value: function addKeyFrame(kf) {\n      this.keyframes.push(kf);\n    }\n    /**\r\n     * @method nextFrame\r\n     * 进入下一帧\r\n     * @param {Number} time  当前时间\r\n     * @param {Number} delta 时间偏移量\r\n     */\n\n  }, {\n    key: \"nextFrame\",\n    value: function nextFrame(time, delta) {\n      if (!this.timeline) {\n        //TODO:fix this, there is something wrong here.\n        return;\n      }\n\n      var result = this.timeline.nextFrame(time, delta);\n\n      if (dataUtil.isNumeric(result) && result === 1) {\n        this.isFinished = true;\n      }\n\n      return result;\n    }\n    /**\r\n     * @method fire\r\n     * 触发事件\r\n     * @param {String} eventType \r\n     * @param {Object} arg \r\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(eventType, arg) {\n      this.timeline.fire(eventType, arg);\n    }\n    /**\r\n     * @method start\r\n     * 开始动画\r\n     * @param {String} easing 缓动函数名称\r\n     * @param {String} propName 属性名称\r\n     * @param {Boolean} forceAnimate 是否强制开启动画 \r\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(easing, propName, forceAnimate) {\n      var options = this._parseKeyFrames(easing, propName, forceAnimate); //如果传入的参数不正确，则无法构造实例\n\n\n      if (!options) {\n        return null;\n      }\n\n      var timeline = new Timeline(options);\n      this.timeline = timeline;\n    }\n    /**\r\n     * @method stop\r\n     * 停止动画\r\n     * @param {Boolean} forwardToLast 是否快进到最后一帧 \r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(forwardToLast) {\n      if (forwardToLast) {\n        // Move to last frame before stop\n        this.timeline.onframe(this._target, 1);\n      }\n    }\n    /**\r\n     * @method pause\r\n     * 暂停\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.timeline.pause();\n    }\n    /**\r\n     * @method resume\r\n     * 重启\r\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.timeline.resume();\n    }\n    /**\r\n     * @private\r\n     * @method _parseKeyFrames\r\n     * 解析关键帧，创建时间线\r\n     * @param {String} easing 缓动函数名称\r\n     * @param {String} propName 属性名称\r\n     * @param {Boolean} forceAnimate 是否强制开启动画 \r\n     * //TODO:try move this into webworker\r\n     */\n\n  }, {\n    key: \"_parseKeyFrames\",\n    value: function _parseKeyFrames(easing, propName, forceAnimate) {\n      var loop = this._loop;\n      var delay = this._delay;\n      var target = this._target;\n      var getter = this._getter;\n      var setter = this._setter;\n      var useSpline = easing === 'spline';\n      var kfLength = this.keyframes.length;\n\n      if (!kfLength) {\n        return;\n      } // Guess data type\n\n\n      var firstVal = this.keyframes[0].value;\n      var isValueArray = dataUtil.isArrayLike(firstVal);\n      var isValueColor = false;\n      var isValueString = false; // For vertices morphing\n\n      var arrDim = isValueArray ? dataUtil.getArrayDim(this.keyframes) : 0;\n      this.keyframes.sort(function (a, b) {\n        return a.time - b.time;\n      });\n      var trackMaxTime = this.keyframes[kfLength - 1].time;\n      var kfPercents = [];\n      var kfValues = [];\n      var prevValue = this.keyframes[0].value;\n      var isAllValueEqual = true;\n\n      for (var i = 0; i < kfLength; i++) {\n        kfPercents.push(this.keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n        var value = this.keyframes[i].value; // Check if value is equal, deep check if value is array\n\n        if (!(isValueArray && dataUtil.isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n          isAllValueEqual = false;\n        }\n\n        prevValue = value; // Try converting a string to a color array\n\n        if (typeof value === 'string') {\n          var colorArray = colorUtil.parse(value);\n\n          if (colorArray) {\n            value = colorArray;\n            isValueColor = true;\n          } else {\n            isValueString = true;\n          }\n        }\n\n        kfValues.push(value);\n      }\n\n      if (!forceAnimate && isAllValueEqual) {\n        return;\n      }\n\n      var lastValue = kfValues[kfLength - 1]; // Polyfill array and NaN value\n\n      for (var _i = 0; _i < kfLength - 1; _i++) {\n        if (isValueArray) {\n          dataUtil.fillArr(kfValues[_i], lastValue, arrDim);\n        } else {\n          if (isNaN(kfValues[_i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n            kfValues[_i] = lastValue;\n          }\n        }\n      }\n\n      isValueArray && dataUtil.fillArr(getter(target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n      // animation playback is sequency\n\n      var lastFrame = 0;\n      var lastFramePercent = 0;\n      var start;\n      var w;\n      var p0;\n      var p1;\n      var p2;\n      var p3;\n      var rgba = [0, 0, 0, 0]; //Timeline 每一帧都会回调此方法。\n\n      var onframe = function onframe(target, percent) {\n        // Find the range keyframes\n        // kf1-----kf2---------current--------kf3\n        // find kf2 and kf3 and do interpolation\n        var frame; // In the easing function like elasticOut, percent may less than 0\n\n        if (percent < 0) {\n          frame = 0;\n        } else if (percent < lastFramePercent) {\n          // Start from next key\n          // PENDING start from lastFrame ?\n          start = mathMin(lastFrame + 1, kfLength - 1);\n\n          for (frame = start; frame >= 0; frame--) {\n            if (kfPercents[frame] <= percent) {\n              break;\n            }\n          } // PENDING really need to do this ?\n\n\n          frame = mathMin(frame, kfLength - 2);\n        } else {\n          for (frame = lastFrame; frame < kfLength; frame++) {\n            if (kfPercents[frame] > percent) {\n              break;\n            }\n          }\n\n          frame = mathMin(frame - 1, kfLength - 2);\n        }\n\n        lastFrame = frame;\n        lastFramePercent = percent;\n        var range = kfPercents[frame + 1] - kfPercents[frame];\n\n        if (range === 0) {\n          return;\n        } else {\n          w = (percent - kfPercents[frame]) / range;\n        }\n\n        if (useSpline) {\n          p1 = kfValues[frame];\n          p0 = kfValues[frame === 0 ? frame : frame - 1];\n          p2 = kfValues[frame > kfLength - 2 ? kfLength - 1 : frame + 1];\n          p3 = kfValues[frame > kfLength - 3 ? kfLength - 1 : frame + 2];\n\n          if (isValueArray) {\n            dataUtil.catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n          } else {\n            var _value;\n\n            if (isValueColor) {\n              _value = dataUtil.catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n              _value = dataUtil.rgba2String(rgba);\n            } else if (isValueString) {\n              // String is step(0.5)\n              return dataUtil.interpolateString(p1, p2, w);\n            } else {\n              _value = dataUtil.catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n            }\n\n            setter(target, propName, _value);\n          }\n        } else {\n          if (isValueArray) {\n            dataUtil.interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n          } else {\n            var _value2;\n\n            if (isValueColor) {\n              dataUtil.interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n              _value2 = dataUtil.rgba2String(rgba);\n            } else if (isValueString) {\n              // String is step(0.5)\n              return dataUtil.interpolateString(kfValues[frame], kfValues[frame + 1], w);\n            } else {\n              _value2 = dataUtil.interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n            }\n\n            setter(target, propName, _value2);\n          }\n        }\n      };\n\n      var options = {\n        target: target,\n        lifeTime: trackMaxTime,\n        loop: loop,\n        delay: delay,\n        onframe: onframe,\n        easing: easing && easing !== 'spline' ? easing : 'Linear'\n      };\n      return options;\n    }\n  }]);\n\n  return Track;\n}();\n\nmodule.exports = Track;","var easingFuncs = require(\"./utils/easing\");\n\nvar _constants = require(\"../graphic/constants\");\n\nvar mathMin = _constants.mathMin;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.animation.Timeline\r\n * Timeline，时间线，用来计算元素上的某个属性在指定时间点的数值。\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Timeline =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor Timeline\r\n   * @param {Object} options \r\n   * @param {Element} options.target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\r\n   * @param {Number} options.life(1000) 动画时长\r\n   * @param {Number} options.delay(0) 动画延迟时间\r\n   * @param {Boolean} options.loop(true)\r\n   * @param {Number} options.gap(0) 循环的间隔时间\r\n   * @param {Function} options.onframe\r\n   * @param {String} options.easing(optional)\r\n   * @param {Function} options.ondestroy(optional)\r\n   * @param {Function} options.onrestart(optional)\r\n   */\n  function Timeline(options) {\n    _classCallCheck(this, Timeline);\n\n    this._target = options.target;\n    this._lifeTime = options.lifeTime || 1000;\n    this._delay = options.delay || 0;\n    this._initialized = false;\n    this.loop = options.loop == null ? false : options.loop;\n    this.gap = options.gap || 0;\n    this.easing = options.easing || 'Linear';\n    this.onframe = options.onframe;\n    this.ondestroy = options.ondestroy;\n    this.onrestart = options.onrestart;\n    this._pausedTime = 0;\n    this._paused = false;\n  }\n  /**\r\n   * @method nextFrame\r\n   * 进入下一帧\r\n   * @param {Number} globalTime 当前时间\r\n   * @param {Number} deltaTime  时间偏移量\r\n   * //TODO:try move this into webworker\r\n   */\n\n\n  _createClass(Timeline, [{\n    key: \"nextFrame\",\n    value: function nextFrame(globalTime, deltaTime) {\n      // Set startTime on first frame, or _startTime may has milleseconds different between clips\n      // PENDING\n      if (!this._initialized) {\n        this._startTime = globalTime + this._delay;\n        this._initialized = true;\n      }\n\n      if (this._paused) {\n        this._pausedTime += deltaTime;\n        return;\n      }\n\n      var percent = (globalTime - this._startTime - this._pausedTime) / this._lifeTime; // 还没开始\n\n      if (percent < 0) {\n        return;\n      }\n\n      percent = mathMin(percent, 1);\n      var easing = this.easing;\n      var easingFunc = typeof easing === 'string' ? easingFuncs[easing] : easing;\n      var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n      this.fire('frame', schedule); // 结束或者重新开始周期\n      // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\n      if (percent === 1) {\n        if (this.loop) {\n          this.restart(globalTime);\n          return 'restart';\n        }\n\n        return 'destroy';\n      }\n\n      return percent;\n    }\n    /**\r\n     * @method restart\r\n     * 重新开始\r\n     * @param {Number} globalTime \r\n     */\n\n  }, {\n    key: \"restart\",\n    value: function restart(globalTime) {\n      var remainder = (globalTime - this._startTime - this._pausedTime) % this._lifeTime;\n      this._startTime = globalTime - remainder + this.gap;\n      this._pausedTime = 0;\n    }\n    /**\r\n     * @method fire\r\n     * 触发事件\r\n     * @param {String} eventType \r\n     * @param {Object} arg \r\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(eventType, arg) {\n      eventType = 'on' + eventType;\n\n      if (this[eventType]) {\n        this[eventType](this._target, arg);\n      }\n    }\n    /**\r\n     * @method pause\r\n     * 暂停\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._paused = true;\n    }\n    /**\r\n     * @method resume\r\n     * 恢复运行\r\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this._paused = false;\n    }\n  }]);\n\n  return Timeline;\n}();\n\nmodule.exports = Timeline;","var _constants = require(\"../../graphic/constants\");\n\nvar mathAsin = _constants.mathAsin;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\nvar mathPow = _constants.mathPow;\nvar mathSqrt = _constants.mathSqrt;\nvar PI = _constants.PI;\nvar mathMin = _constants.mathMin;\n\n/**\r\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\r\n * 这里的缓动主要是一些数学计算公式，这些公式可以用来计算对象的坐标。\r\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\r\n * @exports qrenderer/animation/easing\r\n */\nvar easing = {\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  linear: function linear(k) {\n    return k;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quadraticIn: function quadraticIn(k) {\n    return k * k;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quadraticOut: function quadraticOut(k) {\n    return k * (2 - k);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quadraticInOut: function quadraticInOut(k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // 三次方的缓动（t^3）\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  cubicIn: function cubicIn(k) {\n    return k * k * k;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  cubicOut: function cubicOut(k) {\n    return --k * k * k + 1;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  cubicInOut: function cubicInOut(k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // 四次方的缓动（t^4）\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quarticIn: function quarticIn(k) {\n    return k * k * k * k;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quarticOut: function quarticOut(k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quarticInOut: function quarticInOut(k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // 五次方的缓动（t^5）\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quinticIn: function quinticIn(k) {\n    return k * k * k * k * k;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quinticOut: function quinticOut(k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  quinticInOut: function quinticInOut(k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // 正弦曲线的缓动（sin(t)）\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  sinusoidalIn: function sinusoidalIn(k) {\n    return 1 - mathCos(k * PI / 2);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  sinusoidalOut: function sinusoidalOut(k) {\n    return mathSin(k * PI / 2);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  sinusoidalInOut: function sinusoidalInOut(k) {\n    return 0.5 * (1 - mathCos(PI * k));\n  },\n  // 指数曲线的缓动（2^t）\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  exponentialIn: function exponentialIn(k) {\n    return k === 0 ? 0 : mathPow(1024, k - 1);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  exponentialOut: function exponentialOut(k) {\n    return k === 1 ? 1 : 1 - mathPow(2, -10 * k);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  exponentialInOut: function exponentialInOut(k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * mathPow(1024, k - 1);\n    }\n\n    return 0.5 * (-mathPow(2, -10 * (k - 1)) + 2);\n  },\n  // 圆形曲线的缓动（sqrt(1-t^2)）\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  circularIn: function circularIn(k) {\n    return 1 - mathSqrt(1 - k * k);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  circularOut: function circularOut(k) {\n    return mathSqrt(1 - --k * k);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  circularInOut: function circularInOut(k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (mathSqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (mathSqrt(1 - (k -= 2) * k) + 1);\n  },\n  // 创建类似于弹簧在停止前来回振荡的动画\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  elasticIn: function elasticIn(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * mathAsin(1 / a) / (2 * PI);\n    }\n\n    return -(a * mathPow(2, 10 * (k -= 1)) * mathSin((k - s) * (2 * PI) / p));\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  elasticOut: function elasticOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * mathAsin(1 / a) / (2 * PI);\n    }\n\n    return a * mathPow(2, -10 * k) * mathSin((k - s) * (2 * PI) / p) + 1;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  elasticInOut: function elasticInOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * mathAsin(1 / a) / (2 * PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * mathPow(2, 10 * (k -= 1)) * mathSin((k - s) * (2 * PI) / p));\n    }\n\n    return a * mathPow(2, -10 * (k -= 1)) * mathSin((k - s) * (2 * PI) / p) * 0.5 + 1;\n  },\n  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  backIn: function backIn(k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  backOut: function backOut(k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  backInOut: function backInOut(k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // 创建弹跳效果\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  bounceIn: function bounceIn(k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  bounceOut: function bounceOut(k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\r\n  * @param {Number} k\r\n  * @return {Number}\r\n  */\n  bounceInOut: function bounceInOut(k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;","var LRU = require(\"../LRU\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\nvar mathRound = _constants.mathRound;\nvar mathFloor = _constants.mathFloor;\nvar mathCeil = _constants.mathCeil;\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = mathRound(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = mathRound(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\r\n * @param {String} colorStr\r\n * @param {Array<Number>} out\r\n * @return {Array<Number>}\r\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('(');\n  var ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\r\n * @param {Array<Number>} hsla\r\n * @param {Array<Number>} rgba\r\n * @return {Array<Number>} rgba\r\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\r\n * @param {Array<Number>} rgba\r\n * @return {Array<Number>} hsla\r\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = mathMin(R, G, B); // Min. value of RGB\n\n  var vMax = mathMax(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\r\n * @param {String} color\r\n * @param {Number} level\r\n * @return {String}\r\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n\n      if (colorArr[i] > 255) {\n        colorArr[i] = 255;\n      } else if (color[i] < 0) {\n        colorArr[i] = 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\r\n * @param {String} color\r\n * @return {String}\r\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\r\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\r\n * @param {Number} normalizedValue A float between 0 and 1.\r\n * @param {Array<Array.<Number>>} colors List of rgba color array\r\n * @param {Array<Number>} [out] Mapped gba color array\r\n * @return {Array<Number>} will be null/undefined if input illegal.\r\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = mathFloor(value);\n  var rightIndex = mathCeil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\r\n * @deprecated\r\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\r\n * @param {Number} normalizedValue A float between 0 and 1.\r\n * @param {Array<String>} colors Color list.\r\n * @param {boolean=} fullOutput Default false.\r\n * @return {(string|Object)} Result color. If fullOutput,\r\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\r\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = mathFloor(value);\n  var rightIndex = mathCeil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\r\n * @deprecated\r\n */\n\n\nvar mapToColor = lerp;\n/**\r\n * @param {String} color\r\n * @param {number=} h 0 ~ 360, ignore when null.\r\n * @param {number=} s 0 ~ 1, ignore when null.\r\n * @param {number=} l 0 ~ 1, ignore when null.\r\n * @return {String} Color string in rgba format.\r\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\r\n * @param {String} color\r\n * @param {number=} alpha 0 ~ 1\r\n * @return {String} Color string in rgba format.\r\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\r\n * @param {Array<Number>} arrColor like [12,33,44,0.4]\r\n * @param {String} type 'rgba', 'hsva', ...\r\n * @return {String} Result color. (If input illegal, return undefined).\r\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;","// Simple LRU cache use doubly linked list\n\n/**\r\n * Simple double linked list. Compared with array, it has O(1) remove operation.\r\n * @constructor\r\n */\nvar LinkedList = function LinkedList() {\n  /**\r\n   * @property {LRU~Entry}\r\n   */\n  this.head = null;\n  /**\r\n   * @property {LRU~Entry}\r\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\r\n * Insert a new value at the tail\r\n * @param  {} val\r\n * @return {LRU~Entry}\r\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\r\n * Insert an entry at the tail\r\n * @param  {LRU~Entry} entry\r\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\r\n * Remove entry.\r\n * @param  {LRU~Entry} entry\r\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\r\n * @return {Number}\r\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\r\n * Clear list\r\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\r\n * @constructor\r\n * @param {} val\r\n */\n\n\nvar Entry = function Entry(val) {\n  /**\r\n   * @property {}\r\n   */\n  this.value = val;\n  /**\r\n   * @property {LRU~Entry}\r\n   */\n\n  this.next;\n  /**\r\n   * @property {LRU~Entry}\r\n   */\n\n  this.prev;\n};\n/**\r\n * LRU Cache\r\n * @constructor\r\n * @alias LRU\r\n */\n\n\nvar LRU = function LRU(maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\r\n * @param  {String} key\r\n * @param  {} value\r\n * @return {} Removed value\r\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\r\n * @param  {String} key\r\n * @return {}\r\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\r\n * Clear the cache\r\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;","var vec2 = require(\"../../core/utils/vector\");\n\nvar matrix = require(\"../../core/utils/matrix\");\n\nvar _constants = require(\"../constants\");\n\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.core.BoundingRect\r\n * \r\n * Bounding Rect.\r\n * \r\n * 边界矩形。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar lt = [];\nvar rb = [];\nvar lb = [];\nvar rt = [];\n\nvar BoundingRect =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor BoundingRect\r\n   */\n  function BoundingRect(x, y, width, height) {\n    _classCallCheck(this, BoundingRect);\n\n    if (width < 0) {\n      x = x + width;\n      width = -width;\n    }\n\n    if (height < 0) {\n      y = y + height;\n      height = -height;\n    }\n    /**\r\n     * @property {Number}\r\n     */\n\n\n    this.x = x;\n    /**\r\n     * @property {Number}\r\n     */\n\n    this.y = y;\n    /**\r\n     * @property {Number}\r\n     */\n\n    this.width = width;\n    /**\r\n     * @property {Number}\r\n     */\n\n    this.height = height;\n  }\n  /**\r\n   * @param {Object|BoundingRect} rect\r\n   * @param {Number} rect.x\r\n   * @param {Number} rect.y\r\n   * @param {Number} rect.width\r\n   * @param {Number} rect.height\r\n   * @return {BoundingRect}\r\n   */\n\n\n  _createClass(BoundingRect, [{\n    key: \"union\",\n\n    /**\r\n     * @method union\r\n     * @param {BoundingRect} other\r\n     */\n    value: function union(other) {\n      var x = mathMin(other.x, this.x);\n      var y = mathMin(other.y, this.y);\n      this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n      this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n      this.x = x;\n      this.y = y;\n    }\n    /**\r\n     * @method applyTransform\r\n     * @param {Array<Number>}\r\n     */\n\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    }\n    /**\r\n     * @method calculateTransform\r\n     * Calculate matrix of transforming from self to target rect\r\n     * @param  {BoundingRect} b\r\n     * @return {Array<Number>}\r\n     */\n\n  }, {\n    key: \"calculateTransform\",\n    value: function calculateTransform(b) {\n      var a = this;\n      var sx = b.width / a.width;\n      var sy = b.height / a.height;\n      var m = matrix.create(); // 矩阵右乘\n\n      matrix.translate(m, m, [-a.x, -a.y]);\n      matrix.scale(m, m, [sx, sy]);\n      matrix.translate(m, m, [b.x, b.y]);\n      return m;\n    }\n    /**\r\n     * @method intersect\r\n     * @param {(BoundingRect|Object)} b\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"intersect\",\n    value: function intersect(b) {\n      if (!b) {\n        return false;\n      }\n\n      if (!(b instanceof BoundingRect)) {\n        // Normalize negative width/height.\n        b = BoundingRect.create(b);\n      }\n\n      var a = this;\n      var ax0 = a.x;\n      var ax1 = a.x + a.width;\n      var ay0 = a.y;\n      var ay1 = a.y + a.height;\n      var bx0 = b.x;\n      var bx1 = b.x + b.width;\n      var by0 = b.y;\n      var by1 = b.y + b.height;\n      return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n    }\n    /**\r\n     * @method contain\r\n     * @param {*} x \r\n     * @param {*} y \r\n     */\n\n  }, {\n    key: \"contain\",\n    value: function contain(x, y) {\n      var rect = this;\n      return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n    }\n    /**\r\n     * @method clone\r\n     * @return {BoundingRect}\r\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new BoundingRect(this.x, this.y, this.width, this.height);\n    }\n    /**\r\n     * @method copy\r\n     * Copy from another rect\r\n     * @param other\r\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.width = other.width;\n      this.height = other.height;\n    }\n    /**\r\n     * @method plain\r\n     */\n\n  }, {\n    key: \"plain\",\n    value: function plain() {\n      return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(rect) {\n      return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    }\n  }]);\n\n  return BoundingRect;\n}();\n\nvar _default = BoundingRect;\nmodule.exports = _default;","// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1;\n    var count2;\n    var exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;","var requestAnimationFrame = require(\"./animation/utils/request_animation_frame\");\n\nvar _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar dataUtil = require(\"./core/utils/data_structure_util\");\n\nvar BoundingRect = require(\"./graphic/transform/BoundingRect\");\n\nvar timsort = require(\"./core/utils/timsort\");\n\nvar CanvasLayer = require(\"./CanvasLayer\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar _constants = require(\"./graphic/constants\");\n\nvar mathRandom = _constants.mathRandom;\nvar mathMax = _constants.mathMax;\n\nvar canvasUtil = require(\"./core/utils/canvas_util\");\n\nvar guid = require(\"./core/utils/guid\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.canvas.CanvasPainter\r\n * 这是基于 canvas 接口的 CanvasPainter 类\r\n * @see 基于 SVG 接口的 CanvasPainter 类在 svg 目录下\r\n * @see 基于 VML 接口的 CanvasPainter 类在 vml 目录下\r\n */\nvar HOVER_LAYER_QLEVEL = 1e5;\nvar CANVAS_QLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nvar CanvasPainter =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor\r\n   * @param {HTMLDomElement|Canvas|Context} host \r\n   * This can be a HTMLDomElement like a DIV, or a Canvas instance, \r\n   * or Context for Wechat mini-program.\r\n   * \r\n   * 此属性可以是 HTMLDomElement ，比如 DIV 标签；也可以是 Canvas 实例；或者是 Context 实例，因为在某些\r\n   * 运行环境中，不能获得 Canvas 实例的引用，只能获得 Context。\r\n   * @param {Storage} storage\r\n   * @param {Object} options\r\n   */\n  function CanvasPainter(host, storage) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, CanvasPainter);\n\n    this.options = dataUtil.extend({}, options);\n    /**\r\n     * @property {String} type\r\n     */\n\n    this.type = 'canvas';\n    /**\r\n     * @property {Number} dpr\r\n     */\n\n    this.dpr = this.options.devicePixelRatio || devicePixelRatio;\n    /**\r\n     * @property {HTMLDomElement|Canvas|Context} host \r\n     * This can be a HTMLDomElement like a DIV, or a Canvas instance, \r\n     * or Context for Wechat mini-program.\r\n     * \r\n     * 此属性可以是 HTMLDomElement ，比如 DIV 标签；也可以是 Canvas 实例；或者是 Context 实例，因为在某些\r\n     * 运行环境中，不能获得 Canvas 实例的引用，只能获得 Context。\r\n     */\n\n    this.host = host; // There is no style attribute on element in nodejs.\n\n    if (this.host.style) {\n      this.host.style['-webkit-tap-highlight-color'] = 'transparent';\n      this.host.style['-webkit-user-select'] = this.host.style['user-select'] = this.host.style['-webkit-touch-callout'] = 'none';\n      host.innerHTML = '';\n    }\n    /**\r\n     * @private\r\n     * @property {HTMLDomElement|Canvas|Context} _host \r\n     * This can be a HTMLDomElement like a DIV, or a Canvas instance, \r\n     * or Context for Wechat mini-program. In browser environment, this._host is \r\n     * a div which is created by QuarkRenderer automaticly, \r\n     * in other environments, this._host equals this.host.\r\n     * \r\n     * 此属性可以是 HTMLDomElement ，比如 DIV 标签；也可以是 Canvas 实例；或者是 Context 实例，因为在某些\r\n     * 运行环境中，不能获得 Canvas 实例的引用，只能获得 Context。在浏览器环境中，this._host 是 QuarkRenderer\r\n     * 自己自动创建的 div 层，在其它环境中，this._host 等于 this.root。\r\n     */\n\n\n    this._host = null;\n    /**\r\n     * @property {Storage} storage\r\n     */\n\n    this.storage = storage;\n    /**\r\n     * @property {Array<Number>}\r\n     * @private\r\n     */\n\n    var qlevelList = this._qlevelList = [];\n    /**\r\n     * @private\r\n     * @property {Object<String, CanvasLayer>} layers\r\n     */\n\n    var layers = this._layers = {};\n    /**\r\n     * @private\r\n     * @property {Object<String, Object>} _layerConfig\r\n     */\n\n    this._layerConfig = {};\n    /**\r\n     * @private\r\n     * @property _needsManuallyCompositing\r\n     * qrenderer will do compositing when host is a canvas and have multiple zlevels.\r\n     */\n\n    this._needsManuallyCompositing = false;\n    /**\r\n     * @private\r\n     * @property {CanvasLayer} _hoverlayer\r\n     */\n\n    this._hoverlayer = null;\n    /**\r\n     * @private\r\n     * @property {Array} _hoverElements\r\n     */\n\n    this._hoverElements = [];\n    this._tmpRect = new BoundingRect(0, 0, 0, 0);\n    this._viewRect = new BoundingRect(0, 0, 0, 0);\n    /**\r\n     * @property {Boolean} _singleCanvas\r\n     * In node environment using node-canvas\r\n     * @private\r\n     */\n\n    this._singleCanvas = !this.host.nodeName || this.host.nodeName.toUpperCase() === 'CANVAS'; //The code below is used to compatible with various runtime environments like browser, node-canvas, and Wechat mini-program.\n\n    if (this._singleCanvas) {\n      var width = this.host.width;\n      var height = this.host.height;\n\n      if (this.options.width != null) {\n        width = this.options.width;\n      }\n\n      if (this.options.height != null) {\n        height = this.options.height;\n      }\n\n      this.dpr = this.options.devicePixelRatio || 1; // Use canvas width and height directly\n\n      this.host.width = width * this.dpr;\n      this.host.height = height * this.dpr;\n      this._width = width;\n      this._height = height; // Create layer if only one given canvas\n      // Device can be specified to create a high dpi image.\n\n      var mainLayer = new CanvasLayer(this.host, this._width, this._height, this.dpr);\n      mainLayer.__builtin__ = true;\n      mainLayer.initContext(); // FIXME Use canvas width and height\n      // mainLayer.resize(width, height);\n\n      layers[CANVAS_QLEVEL] = mainLayer;\n      mainLayer.qlevel = CANVAS_QLEVEL; // Not use common qlevel.\n\n      qlevelList.push(CANVAS_QLEVEL);\n      this._host = this.host; // Here, this._host equals this.host.\n    } else {\n      this._width = this._getSize(0);\n      this._height = this._getSize(1);\n      var canvasContainer = this.createDomRoot( // Craete a new div inside the host element.\n      this._width, this._height);\n      this._host = canvasContainer; // In this case, this._host is different from this.host.\n\n      this.host.appendChild(canvasContainer);\n    }\n  }\n  /**\r\n   * @method getHost\r\n   * Do NOT use this method in Wechat mini-program, because we can not get HTMLElement \r\n   * nor canvas instance.\r\n   * @return {HTMLDivElement}\r\n   */\n\n\n  _createClass(CanvasPainter, [{\n    key: \"getHost\",\n    value: function getHost() {\n      return this._host;\n    }\n    /**\r\n     * @method getViewportRootOffset\r\n     * Do NOT use this method in Wechat mini-program, because we can not get HTMLElement \r\n     * nor canvas instance.\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"getViewportRootOffset\",\n    value: function getViewportRootOffset() {\n      var host = this.getHost();\n\n      if (host) {\n        return {\n          offsetLeft: host.offsetLeft || 0,\n          offsetTop: host.offsetTop || 0\n        };\n      }\n    }\n    /**\r\n     * @method\r\n     * 刷新\r\n     * @param {Boolean} [paintAll=false] 是否强制绘制所有displayable\r\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh(paintAll) {\n      var list = this.storage.getDisplayList(true);\n      var qlevelList = this._qlevelList;\n      this._redrawId = mathRandom();\n\n      this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n      for (var i = 0; i < qlevelList.length; i++) {\n        var z = qlevelList[i];\n        var layer = this._layers[z];\n\n        if (!layer.__builtin__ && layer.refresh) {\n          var clearColor = i === 0 ? this._backgroundColor : null;\n          layer.refresh(clearColor);\n        }\n      }\n\n      this.refreshHover();\n      return this;\n    }\n    /**\r\n     * @method addHover\r\n     * \r\n     * @param {*} el \r\n     * @param {*} hoverStyle \r\n     */\n\n  }, {\n    key: \"addHover\",\n    value: function addHover(el, hoverStyle) {\n      if (el.__hoverMir) {\n        return;\n      }\n\n      var elMirror = new el.constructor({\n        style: el.style,\n        shape: el.shape,\n        z: el.z,\n        z2: el.z2,\n        silent: el.silent\n      });\n      elMirror.__from = el;\n      el.__hoverMir = elMirror;\n      hoverStyle && elMirror.setStyle(hoverStyle);\n\n      this._hoverElements.push(elMirror);\n\n      return elMirror;\n    }\n    /**\r\n     * @method removeHover\r\n     * @param {*} el \r\n     */\n\n  }, {\n    key: \"removeHover\",\n    value: function removeHover(el) {\n      var elMirror = el.__hoverMir;\n      var hoverElements = this._hoverElements;\n      var idx = dataUtil.indexOf(hoverElements, elMirror);\n\n      if (idx >= 0) {\n        hoverElements.splice(idx, 1);\n      }\n\n      el.__hoverMir = null;\n    }\n    /**\r\n     * @method clearHover\r\n     * @param {*} el \r\n     */\n\n  }, {\n    key: \"clearHover\",\n    value: function clearHover(el) {\n      var hoverElements = this._hoverElements;\n\n      for (var i = 0; i < hoverElements.length; i++) {\n        var from = hoverElements[i].__from;\n\n        if (from) {\n          from.__hoverMir = null;\n        }\n      }\n\n      hoverElements.length = 0;\n    }\n    /**\r\n     * @method refreshHover\r\n     */\n\n  }, {\n    key: \"refreshHover\",\n    value: function refreshHover() {\n      var hoverElements = this._hoverElements;\n      var len = hoverElements.length;\n      var hoverLayer = this._hoverlayer;\n      hoverLayer && hoverLayer.clear();\n\n      if (!len) {\n        return;\n      }\n\n      timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large qlevel\n      // FIXME?\n\n      if (!hoverLayer) {\n        hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_QLEVEL);\n      }\n\n      var scope = {};\n      hoverLayer.ctx.save();\n\n      for (var i = 0; i < len;) {\n        var el = hoverElements[i];\n        var originalEl = el.__from; // Original el is removed\n        // PENDING\n\n        if (!(originalEl && originalEl.__qr)) {\n          hoverElements.splice(i, 1);\n          originalEl.__hoverMir = null;\n          len--;\n          continue;\n        }\n\n        i++; // Use transform\n        // FIXME style and shape ?\n\n        if (!originalEl.invisible) {\n          el.transform = originalEl.transform;\n          el.invTransform = originalEl.invTransform;\n          el.__clipPaths = originalEl.__clipPaths; // el.\n\n          this._doPaintEl(el, hoverLayer, true, scope);\n        }\n      }\n\n      hoverLayer.ctx.restore();\n    }\n    /**\r\n     * @method getHoverLayer\r\n     */\n\n  }, {\n    key: \"getHoverLayer\",\n    value: function getHoverLayer() {\n      return this.getLayer(HOVER_LAYER_QLEVEL);\n    }\n    /**\r\n     * @method _paintList\r\n     * @param {*} list \r\n     * @param {*} paintAll \r\n     * @param {*} redrawId \r\n     */\n\n  }, {\n    key: \"_paintList\",\n    value: function _paintList(list, paintAll, redrawId) {\n      //如果 redrawId 不一致，说明下一个动画帧已经到来，这里就会直接跳过去，相当于跳过了一帧\n      if (this._redrawId !== redrawId) {\n        return;\n      }\n\n      paintAll = paintAll || false;\n\n      this._updateLayerStatus(list);\n\n      var finished = this._doPaintList(list, paintAll);\n\n      if (this._needsManuallyCompositing) {\n        this._compositeManually();\n      } //如果在一帧的时间内没有绘制完，在下一帧继续绘制。\n      //当前本机的测试值，1000 个元素同时进行动画，可以在 16ms 的时间中绘制完成。\n\n\n      if (!finished) {\n        var self = this;\n        requestAnimationFrame(function () {\n          self._paintList(list, paintAll, redrawId);\n        });\n      }\n    }\n    /**\r\n     * @method _compositeManually\r\n     */\n\n  }, {\n    key: \"_compositeManually\",\n    value: function _compositeManually() {\n      var ctx = this.getLayer(CANVAS_QLEVEL).ctx;\n      var width = this._host.width;\n      var height = this._host.height;\n      ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n      this.eachBuiltinLayer(function (layer) {\n        if (layer.virtual) {\n          ctx.drawImage(layer.canvasInstance, 0, 0, width, height);\n        }\n      });\n    }\n    /**\r\n     * @method _doPaintList\r\n     */\n\n  }, {\n    key: \"_doPaintList\",\n    value: function _doPaintList(list, paintAll) {\n      var layerList = [];\n\n      for (var zi = 0; zi < this._qlevelList.length; zi++) {\n        var qlevel = this._qlevelList[zi];\n        var layer = this._layers[qlevel];\n\n        if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n          layerList.push(layer);\n        }\n      }\n\n      var finished = true;\n\n      for (var k = 0; k < layerList.length; k++) {\n        var _layer = layerList[k];\n        var ctx = _layer.ctx;\n        var scope = {};\n        ctx.save();\n        var start = paintAll ? _layer.__startIndex : _layer.__drawIndex;\n        var useTimer = !paintAll && _layer.incremental && Date.now;\n        var startTime = useTimer && Date.now();\n        var clearColor = _layer.qlevel === this._qlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n        if (_layer.__startIndex === _layer.__endIndex) {\n          _layer.clear(false, clearColor);\n        } else if (start === _layer.__startIndex) {\n          var firstEl = list[start];\n\n          if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n            _layer.clear(false, clearColor);\n          }\n        }\n\n        if (start === -1) {\n          console.error('For some unknown reason. drawIndex is -1');\n          start = _layer.__startIndex;\n        }\n\n        var i = start;\n\n        for (; i < _layer.__endIndex; i++) {\n          var el = list[i];\n\n          this._doPaintEl(el, _layer, paintAll, scope);\n\n          el.__dirty = el.__dirtyText = false;\n\n          if (useTimer) {\n            // Date.now can be executed in 13,025,305 ops/second.\n            var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n            // The rest elements will be drawn in the next frame.\n            // 这里的时间计算非常重要，如果 15ms 的时间内没有能绘制完所有元素，则跳出，等待下一帧继续绘制\n            // 但是 15ms 的时间依然是有限的，如果元素的数量非常巨大，例如有 1000 万个，还是会卡顿。\n\n            if (dTime > 15) {\n              break;\n            }\n          }\n        }\n\n        _layer.__drawIndex = i;\n\n        if (_layer.__drawIndex < _layer.__endIndex) {\n          finished = false;\n        }\n\n        if (scope.prevElClipPaths) {\n          // Needs restore the state. If last drawn element is in the clipping area.\n          ctx.restore();\n        }\n\n        ctx.restore();\n      }\n\n      if (env.wxa) {\n        // Flush for weixin application\n        dataUtil.each(this._layers, function (layer) {\n          if (layer && layer.ctx && layer.ctx.draw) {\n            layer.ctx.draw();\n          }\n        });\n      }\n\n      return finished;\n    }\n    /**\r\n     * @method _doPaintEl\r\n     * 绘制一个元素\r\n     * @param {*} el \r\n     * @param {*} currentLayer \r\n     * @param {*} forcePaint \r\n     * @param {*} scope \r\n     */\n\n  }, {\n    key: \"_doPaintEl\",\n    value: function _doPaintEl(el, currentLayer, forcePaint, scope) {\n      var ctx = currentLayer.ctx;\n      var m = el.transform;\n\n      if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n      !el.invisible // Ignore transparent element\n      && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n      // Draw a scale 0 element can cause all following draw wrong\n      // And setTransform with scale 0 will cause set back transform failed.\n      && !(m && !m[0] && !m[3]) // Ignore culled element\n      && !(el.culling && this.isDisplayableCulled(el, this._width, this._height))) {\n        var clipPaths = el.__clipPaths;\n        var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n        if (!prevElClipPaths || this.isClipPathChanged(clipPaths, prevElClipPaths)) {\n          // If has previous clipping state, restore from it\n          if (prevElClipPaths) {\n            ctx.restore();\n            scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n            scope.prevEl = null;\n          } // New clipping state\n\n\n          if (clipPaths) {\n            ctx.save();\n            this.doClip(clipPaths, ctx);\n            scope.prevElClipPaths = clipPaths;\n          }\n        }\n\n        el.beforeBrush && el.beforeBrush(ctx);\n        el.brush(ctx, scope.prevEl || null);\n        scope.prevEl = el;\n        el.afterBrush && el.afterBrush(ctx);\n      }\n    }\n    /**\r\n     * @method getLayer\r\n     * 获取 qlevel 所在层，如果不存在则会创建一个新的层\r\n     * @param {Number} qlevel\r\n     * @param {Boolean} virtual Virtual layer will not be inserted into dom.\r\n     * @return {CanvasLayer}\r\n     */\n\n  }, {\n    key: \"getLayer\",\n    value: function getLayer(qlevel, virtual) {\n      if (this._singleCanvas && !this._needsManuallyCompositing) {\n        qlevel = CANVAS_QLEVEL;\n      }\n\n      var layer = this._layers[qlevel];\n\n      if (!layer) {\n        // Create a new layer\n        layer = new CanvasLayer('qr_' + qlevel, this._width, this._height, this.dpr);\n        layer.qlevel = qlevel;\n        layer.__builtin__ = true;\n\n        if (this._layerConfig[qlevel]) {\n          dataUtil.merge(layer, this._layerConfig[qlevel], true);\n        }\n\n        if (virtual) {\n          layer.virtual = virtual;\n        }\n\n        this.insertLayer(qlevel, layer); // Context is created after dom inserted to document\n        // Or excanvas will get 0px clientWidth and clientHeight\n\n        layer.initContext();\n      }\n\n      return layer;\n    }\n    /**\r\n     * @method insertLayer\r\n     * Insert layer dynamicly during runtime.\r\n     * Do NOT use this method in Wechat mini-program, because we can neither get HTMLElement \r\n     * nor canvas instance.\r\n     * @param {*} qlevel \r\n     * @param {*} layer \r\n     */\n\n  }, {\n    key: \"insertLayer\",\n    value: function insertLayer(qlevel, layer) {\n      var layersMap = this._layers;\n      var qlevelList = this._qlevelList;\n      var len = qlevelList.length;\n      var prevLayer = null;\n      var i = -1;\n\n      if (layersMap[qlevel]) {\n        console.log('ZLevel ' + qlevel + ' has been used already');\n        return;\n      } // Check if is a valid layer\n\n\n      if (!this.isLayerValid(layer)) {\n        console.log('CanvasLayer of qlevel ' + qlevel + ' is not valid');\n        return;\n      }\n\n      if (len > 0 && qlevel > qlevelList[0]) {\n        for (i = 0; i < len - 1; i++) {\n          if (qlevelList[i] < qlevel && qlevelList[i + 1] > qlevel) {\n            break;\n          }\n        }\n\n        prevLayer = layersMap[qlevelList[i]];\n      }\n\n      qlevelList.splice(i + 1, 0, qlevel);\n      layersMap[qlevel] = layer; // Vitual layer will not directly show on the screen.\n      // (It can be a WebGL layer and assigned to a ZImage element)\n      // But it still under management of qrenderer.\n\n      if (!layer.virtual) {\n        if (prevLayer) {\n          var prevDom = prevLayer.canvasInstance;\n\n          if (prevDom.nextSibling) {\n            this.host.insertBefore(layer.canvasInstance, prevDom.nextSibling);\n          } else {\n            this.host.appendChild(layer.canvasInstance);\n          }\n        } else {\n          if (this.host.firstChild) {\n            this.host.insertBefore(layer.canvasInstance, this.host.firstChild);\n          } else {\n            this.host.appendChild(layer.canvasInstance);\n          }\n        }\n      }\n    }\n    /**\r\n     * @method delLayer\r\n     * 删除指定层\r\n     * @param {Number} qlevel 层所在的zlevel\r\n     */\n\n  }, {\n    key: \"delLayer\",\n    value: function delLayer(qlevel) {\n      var layers = this._layers;\n      var qlevelList = this._qlevelList;\n      var layer = layers[qlevel];\n\n      if (!layer) {\n        return;\n      }\n\n      if (layer.canvasInstance) {\n        layer.canvasInstance.parentNode.removeChild(layer.canvasInstance);\n      }\n\n      delete layers[qlevel];\n      qlevelList.splice(dataUtil.indexOf(qlevelList, qlevel), 1);\n    }\n    /**\r\n     * @private\r\n     * @method eachLayer\r\n     * Iterate each layer\r\n     * @param {Function} cb \r\n     * @param {Object} context \r\n     */\n\n  }, {\n    key: \"eachLayer\",\n    value: function eachLayer(cb, context) {\n      var qlevelList = this._qlevelList;\n      var z;\n      var i;\n\n      for (i = 0; i < qlevelList.length; i++) {\n        z = qlevelList[i];\n        cb.call(context, this._layers[z], z);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method eachBuiltinLayer\r\n     * Iterate each buildin layer\r\n     * @param {Function} cb \r\n     * @param {Object} context \r\n     */\n\n  }, {\n    key: \"eachBuiltinLayer\",\n    value: function eachBuiltinLayer(cb, context) {\n      var qlevelList = this._qlevelList;\n      var layer;\n      var z;\n      var i;\n\n      for (i = 0; i < qlevelList.length; i++) {\n        z = qlevelList[i];\n        layer = this._layers[z];\n\n        if (layer.__builtin__) {\n          cb.call(context, layer, z);\n        }\n      }\n    }\n    /**\r\n     * @private\r\n     * @method eachOtherLayer\r\n     * Iterate each other layer except buildin layer\r\n     * @param {Function} cb \r\n     * @param {Object} context \r\n     */\n\n  }, {\n    key: \"eachOtherLayer\",\n    value: function eachOtherLayer(cb, context) {\n      var qlevelList = this._qlevelList;\n      var layer;\n      var z;\n      var i;\n\n      for (i = 0; i < qlevelList.length; i++) {\n        z = qlevelList[i];\n        layer = this._layers[z];\n\n        if (!layer.__builtin__) {\n          cb.call(context, layer, z);\n        }\n      }\n    }\n    /**\r\n     * @method getLayers\r\n     * 获取所有已创建的层\r\n     * @param {Array<CanvasLayer>} [prevLayer]\r\n     */\n\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      return this._layers;\n    }\n    /**\r\n     * @private\r\n     * @method _updateLayerStatus\r\n     * @param {*} list \r\n     */\n\n  }, {\n    key: \"_updateLayerStatus\",\n    value: function _updateLayerStatus(list) {\n      this.eachBuiltinLayer(function (layer, z) {\n        layer.__dirty = layer.__used = false;\n      });\n\n      function updatePrevLayer(idx) {\n        if (prevLayer) {\n          if (prevLayer.__endIndex !== idx) {\n            prevLayer.__dirty = true;\n          }\n\n          prevLayer.__endIndex = idx;\n        }\n      }\n\n      if (this._singleCanvas) {\n        for (var _i = 1; _i < list.length; _i++) {\n          var el = list[_i];\n\n          if (el.qlevel !== list[_i - 1].qlevel || el.incremental) {\n            this._needsManuallyCompositing = true;\n            break;\n          }\n        }\n      }\n\n      var prevLayer = null;\n      var incrementalLayerCount = 0;\n      var i = 0;\n\n      for (; i < list.length; i++) {\n        var _el = list[i];\n        var qlevel = _el.qlevel;\n        var layer = void 0; // PENDING If change one incremental element style ?\n        // TODO Where there are non-incremental elements between incremental elements.\n\n        if (_el.incremental) {\n          layer = this.getLayer(qlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n          layer.incremental = true;\n          incrementalLayerCount = 1;\n        } else {\n          layer = this.getLayer(qlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n        }\n\n        if (!layer.__builtin__) {\n          console.log('ZLevel ' + qlevel + ' has been used by unkown layer ' + layer.id);\n        }\n\n        if (layer !== prevLayer) {\n          layer.__used = true;\n\n          if (layer.__startIndex !== i) {\n            layer.__dirty = true;\n          }\n\n          layer.__startIndex = i;\n\n          if (!layer.incremental) {\n            layer.__drawIndex = i;\n          } else {\n            // Mark layer draw index needs to update.\n            layer.__drawIndex = -1;\n          }\n\n          updatePrevLayer(i);\n          prevLayer = layer;\n        }\n\n        if (_el.__dirty) {\n          layer.__dirty = true;\n\n          if (layer.incremental && layer.__drawIndex < 0) {\n            // Start draw from the first dirty element.\n            layer.__drawIndex = i;\n          }\n        }\n      }\n\n      updatePrevLayer(i);\n      this.eachBuiltinLayer(function (layer, z) {\n        // Used in last frame but not in this frame. Needs clear\n        if (!layer.__used && layer.getElementCount() > 0) {\n          layer.__dirty = true;\n          layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n        } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n        if (layer.__dirty && layer.__drawIndex < 0) {\n          layer.__drawIndex = layer.__startIndex;\n        }\n      });\n    }\n    /**\r\n     * @method clear\r\n     * 清除hover层外所有内容\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.eachBuiltinLayer(this._clearLayer);\n      return this;\n    }\n    /**\r\n     * @private\r\n     * @method _clearLayer\r\n     */\n\n  }, {\n    key: \"_clearLayer\",\n    value: function _clearLayer(layer) {\n      layer.clear();\n    }\n    /**\r\n     * @method setBackgroundColor\r\n     */\n\n  }, {\n    key: \"setBackgroundColor\",\n    value: function setBackgroundColor(backgroundColor) {\n      this._backgroundColor = backgroundColor;\n    }\n    /**\r\n     * @method configLayer\r\n     * 修改指定zlevel的绘制参数\r\n     *\r\n     * @param {String} qlevel\r\n     * @param {Object} [config] 配置对象\r\n     * @param {String} [config.clearColor=0] 每次清空画布的颜色\r\n     * @param {String} [config.motionBlur=false] 是否开启动态模糊\r\n     * @param {Number} [config.lastFrameAlpha=0.7] 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\r\n     */\n\n  }, {\n    key: \"configLayer\",\n    value: function configLayer(qlevel, config) {\n      if (config) {\n        var layerConfig = this._layerConfig;\n\n        if (!layerConfig[qlevel]) {\n          layerConfig[qlevel] = config;\n        } else {\n          dataUtil.merge(layerConfig[qlevel], config, true);\n        }\n\n        for (var i = 0; i < this._qlevelList.length; i++) {\n          var _zlevel = this._qlevelList[i];\n\n          if (_zlevel === qlevel || _zlevel === qlevel + EL_AFTER_INCREMENTAL_INC) {\n            var layer = this._layers[_zlevel];\n            dataUtil.merge(layer, layerConfig[qlevel], true);\n          }\n        }\n      }\n    }\n    /**\r\n     * @method resize\r\n     * 区域大小变化后重绘\r\n     * @param {Number} width\r\n     * @param {Number} height\r\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      if (!this._host.style) {\n        // Maybe in node or worker or Wechat\n        if (width == null || height == null) {\n          return;\n        }\n\n        this._width = width;\n        this._height = height;\n        this.getLayer(CANVAS_QLEVEL).resize(width, height);\n      } else {\n        var domRoot = this._host;\n        domRoot.style.display = 'none'; // Save input w/h\n\n        var options = this.options;\n        width != null && (options.width = width);\n        height != null && (options.height = height);\n        width = this._getSize(0);\n        height = this._getSize(1);\n        domRoot.style.display = ''; // 优化没有实际改变的resize\n\n        if (this._width !== width || height !== this._height) {\n          domRoot.style.width = width + 'px';\n          domRoot.style.height = height + 'px';\n\n          for (var id in this._layers) {\n            if (this._layers.hasOwnProperty(id)) {\n              this._layers[id].resize(width, height);\n            }\n          }\n\n          dataUtil.each(this._progressiveLayers, function (layer) {\n            layer.resize(width, height);\n          });\n          this.refresh(true);\n        }\n\n        this._width = width;\n        this._height = height;\n      }\n\n      return this;\n    }\n    /**\r\n     * @method clearLayer\r\n     * 清除单独的一个层\r\n     * @param {Number} qlevel\r\n     */\n\n  }, {\n    key: \"clearLayer\",\n    value: function clearLayer(qlevel) {\n      var layer = this._layers[qlevel];\n\n      if (layer) {\n        layer.clear();\n      }\n    }\n    /**\r\n     * @method dispose\r\n     * 释放\r\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.host.innerHTML = '';\n      this.host = null;\n      this.storage = null;\n      this._host = null;\n      this._layers = null;\n    }\n    /**\r\n     * @method getRenderedCanvas\r\n     * Get canvas which has all thing rendered.\r\n     * Do NOT use this method in Wechat mini-program, because we can not get HTMLElement \r\n     * nor canvas instance.\r\n     * @param {Object} [options]\r\n     * @param {String} [options.backgroundColor]\r\n     * @param {Number} [options.pixelRatio]\r\n     */\n\n  }, {\n    key: \"getRenderedCanvas\",\n    value: function getRenderedCanvas() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._singleCanvas && !this._compositeManually) {\n        return this._layers[CANVAS_QLEVEL].canvasInstance;\n      }\n\n      var imageLayer = new CanvasLayer('image', this._width, this._height, options.pixelRatio || this.dpr);\n      imageLayer.initContext();\n      imageLayer.clear(false, options.backgroundColor || this._backgroundColor);\n\n      if (options.pixelRatio <= this.dpr) {\n        this.refresh();\n        var width = imageLayer.canvasInstance.width;\n        var height = imageLayer.canvasInstance.height;\n        var ctx = imageLayer.ctx;\n        this.eachLayer(function (layer) {\n          if (layer.__builtin__) {\n            ctx.drawImage(layer.canvasInstance, 0, 0, width, height);\n          } else if (layer.renderToCanvas) {\n            imageLayer.ctx.save();\n            layer.renderToCanvas(imageLayer.ctx);\n            imageLayer.ctx.restore();\n          }\n        });\n      } else {\n        // PENDING, echarts-gl and incremental rendering.\n        var scope = {};\n        var displayList = this.storage.getDisplayList(true);\n\n        for (var i = 0; i < displayList.length; i++) {\n          var el = displayList[i];\n\n          this._doPaintEl(el, imageLayer, true, scope);\n        }\n      }\n\n      return imageLayer.canvasInstance;\n    }\n    /**\r\n     * @method getWidth\r\n     * 获取绘图区域宽度\r\n     * @return {Number}\r\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this._width;\n    }\n    /**\r\n     * @method getHeight\r\n     * 获取绘图区域高度\r\n     * @return {Number}\r\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this._height;\n    }\n    /**\r\n     * @method _getSize\r\n     * Do NOT use this method in Wechat mini-program, because we can not get HTMLElement \r\n     * nor canvas instance.\r\n     * @param {*} whIdx \r\n     */\n\n  }, {\n    key: \"_getSize\",\n    value: function _getSize(whIdx) {\n      var options = this.options;\n      var wh = ['width', 'height'][whIdx];\n      var cwh = ['clientWidth', 'clientHeight'][whIdx];\n      var plt = ['paddingLeft', 'paddingTop'][whIdx];\n      var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n      if (options[wh] != null && options[wh] !== 'auto') {\n        return parseFloat(options[wh]);\n      } // IE8 does not support getComputedStyle, but it use VML.\n\n\n      var stl = document.defaultView.getComputedStyle(this.host);\n      return (this.host[cwh] || dataUtil.parseInt10(stl[wh]) || dataUtil.parseInt10(this.host.style[wh])) - (dataUtil.parseInt10(stl[plt]) || 0) - (dataUtil.parseInt10(stl[prb]) || 0) | 0;\n    }\n    /**\r\n     * @method pathToImage\r\n     * @param {*} path \r\n     * @param {*} dpr \r\n     */\n\n  }, {\n    key: \"pathToImage\",\n    value: function pathToImage(path, dpr) {\n      dpr = dpr || this.dpr;\n      var canvas = canvasUtil.createCanvas(); //创建隐藏的 canvas，在内存中。\n\n      var ctx = canvasUtil.getContext(canvas);\n      var rect = path.getBoundingRect();\n      var style = path.style;\n      var shadowBlurSize = style.shadowBlur * dpr;\n      var shadowOffsetX = style.shadowOffsetX * dpr;\n      var shadowOffsetY = style.shadowOffsetY * dpr;\n      var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n      var leftMargin = mathMax(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n      var rightMargin = mathMax(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n      var topMargin = mathMax(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n      var bottomMargin = mathMax(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n      var width = rect.width + leftMargin + rightMargin;\n      var height = rect.height + topMargin + bottomMargin;\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      ctx.scale(dpr, dpr);\n      ctx.clearRect(0, 0, width, height);\n      ctx.dpr = dpr;\n      var pathTransform = {\n        position: path.position,\n        rotation: path.rotation,\n        scale: path.scale\n      };\n      path.position = [leftMargin - rect.x, topMargin - rect.y];\n      path.rotation = 0;\n      path.scale = [1, 1];\n      path.updateTransform();\n\n      if (path) {\n        path.brush(ctx);\n      }\n\n      var ImageShape = Image;\n      var imgShape = new ImageShape({\n        style: {\n          x: 0,\n          y: 0,\n          image: canvas\n        }\n      });\n\n      if (pathTransform.position != null) {\n        imgShape.position = path.position = pathTransform.position;\n      }\n\n      if (pathTransform.rotation != null) {\n        imgShape.rotation = path.rotation = pathTransform.rotation;\n      }\n\n      if (pathTransform.scale != null) {\n        imgShape.scale = path.scale = pathTransform.scale;\n      }\n\n      return imgShape;\n    }\n    /**\r\n     * @private\r\n     * @method isLayerValid\r\n     * @param {*} layer \r\n     */\n\n  }, {\n    key: \"isLayerValid\",\n    value: function isLayerValid(layer) {\n      if (!layer) {\n        return false;\n      }\n\n      if (layer.__builtin__) {\n        return true;\n      }\n\n      if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * @private\r\n     * @method isDisplayableCulled\r\n     * @param {*} el \r\n     * @param {*} width \r\n     * @param {*} height \r\n     */\n\n  }, {\n    key: \"isDisplayableCulled\",\n    value: function isDisplayableCulled(el, width, height) {\n      this._tmpRect.copy(el.getBoundingRect());\n\n      if (el.transform) {\n        this._tmpRect.applyTransform(el.transform);\n      }\n\n      this._viewRect.width = width;\n      this._viewRect.height = height;\n      return !this._tmpRect.intersect(this._viewRect);\n    }\n    /**\r\n     * @private\r\n     * @method isClipPathChanged\r\n     * @param {*} clipPaths \r\n     * @param {*} prevClipPaths \r\n     */\n\n  }, {\n    key: \"isClipPathChanged\",\n    value: function isClipPathChanged(clipPaths, prevClipPaths) {\n      // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n      if (clipPaths === prevClipPaths) {\n        return false;\n      }\n\n      if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n        return true;\n      }\n\n      for (var i = 0; i < clipPaths.length; i++) {\n        if (clipPaths[i] !== prevClipPaths[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * @private\r\n     * @method doClip\r\n     * @param {*} clipPaths \r\n     * @param {*} ctx \r\n     */\n\n  }, {\n    key: \"doClip\",\n    value: function doClip(clipPaths, ctx) {\n      clipPaths.forEach(function (clipPath, index) {\n        clipPath.setTransform(ctx);\n        ctx.beginPath();\n        clipPath.buildPath(ctx, clipPath.shape);\n        ctx.clip();\n        clipPath.restoreTransform(ctx);\n      });\n    }\n    /**\r\n     * @private\r\n     * @method createDomRoot\r\n     * 在浏览器环境中，不会直接在传入的 dom 节点内部创建 canvas 标签，而是再内嵌一层div。\r\n     * 目的是加上一些必须的 CSS 样式，方便实现特定的功能。\r\n     * @param {Number} width \r\n     * @param {Number} height \r\n     */\n\n  }, {\n    key: \"createDomRoot\",\n    value: function createDomRoot(width, height) {\n      var domRoot = document.createElement('div'); // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n      // dom does not act as expected) when some of the parent dom has\n      // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n      // the canvas is not at the top part of the page.\n      // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n      // this `overflow:hidden` to avoid the bug.\n      // 'overflow:hidden',\n\n      domRoot.style.cssText = ['position:relative', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n      return domRoot;\n    }\n  }]);\n\n  return CanvasPainter;\n}();\n\nmodule.exports = CanvasPainter;","/**\r\n * 兼容多种运行环境的 requestAnimationFrame 方法。\r\n * 有两个重要的地方会依赖此方法：\r\n * - 元素的渲染机制，在 Painter 类中会调用\r\n * - 元素的动画效果，在 Animation 类中会调用\r\n * \r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\r\n */\nvar _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16); // 1000ms/60，每秒60帧，每帧约16ms\n};\n\nmodule.exports = _default;","var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\r\n * config默认配置项\r\n * @exports qrenderer/config\r\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n */\n\n/**\r\n * Debug log mode:\r\n * 0: Do nothing, for release.\r\n * 1: console.error, for debug.\r\n */\n\n\nvar debugMode = 0; // retina 屏幕优化\n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;","var dataUtil = require(\"./core/utils/data_structure_util\");\n\nvar canvasUtil = require(\"./core/utils/canvas_util\");\n\nvar Style = require(\"./graphic/Style\");\n\nvar Pattern = require(\"./graphic/Pattern\");\n\nvar guid = require(\"./core/utils/guid\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.canvas.CanvasLayer\r\n * \r\n * CanvasLayer is designed to create canvas layers, it will be used in CanvasPainter.\r\n * CanvasPainter will create several canvas instances during the paint process, some \r\n * of them are invisiable, such as the one used for export a image.\r\n * Attention: we can NOT create canvas dynamicly in Wechat mini-program, because Wechat\r\n * does not allow us to manipulate DOM.\r\n * \r\n * 该类被设计用来创建 canvas 层，在 CanvasPainter 类中会引用此类。\r\n * 在绘图过程中， CanvasPainter 会创建多个 canvas 实例来辅助操作，\r\n * 某些 canvas 实例是隐藏的，比如用来导出图片的 canvas。\r\n * 注意：在微信小程序中不能动态创建 canvas 标签，因为微信小程序不允许 DOM 操作。\r\n * \r\n * @author pissang(https://www.github.com/pissang)\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar CanvasLayer =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor CanvasLayer\r\n   * @param {HTMLDomElement|Canvas|Context} host \r\n   * This can be a HTMLDomElement like a DIV, or a Canvas instance, \r\n   * or Context for Wechat mini-program.\r\n   * \r\n   * 此属性可以是 HTMLDomElement ，比如 DIV 标签；也可以是 Canvas 实例；或者是 Context 实例，因为在某些\r\n   * 运行环境中，不能获得 Canvas 实例的引用，只能获得 Context。\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   * @param {Number} [dpr]\r\n   */\n  function CanvasLayer(host, width, height, dpr) {\n    _classCallCheck(this, CanvasLayer);\n\n    /**\r\n     * @property {String|Object} CanvasLayer id\r\n     */\n    this.id = guid();\n    /**\r\n     * @property {Number} CanvasLayer width\r\n     */\n\n    this.width = width;\n    /**\r\n     * @property {Number} CanvasLayer height\r\n     */\n\n    this.height = height;\n    /**\r\n     * @property {Number} CanvasLayer dpr\r\n     */\n\n    this.dpr = dpr;\n    /**\r\n     * @property {Context} ctx Canvas context, this property will be initialized after calling initContext() method.\r\n     */\n\n    this.ctx; // Create or set canvas instance.\n\n    var canvasInstance = null;\n\n    if (host && host.nodeName && host.nodeName.toUpperCase() === 'CANVAS') {\n      // host is a canvas instance\n      canvasInstance = host;\n      this.id = canvasInstance.id;\n    } else if (typeof host === 'string') {\n      // host is an id string\n      canvasInstance = canvasUtil.createCanvas(host, this.width, this.height, this.dpr);\n      this.id = host;\n    } else {\n      // host is a Context instance\n      this.ctx = host;\n    } // There is no style attribute of canvasInstance in nodejs.\n\n\n    if (canvasInstance && canvasInstance.style) {\n      canvasInstance.onselectstart = function () {\n        return false;\n      }; // 避免页面选中的尴尬\n\n\n      canvasInstance.style['-webkit-user-select'] = 'none';\n      canvasInstance.style['user-select'] = 'none';\n      canvasInstance.style['-webkit-touch-callout'] = 'none';\n      canvasInstance.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n      canvasInstance.style['padding'] = 0; // eslint-disable-line dot-notation\n\n      canvasInstance.style['margin'] = 0; // eslint-disable-line dot-notation\n\n      canvasInstance.style['border-width'] = 0;\n    }\n    /**\r\n     * @property {Canvas} canvasInstance\r\n     * 注意：this.canvasInstance 可能为null，因为在微信小程序中，没有办法获取 canvas 实例，只能获取到 Context 对象。\r\n     */\n\n\n    this.canvasInstance = canvasInstance;\n    /**\r\n     * @property {Canvas} hiddenCanvas 隐藏的画布实例\r\n     */\n\n    this.hiddenCanvas = null;\n    /**\r\n     * @property {Context} hiddenContext 隐藏的画布上下文\r\n     */\n\n    this.hiddenContext = null;\n    this.config = null;\n    /**\r\n     * @property {String} 每次清空画布的颜色\r\n     */\n\n    this.clearColor = 0;\n    /**\r\n     * @property {boolean} 是否开启动态模糊\r\n     */\n\n    this.motionBlur = false;\n    /**\r\n     * @property {Number} 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\r\n     */\n\n    this.lastFrameAlpha = 0.7;\n    this.__dirty = true;\n    this.__used = false;\n    this.__drawIndex = 0;\n    this.__startIndex = 0;\n    this.__endIndex = 0;\n    this.incremental = false;\n  }\n  /**\r\n   * @method getElementCount\r\n   */\n\n\n  _createClass(CanvasLayer, [{\n    key: \"getElementCount\",\n    value: function getElementCount() {\n      return this.__endIndex - this.__startIndex;\n    }\n    /**\r\n     * @method initContext\r\n     */\n\n  }, {\n    key: \"initContext\",\n    value: function initContext() {\n      if (this.canvasInstance) {\n        this.ctx = canvasUtil.getContext(this.canvasInstance);\n      }\n\n      this.ctx.dpr = this.dpr;\n    }\n    /**\r\n     * @method creatHiddenCanvas\r\n     */\n\n  }, {\n    key: \"creatHiddenCanvas\",\n    value: function creatHiddenCanvas() {\n      this.hiddenCanvas = canvasUtil.createCanvas('back-' + this.id, this.width, this.height, this.dpr);\n      this.hiddenContext = canvasUtil.getContext(this.hiddenCanvas);\n\n      if (this.dpr !== 1) {\n        this.hiddenContext.scale(this.dpr, this.dpr);\n      }\n    }\n    /**\r\n     * @method resize\r\n     * @param  {Number} width\r\n     * @param  {Number} height\r\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      //Can NOT get canvas instance in Wechat mini-program.\n      if (!this.canvasInstance) {\n        return;\n      }\n\n      if (this.canvasInstance.style) {\n        this.canvasInstance.style.width = width + 'px';\n        this.canvasInstance.style.height = height + 'px';\n      }\n\n      this.canvasInstance.width = width * this.dpr;\n      this.canvasInstance.height = height * this.dpr;\n\n      if (!this.hiddenCanvas) {\n        return;\n      }\n\n      this.hiddenCanvas.width = width * this.dpr;\n      this.hiddenCanvas.height = height * this.dpr;\n\n      if (this.dpr !== 1) {\n        this.hiddenContext.scale(this.dpr, this.dpr);\n      }\n    }\n    /**\r\n     * @method clear\r\n     * 清空该层画布\r\n     * @param {boolean} [clearAll=false] Clear all with out motion blur\r\n     * @param {Color} [clearColor]\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(clearAll, clearColor) {\n      clearColor = clearColor || this.clearColor;\n      var haveMotionBLur = this.motionBlur && !clearAll;\n      var lastFrameAlpha = this.lastFrameAlpha;\n      var dpr = this.dpr;\n\n      if (haveMotionBLur && this.canvasInstance) {\n        var _width = this.canvasInstance.width;\n        var _height = this.canvasInstance.height;\n\n        if (!this.hiddenCanvas) {\n          this.creatHiddenCanvas();\n        }\n\n        this.hiddenContext.globalCompositeOperation = 'copy';\n        this.hiddenContext.drawImage(this.canvasInstance, 0, 0, _width / dpr, _height / dpr);\n      }\n\n      this.ctx.clearRect(0, 0, this.width, this.height);\n\n      if (clearColor && clearColor !== 'transparent') {\n        var clearColorGradientOrPattern; // Gradient\n\n        if (clearColor.colorStops) {\n          // Cache canvasInstance gradient\n          clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(this.ctx, clearColor, {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n          });\n          clearColor.__canvasGradient = clearColorGradientOrPattern;\n        } else if (clearColor.image) {\n          // Pattern\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, this.ctx);\n        }\n\n        this.ctx.save();\n        this.ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.restore();\n      }\n\n      if (haveMotionBLur && this.hiddenCanvas) {\n        this.ctx.save();\n        this.ctx.globalAlpha = lastFrameAlpha;\n        this.ctx.drawImage(this.hiddenCanvas, 0, 0, width, height);\n        this.ctx.restore();\n      }\n    }\n  }]);\n\n  return CanvasLayer;\n}();\n\nmodule.exports = CanvasLayer;","var guid = require(\"./guid\");\n\n/**\r\n * 创建 canvas 实例\r\n * @param {String} id\r\n * @param {Number} width\r\n * @param {Number} height\r\n * @param {Number} dpr\r\n * @return {Canvas}\r\n */\nfunction createCanvas(id, width, height, dpr) {\n  var canvas = document.createElement('canvas');\n\n  if (id == null || id == undefined) {\n    id = guid();\n  }\n\n  canvas.setAttribute('data-qr-dom-id', id);\n\n  if (width == null || width == undefined || height == null || height == undefined) {\n    return canvas;\n  } // Canvas instance has no style attribute in nodejs.\n\n\n  if (canvas.style) {\n    canvas.style.position = 'absolute';\n    canvas.style.left = 0;\n    canvas.style.top = 0;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  if (dpr == null || dpr == undefined) {\n    return canvas;\n  }\n\n  canvas.width = width * dpr;\n  canvas.height = height * dpr;\n  return canvas;\n}\n\nfunction getContext(canvasInstance) {\n  if (!canvasInstance) {\n    canvasInstance = createCanvas();\n  }\n\n  return canvasInstance.getContext('2d');\n}\n\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;","var fixShadow = require(\"./utils/fix_shadow\");\n\nvar _constants = require(\"./constants\");\n\nvar ContextCachedBy = _constants.ContextCachedBy;\n\nvar _constants2 = require(\"../graphic/constants\");\n\nvar mathMin = _constants2.mathMin;\n\n/**\r\n * @class qrenderer.graphic.Style\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]];\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  } // Fix NaN when rect is Infinity\n\n\n  x = isNaN(x) ? 0 : x;\n  x2 = isNaN(x2) ? 1 : x2;\n  y = isNaN(y) ? 0 : y;\n  y2 = isNaN(y2) ? 0 : y2;\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = mathMin(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nvar Style = function Style(opts) {\n  this.extendStyle(opts, false);\n};\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\r\n   * @property {String} fill\r\n   */\n  fill: '#000',\n\n  /**\r\n   * @property {String} stroke\r\n   */\n  stroke: null,\n\n  /**\r\n   * @property {Number} opacity\r\n   */\n  opacity: 1,\n\n  /**\r\n   * @property {Number} fillOpacity\r\n   */\n  fillOpacity: null,\n\n  /**\r\n   * @property {Number} strokeOpacity\r\n   */\n  strokeOpacity: null,\n\n  /**\r\n   * @property {Array<Number>|Boolean} lineDash\r\n   * `true` is not supported.\r\n   * `false`/`null`/`undefined` are the same.\r\n   * `false` is used to remove lineDash in some\r\n   * case that `null`/`undefined` can not be set.\r\n   * (e.g., emphasis.lineStyle in echarts)\r\n   */\n  lineDash: null,\n\n  /**\r\n   * @property {Number} lineDashOffset\r\n   */\n  lineDashOffset: 0,\n\n  /**\r\n   * @property {Number} shadowBlur\r\n   */\n  shadowBlur: 0,\n\n  /**\r\n   * @property {Number} shadowOffsetX\r\n   */\n  shadowOffsetX: 0,\n\n  /**\r\n   * @property {Number} shadowOffsetY\r\n   */\n  shadowOffsetY: 0,\n\n  /**\r\n   * @property {Number} lineWidth\r\n   */\n  lineWidth: 1,\n\n  /**\r\n   * @property {Boolean} strokeNoScale\r\n   * If stroke ignore scale\r\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\r\n   * @property {String} text\r\n   */\n  text: null,\n\n  /**\r\n   * @property {String} font\r\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\r\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\r\n   * So do not visit it directly in upper application (like echarts),\r\n   * but use `contain/text#makeFont` instead.\r\n   */\n  font: null,\n\n  /**\r\n   * @deprecated\r\n   * @property {String} textFont\r\n   * The same as font. Use font please.\r\n   */\n  textFont: null,\n\n  /**\r\n   * @property {String} fontStyle\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   */\n  fontStyle: null,\n\n  /**\r\n   * @property {String} fontWeight\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   */\n  fontWeight: null,\n\n  /**\r\n   * @property {Number} fontSize\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   * Should be 12 but not '12px'.\r\n   */\n  fontSize: null,\n\n  /**\r\n   * @property {String} fontFamily\r\n   * It helps merging respectively, rather than parsing an entire font string.\r\n   */\n  fontFamily: null,\n\n  /**\r\n   * @property {String} textTag\r\n   * Reserved for special functinality, like 'hr'.\r\n   */\n  textTag: null,\n\n  /**\r\n   * @property {String} textFill\r\n   */\n  textFill: '#000',\n\n  /**\r\n   * @property {String} textStroke\r\n   */\n  textStroke: null,\n\n  /**\r\n   * @property {Number} textWidth\r\n   */\n  textWidth: null,\n\n  /**\r\n   * @property {Number} textHeight\r\n   * Only for textBackground.\r\n   */\n  textHeight: null,\n\n  /**\r\n   * @property {Number} textStrokeWidth\r\n   * textStroke may be set as some color as a default\r\n   * value in upper applicaion, where the default value\r\n   * of textStrokeWidth should be 0 to make sure that\r\n   * user can choose to do not use text stroke.\r\n   */\n  textStrokeWidth: 0,\n\n  /**\r\n   * @property {Number} textLineHeight\r\n   */\n  textLineHeight: null,\n\n  /**\r\n   * @property {string|Array<Number>} textPosition\r\n   * 'inside', 'left', 'right', 'top', 'bottom'\r\n   * [x, y]\r\n   * Based on x, y of rect.\r\n   */\n  textPosition: 'inside',\n\n  /**\r\n   * @property {Object} textRect\r\n   * If not specified, use the boundingRect of a `displayable`.\r\n   */\n  textRect: null,\n\n  /**\r\n   * @property {Array<Number>} textOffset\r\n   * [x, y]\r\n   */\n  textOffset: null,\n\n  /**\r\n   * @property {String} textAlign\r\n   */\n  textAlign: null,\n\n  /**\r\n   * @property {String} textVerticalAlign\r\n   */\n  textVerticalAlign: null,\n\n  /**\r\n   * @property {Number} textDistance\r\n   */\n  textDistance: 5,\n\n  /**\r\n   * @property {String} textShadowColor\r\n   */\n  textShadowColor: 'transparent',\n\n  /**\r\n   * @property {Number} textShadowBlur\r\n   */\n  textShadowBlur: 0,\n\n  /**\r\n   * @property {Number} textShadowOffsetX\r\n   */\n  textShadowOffsetX: 0,\n\n  /**\r\n   * @property {Number} textShadowOffsetY\r\n   */\n  textShadowOffsetY: 0,\n\n  /**\r\n   * @property {String} textBoxShadowColor\r\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\r\n   * @property {Number} textBoxShadowBlur\r\n   */\n  textBoxShadowBlur: 0,\n\n  /**\r\n   * @property {Number} textBoxShadowOffsetX\r\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\r\n   * @property {Number} textBoxShadowOffsetY\r\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\r\n   * @property {Boolean} transformText\r\n   * Whether transform text.\r\n   * Only available in Path and Image element,\r\n   * where the text is called as `RectText`.\r\n   */\n  transformText: false,\n\n  /**\r\n   * @property {Number} textRotation\r\n   * Text rotate around position of Path or Image.\r\n   * The origin of the rotation can be specified by `textOrigin`.\r\n   * Only available in Path and Image element,\r\n   * where the text is called as `RectText`.\r\n   */\n  textRotation: 0,\n\n  /**\r\n   * @property {String|Array<Number>} textOrigin\r\n   * Text origin of text rotation.\r\n   * Useful in the case like label rotation of circular symbol.\r\n   * Only available in Path and Image element, where the text is called\r\n   * as `RectText` and the element is called as \"host element\".\r\n   * The value can be:\r\n   * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`\r\n   * base on the left-top corner of the rect of its host element.\r\n   * + If specified as a string `center`, it is the center of the rect of\r\n   * its host element.\r\n   * + By default, this origin is the `textPosition`.\r\n   */\n  textOrigin: null,\n\n  /**\r\n   * @property {String} textBackgroundColor\r\n   */\n  textBackgroundColor: null,\n\n  /**\r\n   * @property {String} textBorderColor\r\n   */\n  textBorderColor: null,\n\n  /**\r\n   * @property {Number} textBorderWidth\r\n   */\n  textBorderWidth: 0,\n\n  /**\r\n   * @property {Number} textBorderRadius\r\n   */\n  textBorderRadius: 0,\n\n  /**\r\n   * @property {number|Array<Number>} textPadding\r\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\r\n   */\n  textPadding: null,\n\n  /**\r\n   * @property {Object} rich\r\n   * Text styles for rich text.\r\n   */\n  rich: null,\n\n  /**\r\n   * @property {Object} truncate\r\n   * {outerWidth, outerHeight, ellipsis, placeholder}\r\n   */\n  truncate: null,\n\n  /**\r\n   * @property {String} blend\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\r\n   */\n  blend: null,\n\n  /**\r\n   * @method bind\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   * @param {Element} el\r\n   * @param {Element} prevEl\r\n   */\n  bind: function bind(ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style; // If no prevStyle, it means first draw.\n    // Only apply cache if the last time cachced by this function.\n\n    var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;\n    ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (notCheckCache || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);\n      }\n    }\n\n    if (notCheckCache || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (notCheckCache || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (notCheckCache || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (notCheckCache || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n\n  /**\r\n   * @method hasFill\r\n   */\n  hasFill: function hasFill() {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n\n  /**\r\n   * @method hasStroke\r\n   */\n  hasStroke: function hasStroke() {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\r\n   * @method extendStyle\r\n   * Extend from other style\r\n   * @param {Style} otherStyle\r\n   * @param {Boolean} overwrite true: overwrirte any way.\r\n   *                            false: overwrite only when !target.hasOwnProperty\r\n   *                            others: overwrite when property is not null/undefined.\r\n   */\n  extendStyle: function extendStyle(otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\r\n   * @method set\r\n   * Batch setting style with a given object\r\n   * @param {Object|String} obj\r\n   * @param {*} [obj]\r\n   */\n  set: function set(obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendStyle(obj, true);\n    }\n  },\n\n  /**\r\n   * @method clone\r\n   * @return {Style}\r\n   */\n  clone: function clone() {\n    var newStyle = new this.constructor();\n    newStyle.extendStyle(this, true);\n    return newStyle;\n  },\n\n  /**\r\n   * @method getGradient\r\n   * @param {*} ctx \r\n   * @param {*} obj \r\n   * @param {*} rect \r\n   */\n  getGradient: function getGradient(ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;","var SHADOW_PROPS = {\n  'shadowBlur': 1,\n  'shadowOffsetX': 1,\n  'shadowOffsetY': 1,\n  'textShadowBlur': 1,\n  'textShadowOffsetX': 1,\n  'textShadowOffsetY': 1,\n  'textBoxShadowBlur': 1,\n  'textBoxShadowOffsetX': 1,\n  'textBoxShadowOffsetY': 1\n};\n\nfunction _default(ctx, propName, value) {\n  if (SHADOW_PROPS.hasOwnProperty(propName)) {\n    return value *= ctx.dpr;\n  }\n\n  return value;\n}\n\nmodule.exports = _default;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.graphic.Pattern\r\n * \r\n * Pattern\r\n * \r\n * 图案\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Pattern =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method  constructor Pattern\r\n   * @param {*} image \r\n   * @param {*} repeat \r\n   */\n  function Pattern(image, repeat) {\n    _classCallCheck(this, Pattern);\n\n    // Should do nothing more in this constructor. Because gradient can be\n    // declard by `color: {image: ...}`, where this constructor will not be called.\n    this.image = image;\n    this.repeat = repeat; // Can be cloned\n\n    this.type = 'pattern';\n  }\n\n  _createClass(Pattern, [{\n    key: \"getCanvasPattern\",\n    value: function getCanvasPattern(ctx) {\n      return ctx.createPattern(this.image, this.repeat || 'repeat');\n    }\n  }]);\n\n  return Pattern;\n}();\n\nvar _default = Pattern;\nmodule.exports = _default;","var Displayable = require(\"./Displayable\");\n\nvar BoundingRect = require(\"./transform/BoundingRect\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar imageHelper = require(\"./utils/image\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.ZImage \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar ZImage =\n/*#__PURE__*/\nfunction (_Displayable) {\n  _inherits(ZImage, _Displayable);\n\n  /**\r\n   * @method constructor ZImage\r\n   * @param {Object} options\r\n   */\n  function ZImage(options) {\n    var _this;\n\n    _classCallCheck(this, ZImage);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZImage).call(this, options));\n    /**\r\n     * @property {String}\r\n     */\n\n    _this.type = 'image';\n    return _this;\n  }\n  /**\r\n   * @method brush\r\n   * @param {Object} ctx \r\n   * @param {Element} prevEl \r\n   */\n\n\n  _createClass(ZImage, [{\n    key: \"brush\",\n    value: function brush(ctx, prevEl) {\n      var style = this.style;\n      var src = style.image; // Must bind each time\n\n      style.bind(ctx, this, prevEl);\n      var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n      if (!image || !imageHelper.isImageReady(image)) {\n        return;\n      }\n\n      var x = style.x || 0;\n      var y = style.y || 0;\n      var width = style.width;\n      var height = style.height;\n      var aspect = image.width / image.height;\n\n      if (width == null && height != null) {\n        // Keep image/height ratio\n        width = height * aspect;\n      } else if (height == null && width != null) {\n        height = width / aspect;\n      } else if (width == null && height == null) {\n        width = image.width;\n        height = image.height;\n      } // 设置transform\n\n\n      this.setTransform(ctx);\n\n      if (style.sWidth && style.sHeight) {\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n        ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n      } else if (style.sx && style.sy) {\n        var _sx = style.sx;\n        var _sy = style.sy;\n        var sWidth = width - _sx;\n        var sHeight = height - _sy;\n        ctx.drawImage(image, _sx, _sy, sWidth, sHeight, x, y, width, height);\n      } else {\n        ctx.drawImage(image, x, y, width, height);\n      } // Draw rect text\n\n\n      if (style.text != null) {\n        // Only restore transform when needs draw text.\n        this.restoreTransform(ctx);\n        this.drawRectText(ctx, this.getBoundingRect());\n      }\n    }\n    /**\r\n     * @method getBoundingRect\r\n     */\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect() {\n      var style = this.style;\n\n      if (!this._rect) {\n        this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n      }\n\n      return this._rect;\n    }\n  }]);\n\n  return ZImage;\n}(Displayable);\n\nmodule.exports = ZImage;","var classUtil = require(\"../core/utils/class_util\");\n\nvar Style = require(\"./Style\");\n\nvar Element = require(\"./Element\");\n\nvar RectText = require(\"./RectText\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @abstract\r\n * @class qrenderer.graphic.Displayable \r\n * \r\n * Base class of all displayable graphic objects.\r\n * \r\n * 所有图形对象的基类，抽象类。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Displayable =\n/*#__PURE__*/\nfunction (_Element) {\n  _inherits(Displayable, _Element);\n\n  /**\r\n   * @method constructor\r\n   * @param {*} options \r\n   */\n  function Displayable() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Displayable);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Displayable).call(this, options));\n    /**\r\n     * @private\r\n     * @property  __clipPaths\r\n     * Shapes for cascade clipping.\r\n     * Can only be `null`/`undefined` or an non-empty array, MUST NOT be an empty array.\r\n     * because it is easy to only using null to check whether clipPaths changed.\r\n     */\n\n    _this.__clipPaths = null; // FIXME Stateful must be mixined after style is setted\n    // Stateful.call(this, options);\n\n    /**\r\n     * The String value of `textPosition` needs to be calculated to a real postion.\r\n     * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`\r\n     * by default. See `contain/text.js#calculateTextPosition` for more details.\r\n     * But some coutom shapes like \"pin\", \"flag\" have center that is not exactly\r\n     * `[width/2, height/2]`. So we provide this hook to customize the calculation\r\n     * for those shapes. It will be called if the `style.textPosition` is a String.\r\n     * @param {Obejct} [out] Prepared out object. If not provided, this method should\r\n     *        be responsible for creating one.\r\n     * @param {Style} style\r\n     * @param {Object} rect {x, y, width, height}\r\n     * @return {Obejct} out The same as the input out.\r\n     *         {\r\n     *             x: Number. mandatory.\r\n     *             y: Number. mandatory.\r\n     *             textAlign: String. optional. use style.textAlign by default.\r\n     *             textVerticalAlign: String. optional. use style.textVerticalAlign by default.\r\n     *         }\r\n     */\n\n    _this.calculateTextPosition = null;\n    /**\r\n     * @property {String} type\r\n     */\n\n    _this.type = 'displayable';\n    /**\r\n     * @property {Boolean} invisible\r\n     * Whether the displayable object is visible. when it is true, the displayable object\r\n     * is not drawn, but the mouse event can still trigger the object.\r\n     */\n\n    _this.invisible = false;\n    /**\r\n     * @property {Number} z\r\n     */\n\n    _this.z = 0;\n    /**\r\n     * @property {Number} z2\r\n     */\n\n    _this.z2 = 0;\n    /**\r\n     * @property {Number} qlevel\r\n     * The q level determines the displayable object can be drawn in which layer canvas.\r\n     */\n\n    _this.qlevel = 0;\n    /**\r\n     * @property {Boolean} draggable\r\n     * Whether it can be dragged.\r\n     */\n\n    _this.draggable = false;\n    /**\r\n     * @property {Boolean} dragging\r\n     * Whether is it dragging.\r\n     */\n\n    _this.dragging = false;\n    /**\r\n     * @property {Boolean} silent\r\n     * Whether to respond to mouse events.\r\n     */\n\n    _this.silent = false;\n    /**\r\n     * @property {Boolean} culling\r\n     * If enable culling\r\n     */\n\n    _this.culling = false;\n    /**\r\n     * @property {String} cursor\r\n     * Mouse cursor when hovered\r\n     */\n\n    _this.cursor = 'pointer';\n    /**\r\n     * @property {String} rectHover\r\n     * If hover area is bounding rect\r\n     */\n\n    _this.rectHover = false;\n    /**\r\n     * @property {Boolean} progressive\r\n     * Render the element progressively when the value >= 0,\r\n     * usefull for large data.\r\n     */\n\n    _this.progressive = false;\n    /**\r\n     * @property {Boolean} incremental\r\n     */\n\n    _this.incremental = false;\n    /**\r\n     * @property {Boolean} globalScaleRatio\r\n     * Scale ratio for global scale.\r\n     */\n\n    _this.globalScaleRatio = 1;\n    /**\r\n     * @property {Style} style\r\n     */\n\n    _this.style = new Style(options.style, _assertThisInitialized(_this));\n    /**\r\n     * @property {Object} shape 形状\r\n     */\n\n    _this.shape = {}; // Extend default shape\n\n    var defaultShape = _this.options.shape;\n\n    if (defaultShape) {\n      for (var name in defaultShape) {\n        if (!_this.shape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          _this.shape[name] = defaultShape[name];\n        }\n      }\n    } // FIXME 不能 extend position, rotation 等引用对象 TODO:why?\n\n\n    classUtil.copyOwnProperties(_assertThisInitialized(_this), _this.options, ['style', 'shape']);\n    return _this;\n  }\n  /**\r\n   * @protected\r\n   * @method beforeBrush\r\n   */\n\n\n  _createClass(Displayable, [{\n    key: \"beforeBrush\",\n    value: function beforeBrush(ctx) {}\n    /**\r\n     * @protected\r\n     * @method brush\r\n     * Callback during brush.\r\n     */\n\n  }, {\n    key: \"brush\",\n    value: function brush(ctx, prevEl) {}\n    /**\r\n     * @protected\r\n     * @method afterBrush\r\n     */\n\n  }, {\n    key: \"afterBrush\",\n    value: function afterBrush(ctx) {}\n    /**\r\n     * @protected\r\n     * @method getBoundingRect\r\n     */\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect() {}\n    /**\r\n     * @protected\r\n     * @method contain\r\n     * \r\n     * If displayable element contain coord x, y, this is an util function for\r\n     * determine where two elements overlap.\r\n     * \r\n     * 图元是否包含坐标(x,y)，此工具方法用来判断两个图元是否重叠。\r\n     * \r\n     * @param  {Number} x\r\n     * @param  {Number} y\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: \"contain\",\n    value: function contain(x, y) {\n      return this.rectContain(x, y);\n    }\n    /**\r\n     * @protected\r\n     * @method rectContain\r\n     * \r\n     * If bounding rect of element contain coord x, y.\r\n     * \r\n     * 用来判断当前图元的外框矩形是否包含坐标点(x,y)。\r\n     * \r\n     * @param  {Number} x\r\n     * @param  {Number} y\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: \"rectContain\",\n    value: function rectContain(x, y) {\n      var coord = this.transformCoordToLocal(x, y);\n      var rect = this.getBoundingRect();\n      return rect.contain(coord[0], coord[1]);\n    }\n    /**\r\n     * @method traverse\r\n     * @param  {Function} cb\r\n     * @param  {Object}  context\r\n     */\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(cb, context) {\n      cb.call(context, this);\n    }\n    /**\r\n     * @method animateStyle\r\n     * Alias for animate('style')\r\n     * @param {Boolean} loop\r\n     */\n\n  }, {\n    key: \"animateStyle\",\n    value: function animateStyle(loop) {\n      return this.animate('style', loop);\n    }\n    /**\r\n     * @method attrKV\r\n     * @param {*} key \r\n     * @param {*} value \r\n     */\n\n  }, {\n    key: \"attrKV\",\n    value: function attrKV(key, value) {\n      if (key !== 'style') {\n        Element.prototype.attrKV.call(this, key, value);\n      } else {\n        this.style.set(value);\n      }\n    }\n    /**\r\n     * @method setStyle\r\n     * @param {Object|String} key\r\n     * @param {*} value\r\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(key, value) {\n      this.style.set(key, value);\n      this.dirty(false);\n      return this;\n    }\n    /**\r\n     * @method useStyle\r\n     * Use given style object\r\n     * @param  {Object} obj\r\n     */\n\n  }, {\n    key: \"useStyle\",\n    value: function useStyle(obj) {\n      this.style = new Style(obj, this);\n      this.dirty(false);\n      return this;\n    }\n  }]);\n\n  return Displayable;\n}(Element);\n\nclassUtil.mixin(Displayable, RectText);\nvar _default = Displayable;\nmodule.exports = _default;","var textUtil = require(\"./utils/text_util\");\n\nvar BoundingRect = require(\"./transform/BoundingRect\");\n\nvar _constants = require(\"./constants\");\n\nvar WILL_BE_RESTORED = _constants.WILL_BE_RESTORED;\n\n/**\r\n * @class qrenderer.graphic.RectText \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function RectText() {};\n/**\r\n * @method constructor RectText\r\n */\n\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\r\n   * Draw text in a rect with specified position.\r\n   * @param  {CanvasRenderingContext2D} ctx\r\n   * @param  {Object} rect Displayable rect\r\n   */\n  drawRectText: function drawRectText(ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textUtil.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textUtil.needDrawText(text, style)) {\n      return;\n    } // FIXME\n    // Do not provide prevEl to `textUtil.renderText` for ctx prop cache,\n    // but use `ctx.save()` and `ctx.restore()`. Because the cache for rect\n    // text propably break the cache for its host elements.\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textUtil.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;","var dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar textContain = require(\"../../core/contain/text\");\n\nvar roundRectHelper = require(\"./round_rect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fix_shadow\");\n\nvar _constants = require(\"../constants\");\n\nvar ContextCachedBy = _constants.ContextCachedBy;\nvar WILL_BE_RESTORED = _constants.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\r\n * @param {Style} style\r\n * @return {Style} The input style.\r\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  dataUtil.each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = dataUtil.normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {String} text\r\n * @param {Style} style\r\n * @param {Object|boolean} [rect] {x, y, width, height}\r\n *                  If set false, rect text is not used.\r\n * @param {Element|helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\r\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  \n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n    }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', dataUtil.retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', dataUtil.retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', dataUtil.retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = dataUtil.retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = dataUtil.isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (dataUtil.isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\r\n * @param {String} [stroke] If specified, do not check style.textStroke.\r\n * @param {String} [lineWidth] If specified, do not check style.textStroke.\r\n * @param {Number} style\r\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\r\n * @param {String} text\r\n * @param {Style} style\r\n * @return {boolean}\r\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;","var BoundingRect = require(\"../../graphic/transform/BoundingRect\");\n\nvar imageHelper = require(\"../../graphic/utils/image\");\n\nvar _data_structure_util = require(\"../utils/data_structure_util\");\n\nvar extend = _data_structure_util.extend;\nvar retrieve2 = _data_structure_util.retrieve2;\nvar retrieve3 = _data_structure_util.retrieve3;\nvar trim = _data_structure_util.trim;\n\nvar _canvas_util = require(\"../utils/canvas_util\");\n\nvar getContext = _canvas_util.getContext;\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathMax = _constants.mathMax;\nvar mathFloor = _constants.mathFloor;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\r\n * @public\r\n * @param {String} text\r\n * @param {String} font\r\n * @return {Number} width\r\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = mathMax(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\r\n * @public\r\n * @param {String} text\r\n * @param {String} font\r\n * @param {String} [textAlign='left']\r\n * @param {String} [textVerticalAlign='top']\r\n * @param {Array<Number>} [textPadding]\r\n * @param {Object} [rich]\r\n * @param {Object} [truncate]\r\n * @return {Object} {x, y, width, height, lineHeight}\r\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\r\n * @public\r\n * @param {Number} x\r\n * @param {Number} width\r\n * @param {String} [textAlign='left']\r\n * @return {Number} Adjusted x.\r\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\r\n * @public\r\n * @param {Number} y\r\n * @param {Number} height\r\n * @param {String} [textVerticalAlign='top']\r\n * @return {Number} Adjusted y.\r\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\r\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\r\n * @public\r\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\r\n * @param {Style} style where `textPosition` and `textDistance` are visited.\r\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\r\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\r\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\r\n * To be removed. But still do not remove in case that some one has imported it.\r\n * @deprecated\r\n * @public\r\n * @param {stirng} textPosition\r\n * @param {Object} rect {x, y, width, height}\r\n * @param {Number} distance\r\n * @return {Object} {x, y, textAlign, textVerticalAlign}\r\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\r\n * Show ellipsis if overflow.\r\n *\r\n * @public\r\n * @param  {String} text\r\n * @param  {String} containerWidth\r\n * @param  {String} font\r\n * @param  {Number} [ellipsis='...']\r\n * @param  {Object} [options]\r\n * @param  {Number} [options.maxIterations=3]\r\n * @param  {Number} [options.minChar=0] If truncate result are less\r\n *                  then minChar, ellipsis will not show, which is\r\n *                  better for user hint in some cases.\r\n * @param  {Number} [options.placeholder=''] When all truncated, use the placeholder.\r\n * @return {String}\r\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = mathMax(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? mathFloor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\r\n * @public\r\n * @param {String} font\r\n * @return {Number} line height\r\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\r\n * @public\r\n * @param {String} text\r\n * @param {String} font\r\n * @return {Object} width\r\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\r\n * @public\r\n * @param {String} text\r\n * @param {String} font\r\n * @param {Object} [truncate]\r\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\r\n *  Notice: for performance, do not calculate outerWidth util needed.\r\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\r\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\r\n *  without travel the result `lines`.\r\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\r\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\r\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\r\n *\r\n * @public\r\n * @param {String} text\r\n * @param {Object} style\r\n * @return {Object} block\r\n * {\r\n *      width,\r\n *      height,\r\n *      lines: [{\r\n *          lineHeight,\r\n *          width,\r\n *          tokens: [[{\r\n *              styleName,\r\n *              text,\r\n *              width,      // include textPadding\r\n *              height,     // include textPadding\r\n *              textWidth, // pure text width\r\n *              textHeight, // pure text height\r\n *              lineHeihgt,\r\n *              font,\r\n *              textAlign,\r\n *              textVerticalAlign\r\n *          }], [...], ...]\r\n *      }, ...]\r\n * }\r\n * If styleName is undefined, it is plain text.\r\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = mathMax(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = mathMax(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = mathMax(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var _i = 0; _i < pendingList.length; _i++) {\n    var _token = pendingList[_i];\n    var percentWidth = _token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    _token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\r\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\r\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\r\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\r\n * Caution: User should cache loaded images, but not just count on LRU.\r\n * Consider if required images more than LRU size, will dead loop occur?\r\n *\r\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\r\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\r\n * @param {Element} [hostEl] For calling `dirty`.\r\n * @param {Function} [cb] params: (image, cbPayload)\r\n * @param {Object} [cbPayload] Payload on cb calling.\r\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\r\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__qrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      image = new Image();\n      image.onload = image.onerror = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__qrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.onerror = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;","/**\r\n * @param {Object} ctx\r\n * @param {Object} shape\r\n * @param {Number} shape.x\r\n * @param {Number} shape.y\r\n * @param {Number} shape.width\r\n * @param {Number} shape.height\r\n * @param {Number} shape.r\r\n */\nfunction buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n}\n\nexports.buildPath = buildPath;","var dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../core/utils/class_util\");\n\nvar _event_util = require(\"../core/utils/event_util\");\n\nvar Dispatcher = _event_util.Dispatcher;\n\nvar requestAnimationFrame = require(\"./utils/request_animation_frame\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @singleton\r\n * @class qrenderer.animation.GlobalAnimationMgr\r\n * \r\n * Animation manager, global singleton, controls all the animation process.\r\n * Each QRenderer instance has a GlobalAnimationMgr instance. GlobalAnimationMgr \r\n * is designed to manage all the AnimationProcesses inside a qrenderer instance.\r\n * \r\n * 动画管理器，全局单例，控制和调度所有动画过程。每个 qrenderer 实例中会持有一个 \r\n * GlobalAnimationMgr 实例。GlobalAnimationMgr 会管理 qrenderer 实例中的所有\r\n * AnimationProcess。\r\n * \r\n * @author pissang(https://github.com/pissang)\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\nvar GlobalAnimationMgr =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor GlobalAnimationMgr\r\n   * @param {Object} [options]\r\n   */\n  function GlobalAnimationMgr(options) {\n    _classCallCheck(this, GlobalAnimationMgr);\n\n    options = options || {};\n    this._animationProcessList = [];\n    this._running = false;\n    this._timestamp;\n    this._pausedTime; //ms\n\n    this._pauseStart;\n    this._paused = false;\n    Dispatcher.call(this);\n  }\n  /**\r\n   * @method addAnimationProcess\r\n   * 添加 animationProcess\r\n   * @param {qrenderer.animation.GlobalAnimationMgr} animationProcess\r\n   */\n\n\n  _createClass(GlobalAnimationMgr, [{\n    key: \"addAnimationProcess\",\n    value: function addAnimationProcess(animationProcess) {\n      this._animationProcessList.push(animationProcess);\n    }\n    /**\r\n     * @method removeAnimationProcess\r\n     * 删除动画片段\r\n     * @param {qrenderer.animation.GlobalAnimationMgr} animationProcess\r\n     */\n\n  }, {\n    key: \"removeAnimationProcess\",\n    value: function removeAnimationProcess(animationProcess) {\n      var index = this._animationProcessList.findIndex(animationProcess);\n\n      if (index >= 0) {\n        this._animationProcessList.splice(index, 1);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method _update\r\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      var time = new Date().getTime() - this._pausedTime;\n\n      var delta = time - this._timestamp;\n\n      this._animationProcessList.forEach(function (ap, index) {\n        ap.nextFrame(time, delta);\n      });\n\n      this._timestamp = time; // TODO:What's going on here?\n      // 'frame' should be triggered before stage, because upper application\n      // depends on the sequence (e.g., echarts-stream and finish\n      // event judge)\n\n      this.trigger('frame', delta);\n    }\n    /**\r\n     * @private\r\n     * @method _startLoop\r\n     * TODO:需要确认在大量节点下的动画性能问题，比如 100 万个元素同时进行动画\r\n     * 这里开始利用requestAnimationFrame递归执行\r\n     * 如果这里的 _update() 不能在16ms的时间内完成一轮动画，就会出现明显的卡顿。\r\n     * 按照 W3C 的推荐标准 60fps，这里的 step 函数大约每隔 16ms 被调用一次\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\r\n     */\n\n  }, {\n    key: \"_startLoop\",\n    value: function _startLoop() {\n      var self = this;\n      this._running = true;\n\n      function nextFrame() {\n        if (self._running) {\n          requestAnimationFrame(nextFrame);\n          !self._paused && self._update();\n        }\n      }\n\n      requestAnimationFrame(nextFrame);\n    }\n    /**\r\n     * @method start\r\n     * Start all the animations.\r\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._timestamp = new Date().getTime();\n      this._pausedTime = 0;\n\n      this._startLoop();\n    }\n    /**\r\n     * @method stop\r\n     * Stop all the animations.\r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n    }\n    /**\r\n     * @method pause\r\n     * Pause all the animations.\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (!this._paused) {\n        this._pauseStart = new Date().getTime();\n        this._paused = true;\n      }\n    }\n    /**\r\n     * @method resume\r\n     * Resume all the animations.\r\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._paused) {\n        this._pausedTime += new Date().getTime() - this._pauseStart;\n        this._paused = false;\n      }\n    }\n    /**\r\n     * @method clear\r\n     * Clear all the animations.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._animationProcessList.length = 0;\n    }\n    /**\r\n     * @method isFinished\r\n     * Whether all the animations have finished.\r\n     */\n\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      var finished = true;\n\n      this._animationProcessList.forEach(function (animationProcess, index) {\n        if (!animationProcess.isFinished()) {\n          finished = false;\n        }\n      });\n\n      return finished;\n    }\n  }]);\n\n  return GlobalAnimationMgr;\n}();\n\nclassUtil.mixin(GlobalAnimationMgr, Dispatcher);\nvar _default = GlobalAnimationMgr;\nmodule.exports = _default;","var Eventful = require(\"./Eventful\");\n\nvar eventUtil = require(\"../core/utils/event_util\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../core/utils/class_util\");\n\nvar env = require(\"../core/env\");\n\n/**\r\n * @class qrenderer.event.DomEventProxy\r\n * DomEventProxy 的主要功能是：把原生的 DOM 事件代理（转发）到 QuarkRender 实例上，\r\n * 在 QuarkRendererEventHandler 类中会把事件进一步分发给 canvas 中绘制的元素。\r\n * 需要转发的大部分 DOM 事件挂载在 canvas 的外层容器 div 上面，例如：click, dbclick ；\r\n * 少部分 DOM 事件挂载在 document 对象上，例如：mousemove, mouseout。因为在实现拖拽和\r\n * 键盘交互的过程中，鼠标指针可能已经脱离了 canvas 所在的区域。\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar TOUCH_CLICK_DELAY = 300; // \"page event\" is defined in the comment of `[Page Event]`.\n\nvar pageEventSupported = env.domSupported;\n/**\r\n * [Page Event]\r\n * \"page events\" are `pagemousemove` and `pagemouseup`.\r\n * They are triggered when a user pointer interacts on the whole webpage\r\n * rather than only inside the qrenderer area.\r\n *\r\n * The use case of page events can be, for example, if we are implementing a dragging feature:\r\n * ```js\r\n * qr.on('mousedown', function (event) {\r\n *     let dragging = true;\r\n *\r\n *     // Listen to `pagemousemove` and `pagemouseup` rather than `mousemove` and `mouseup`,\r\n *     // because `mousemove` and `mouseup` will not be triggered when the pointer is out\r\n *     // of the qrenderer area.\r\n *     qr.on('pagemousemove', handleMouseMove);\r\n *     qr.on('pagemouseup', handleMouseUp);\r\n *\r\n *     function handleMouseMove(event) {\r\n *         if (dragging) { ... }\r\n *     }\r\n *     function handleMouseUp(event) {\r\n *         dragging = false; ...\r\n *         qr.off('pagemousemove', handleMouseMove);\r\n *         qr.off('pagemouseup', handleMouseUp);\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * [NOTICE]:\r\n * (1) There are cases that `pagemousexxx` will not be triggered when the pointer is out of\r\n * qrenderer area:\r\n * \"document.eventUtil.addEventListener\" is not available in the current runtime environment,\r\n * or there is any `stopPropagation` called at some user defined listeners on the ancestors\r\n * of the qrenderer dom.\r\n * (2) Although those bad cases exist, users do not need to worry about that. That is, if you\r\n * listen to `pagemousexxx`, you do not need to listen to the correspoinding event `mousexxx`\r\n * any more.\r\n * Becuase inside qrenderer area, `pagemousexxx` will always be triggered, where they are\r\n * triggered just after `mousexxx` triggered and sharing the same event object. Those bad\r\n * cases only happen when the pointer is out of qrenderer area.\r\n */\n\nvar localNativeListenerNames = function () {\n  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n  var pointerEventNameMap = {\n    pointerdown: 1,\n    pointerup: 1,\n    pointermove: 1,\n    pointerout: 1\n  };\n  var pointerHandlerNames = dataUtil.map(mouseHandlerNames, function (name) {\n    var nm = name.replace('mouse', 'pointer');\n    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\n  });\n  return {\n    mouse: mouseHandlerNames,\n    touch: touchHandlerNames,\n    pointer: pointerHandlerNames\n  };\n}();\n\nvar globalNativeListenerNames = {\n  keyboard: ['keydown', 'keyup'],\n  mouse: ['mousemove', 'mouseup'],\n  touch: ['touchmove', 'touchend'],\n  pointer: ['pointermove', 'pointerup']\n};\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n}\n/**\r\n * Prevent mouse event from being dispatched after Touch Events action\r\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\r\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\r\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\r\n * Result: Blocking Mouse Events for 700ms.\r\n *\r\n * @param {DOMHandlerScope} scope\r\n */\n\n\nfunction setTouchTimer(scope) {\n  scope.touching = true;\n\n  if (scope.touchTimer != null) {\n    clearTimeout(scope.touchTimer);\n    scope.touchTimer = null;\n  }\n\n  scope.touchTimer = setTimeout(function () {\n    scope.touching = false;\n    scope.touchTimer = null;\n  }, 700);\n}\n\nfunction markTriggeredFromLocal(event) {\n  event && (event.qrIsFromLocal = true);\n}\n\nfunction isTriggeredFromLocal(event) {\n  return !!(event && event.qrIsFromLocal);\n} // Mark touch, which is useful in distinguish touch and\n// mouse event in upper applicatoin.\n\n\nfunction markTouch(event) {\n  event && (event.qrByTouch = true);\n} // ----------------------------\n// Native event handlers BEGIN\n// ----------------------------\n\n/**\r\n * Local 指的是 Canvas 内部的区域。\r\n * Local DOM Handlers\r\n * @this {DomEventProxy}\r\n */\n\n\nvar localDOMHandlers = {\n  mouseout: function mouseout(event) {\n    event = eventUtil.normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element !== this.dom) {\n      while (element && element.nodeType !== 9) {\n        // 忽略包含在root中的dom引起的mouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    } // 这里的 trigger() 方法是从 Eventful 里面的 mixin 进来的，调用这个 trigger() 方法的时候，是在 QuarkRender 内部，也就是 canvas 里面触发事件。\n    // 这里实现的目的是：把接受到的 HTML 事件转发到了 canvas 内部。\n\n\n    this.trigger('mouseout', event);\n  },\n  touchstart: function touchstart(event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = eventUtil.normalizeEvent(this.dom, event);\n    markTouch(event);\n    this._lastTouchMoment = new Date();\n    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,\n    // we simulate \"mouseover-->mousedown\" in touch device. So we trigger\n    // `mousemove` here (to trigger `mouseover` inside), and then trigger\n    // `mousedown`.\n\n    localDOMHandlers.mousemove.call(this, event);\n    localDOMHandlers.mousedown.call(this, event);\n  },\n  touchmove: function touchmove(event) {\n    event = eventUtil.normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    localDOMHandlers.mousemove.call(this, event);\n  },\n  touchend: function touchend(event) {\n    event = eventUtil.normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'end');\n    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      localDOMHandlers.click.call(this, event);\n    }\n  },\n  pointerdown: function pointerdown(event) {\n    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function pointermove(event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function pointerup(event) {\n    localDOMHandlers.mouseup.call(this, event);\n  },\n  pointerout: function pointerout(event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check localDOMHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mouseout.call(this, event);\n    }\n  }\n};\n/**\r\n * Othere DOM UI Event handlers for qr dom.\r\n * QuarkRender 内部的 DOM 结构默认支持以下7个事件。\r\n * @this {DomEventProxy}\r\n */\n\ndataUtil.each(['click', 'mousemove', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  localDOMHandlers[name] = function (event) {\n    event = eventUtil.normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n\n    if (name === 'mousemove' || name === 'mouseup') {\n      // Trigger `pagemousexxx` immediately with the same event object.\n      // See the reason described in the comment of `[Page Event]`.\n      this.trigger('page' + name, event);\n    }\n  };\n});\n/**\r\n * 这里用来监听外层 HTML 里面的 DOM 事件。监听这些事件的目的是为了方便实现拖拽功能，因为\r\n * 一旦鼠标离开 Canvas 的区域，就无法触发 Canvas 内部的 mousemove 和 mouseup 事件，这里直接\r\n * 监听外层 HTML 上的 mousemove 和 mouseup，绕开这种问题。\r\n * \r\n * Page DOM UI Event handlers for global page.\r\n * @this {DomEventProxy}\r\n */\n\nvar globalDOMHandlers = {\n  touchmove: function touchmove(event) {\n    markTouch(event);\n    globalDOMHandlers.mousemove.call(this, event);\n  },\n  touchend: function touchend(event) {\n    markTouch(event);\n    globalDOMHandlers.mouseup.call(this, event);\n  },\n  pointermove: function pointermove(event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      globalDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function pointerup(event) {\n    globalDOMHandlers.mouseup.call(this, event);\n  },\n  mousemove: function mousemove(event) {\n    event = eventUtil.normalizeEvent(this.dom, event, true);\n    this.trigger('pagemousemove', event);\n  },\n  mouseup: function mouseup(event) {\n    event = eventUtil.normalizeEvent(this.dom, event, true);\n    this.trigger('pagemouseup', event);\n  },\n  keyup: function keyup(event) {\n    event = eventUtil.normalizeEvent(this.dom, event, true);\n    this.trigger('pagekeyup', event);\n  },\n  keydown: function keydown(event) {\n    event = eventUtil.normalizeEvent(this.dom, event, true);\n    this.trigger('pagekeydown', event);\n  }\n}; // ----------------------------\n// Native event handlers END\n// ----------------------------\n\n/**\r\n * @private\r\n * @method mountDOMEventListeners\r\n * @param {DomEventProxy} domEventProxy\r\n * @param {DOMHandlerScope} domHandlerScope\r\n * @param {Object} nativeListenerNames {mouse: Array<String>, touch: Array<String>, poiner: Array<String>}\r\n * @param {Boolean} localOrGlobal `true`: target local, `false`: target global.\r\n */\n\nfunction mountDOMEventListeners(instance, scope, nativeListenerNames, localOrGlobal) {\n  var domHandlers = scope.domHandlers;\n  var domTarget = scope.domTarget;\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    dataUtil.each(nativeListenerNames.pointer, function (nativeEventName) {\n      mountSingle(nativeEventName, function (event) {\n        if (localOrGlobal || !isTriggeredFromLocal(event)) {\n          localOrGlobal && markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    }); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.eventUtil.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      dataUtil.each(nativeListenerNames.touch, function (nativeEventName) {\n        mountSingle(nativeEventName, function (event) {\n          if (localOrGlobal || !isTriggeredFromLocal(event)) {\n            localOrGlobal && markTriggeredFromLocal(event);\n            domHandlers[nativeEventName].call(instance, event);\n            setTouchTimer(scope);\n          }\n        });\n      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // eventUtil.addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    dataUtil.each(nativeListenerNames.mouse, function (nativeEventName) {\n      mountSingle(nativeEventName, function (event) {\n        event = eventUtil.getNativeEvent(event);\n\n        if (!scope.touching && (localOrGlobal || !isTriggeredFromLocal(event))) {\n          localOrGlobal && markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    }); //挂载键盘事件\n\n    dataUtil.each(nativeListenerNames.keyboard, function (nativeEventName) {\n      mountSingle(nativeEventName, function (event) {\n        if (localOrGlobal || !isTriggeredFromLocal(event)) {\n          localOrGlobal && markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    });\n  } //用来监听原生 DOM 事件\n\n\n  function mountSingle(nativeEventName, listener) {\n    scope.mounted[nativeEventName] = listener;\n    eventUtil.addEventListener(domTarget, eventNameFix(nativeEventName), listener);\n  }\n}\n/**\r\n * @private\r\n * @method unmountDOMEventListeners\r\n * @param {Object} scope \r\n */\n\n\nfunction unmountDOMEventListeners(scope) {\n  var mounted = scope.mounted;\n\n  for (var nativeEventName in mounted) {\n    if (mounted.hasOwnProperty(nativeEventName)) {\n      eventUtil.removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName]);\n    }\n  }\n\n  scope.mounted = {};\n}\n\nfunction DOMHandlerScope(domTarget, domHandlers) {\n  this.domTarget = domTarget;\n  this.domHandlers = domHandlers; // Key: eventName\n  // value: mounted handler funcitons.\n  // Used for unmount.\n\n  this.mounted = {};\n  this.touchTimer = null;\n  this.touching = false;\n}\n/**\r\n * @method constructor\r\n * @param dom 被代理的 DOM 节点\r\n */\n\n\nfunction DomEventProxy(dom) {\n  Eventful.call(this);\n  /**\r\n   * @property dom\r\n   */\n\n  this.dom = dom;\n  /**\r\n   * @private\r\n   * @property _localHandlerScope\r\n   */\n\n  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\n\n  if (pageEventSupported) {\n    /**\r\n     * @private\r\n     * @property _globalHandlerScope\r\n     */\n    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers); //注意，这里直接监听 document 上的事件\n  }\n  /**\r\n   * @private\r\n   * @property _pageEventEnabled\r\n   */\n\n\n  this._pageEventEnabled = false; //在构造 DomEventProxy 实例的时候，挂载 DOM 事件监听器。\n\n  mountDOMEventListeners(this, this._localHandlerScope, localNativeListenerNames, true);\n}\n/**\r\n * @private\r\n * @method dispose\r\n */\n\n\nDomEventProxy.prototype.dispose = function () {\n  unmountDOMEventListeners(this._localHandlerScope);\n\n  if (pageEventSupported) {\n    unmountDOMEventListeners(this._globalHandlerScope);\n  }\n};\n/**\r\n * @private\r\n * @method setCursor\r\n */\n\n\nDomEventProxy.prototype.setCursor = function (cursorStyle) {\n  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\n};\n/**\r\n * @private\r\n * @method togglePageEvent\r\n * The implementation of page event depends on listening to document.\r\n * So we should better only listen to that on needed, and remove the\r\n * listeners when do not need them to escape unexpected side-effect.\r\n * @param {Boolean} enableOrDisable `true`: enable page event. `false`: disable page event.\r\n */\n\n\nDomEventProxy.prototype.togglePageEvent = function (enableOrDisable) {\n  dataUtil.assert(enableOrDisable != null);\n\n  if (pageEventSupported && this._pageEventEnabled ^ enableOrDisable) {\n    this._pageEventEnabled = enableOrDisable;\n    var globalHandlerScope = this._globalHandlerScope;\n    enableOrDisable ? mountDOMEventListeners(this, globalHandlerScope, globalNativeListenerNames) : unmountDOMEventListeners(globalHandlerScope);\n  }\n}; //注意，DomEventProxy 也混入了 Eventful 里面提供的事件处理工具。\n\n\nclassUtil.mixin(DomEventProxy, Eventful);\nvar _default = DomEventProxy;\nmodule.exports = _default;","var dataUtil = require(\"./core/utils/data_structure_util\");\n\nexports.dataUtil = dataUtil;\n\nvar colorUtil = require(\"./core/utils/color_util\");\n\nexports.color = colorUtil;\n\nvar pathUtil = require(\"./core/utils/path_util\");\n\nexports.path = pathUtil;\n\nvar canvasUtil = require(\"./core/utils/canvas_util\");\n\nexports.canvasUtil = canvasUtil;\n\nvar matrix = require(\"./core/utils/matrix\");\n\nexports.matrix = matrix;\n\nvar vector = require(\"./core/utils/vector\");\n\nexports.vector = vector;\n\nvar _SVGParser = require(\"./svg/SVGParser\");\n\nvar parseSVG = _SVGParser.parseSVG;\nexports.parseSVG = _SVGParser.parseSVG;\n\nvar _Group = require(\"./graphic/Group\");\n\nexports.Group = _Group;\n\nvar _Path = require(\"./graphic/Path\");\n\nexports.Path = _Path;\n\nvar _Image = require(\"./graphic/Image\");\n\nexports.Image = _Image;\n\nvar _CompoundPath = require(\"./graphic/CompoundPath\");\n\nexports.CompoundPath = _CompoundPath;\n\nvar _Text = require(\"./graphic/Text\");\n\nexports.Text = _Text;\n\nvar _IncrementalDisplayable = require(\"./graphic/IncrementalDisplayable\");\n\nexports.IncrementalDisplayable = _IncrementalDisplayable;\n\nvar _Arc = require(\"./graphic/shape/Arc\");\n\nexports.Arc = _Arc;\n\nvar _BezierCurve = require(\"./graphic/shape/BezierCurve\");\n\nexports.BezierCurve = _BezierCurve;\n\nvar _Circle = require(\"./graphic/shape/Circle\");\n\nexports.Circle = _Circle;\n\nvar _Droplet = require(\"./graphic/shape/Droplet\");\n\nexports.Droplet = _Droplet;\n\nvar _Ellipse = require(\"./graphic/shape/Ellipse\");\n\nexports.Ellipse = _Ellipse;\n\nvar _Heart = require(\"./graphic/shape/Heart\");\n\nexports.Heart = _Heart;\n\nvar _Isogon = require(\"./graphic/shape/Isogon\");\n\nexports.Isogon = _Isogon;\n\nvar _Line = require(\"./graphic/shape/Line\");\n\nexports.Line = _Line;\n\nvar _Polygon = require(\"./graphic/shape/Polygon\");\n\nexports.Polygon = _Polygon;\n\nvar _Polyline = require(\"./graphic/shape/Polyline\");\n\nexports.Polyline = _Polyline;\n\nvar _Rect = require(\"./graphic/shape/Rect\");\n\nexports.Rect = _Rect;\n\nvar _Ring = require(\"./graphic/shape/Ring\");\n\nexports.Ring = _Ring;\n\nvar _Rose = require(\"./graphic/shape/Rose\");\n\nexports.Rose = _Rose;\n\nvar _Sector = require(\"./graphic/shape/Sector\");\n\nexports.Sector = _Sector;\n\nvar _Star = require(\"./graphic/shape/Star\");\n\nexports.Star = _Star;\n\nvar _Trochoid = require(\"./graphic/shape/Trochoid\");\n\nexports.Trochoid = _Trochoid;\n\nvar _LinearGradient = require(\"./graphic/gradient/LinearGradient\");\n\nexports.LinearGradient = _LinearGradient;\n\nvar _RadialGradient = require(\"./graphic/gradient/RadialGradient\");\n\nexports.RadialGradient = _RadialGradient;\n\nvar _Pattern = require(\"./graphic/Pattern\");\n\nexports.Pattern = _Pattern;\n\nvar _BoundingRect = require(\"./graphic/transform/BoundingRect\");\n\nexports.BoundingRect = _BoundingRect;","var Path = require(\"../../graphic/Path\");\n\nvar PathProxy = require(\"../../graphic/PathProxy\");\n\nvar transformPath = require(\"./transform_path\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathSqrt = _constants.mathSqrt;\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\nvar PI = _constants.PI;\nvar mathAcos = _constants.mathAcos;\n\n// command chars\n// var cc = [\n//     'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n//     'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n// ];\nvar vMag = function vMag(v) {\n  return mathSqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function vRatio(u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function vAngle(u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * mathAcos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nvar commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; // Consider case:\n// (1) delimiter can be comma or space, where continuous commas\n// or spaces should be seen as one comma.\n// (2) value can be like:\n// '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',\n// 'l-.5E1,54', '121-23-44-11' (no delimiter)\n\nvar numberReg = /-?([0-9]*\\.)?[0-9]+([eE]-?[0-9]+)?/g; // var valueSplitReg = /[\\s,]+/;\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return new PathProxy();\n  } // var data = data.replace(/-/g, ' -')\n  //     .replace(/  /g, ' ')\n  //     .replace(/ /g, ',')\n  //     .replace(/,,/g, ',');\n  // var n;\n  // create pipes so that we can split the data\n  // for (n = 0; n < cc.length; n++) {\n  //     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  // }\n  // data = data.replace(/-/g, ',-');\n  // create array\n  // var arr = cs.split('|');\n  // init context point\n\n\n  var cpx = 0;\n  var cpy = 0;\n  var subpathX = cpx;\n  var subpathY = cpy;\n  var prevCmd;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD; // commandReg.lastIndex = 0;\n  // var cmdResult;\n  // while ((cmdResult = commandReg.exec(data)) != null) {\n  //     var cmdStr = cmdResult[1];\n  //     var cmdContent = cmdResult[2];\n\n  var cmdList = data.match(commandReg);\n\n  for (var l = 0; l < cmdList.length; l++) {\n    var cmdText = cmdList[l];\n    var cmdStr = cmdText.charAt(0);\n    var cmd; // String#split is faster a little bit than String#replace or RegExp#exec.\n    // var p = cmdContent.split(valueSplitReg);\n    // var pLen = 0;\n    // for (var i = 0; i < p.length; i++) {\n    //     // '' and other invalid str => NaN\n    //     var val = parseFloat(p[i]);\n    //     !isNaN(val) && (p[pLen++] = val);\n    // }\n\n    var p = cmdText.match(numberReg) || [];\n    var pLen = p.length;\n\n    for (var i = 0; i < pLen; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    var off = 0;\n\n    while (off < pLen) {\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (cmdStr) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          subpathX = cpx;\n          subpathY = cpy;\n          cmdStr = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          subpathX = cpx;\n          subpathY = cpy;\n          cmdStr = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (cmdStr === 'z' || cmdStr === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd); // z may be in the middle of the path.\n\n      cpx = subpathX;\n      cpy = subpathY;\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\r\n * Create a Path object from path string data\r\n * http://www.w3.org/TR/SVG/paths.html#PathData\r\n * @param  {Object} opts Other options\r\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\r\n * Merge multiple paths\r\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.mergePath = mergePath;","var Displayable = require(\"./Displayable\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../core/utils/class_util\");\n\nvar PathProxy = require(\"./PathProxy\");\n\nvar pathContain = require(\"../core/contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar _constants = require(\"../graphic/constants\");\n\nvar mathMax = _constants.mathMax;\nvar mathAbs = _constants.mathAbs;\nvar mathSqrt = _constants.mathSqrt;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.Path \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Path =\n/*#__PURE__*/\nfunction (_Displayable) {\n  _inherits(Path, _Displayable);\n\n  /**\r\n   * @method constructor Path\r\n   * @param {Object} options\r\n   */\n  function Path(options) {\n    var _this;\n\n    _classCallCheck(this, Path);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, options));\n    /**\r\n     * @property {PathProxy}\r\n     * @readOnly\r\n     */\n\n    _this.path = null;\n    /**\r\n     * @property {String} type\r\n     */\n\n    _this.type = 'path';\n    /**\r\n     * @private\r\n     * @property __dirtyPath\r\n     */\n\n    _this.__dirtyPath = true;\n    /**\r\n     * @property {Number} strokeContainThreshold\r\n     */\n\n    _this.strokeContainThreshold = 5;\n    /**\r\n     * @property {Number} segmentIgnoreThreshold\r\n     * This item default to be false. But in map series in echarts,\r\n     * in order to improve performance, it should be set to true,\r\n     * so the shorty segment won't draw.\r\n     */\n\n    _this.segmentIgnoreThreshold = 0;\n    /**\r\n     * @property {Boolean} subPixelOptimize\r\n     * See `subPixelOptimize`.\r\n     */\n\n    _this.subPixelOptimize = false;\n    classUtil.copyOwnProperties(_assertThisInitialized(_this), _this.options, ['style', 'shape']);\n    return _this;\n  }\n  /**\r\n   * @method brush\r\n   * @param {Object} ctx \r\n   * @param {Element} prevEl \r\n   */\n\n\n  _createClass(Path, [{\n    key: \"brush\",\n    value: function brush(ctx, prevEl) {\n      var style = this.style;\n      var path = this.path || new PathProxy(true);\n      var hasStroke = style.hasStroke();\n      var hasFill = style.hasFill();\n      var fill = style.fill;\n      var stroke = style.stroke;\n      var hasFillGradient = hasFill && !!fill.colorStops;\n      var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n      var hasFillPattern = hasFill && !!fill.image;\n      var hasStrokePattern = hasStroke && !!stroke.image;\n      style.bind(ctx, this, prevEl);\n      this.setTransform(ctx);\n\n      if (this.__dirty) {\n        var rect; // Update gradient because bounding rect may changed\n\n        if (hasFillGradient) {\n          rect = rect || this.getBoundingRect();\n          this._fillGradient = style.getGradient(ctx, fill, rect);\n        }\n\n        if (hasStrokeGradient) {\n          rect = rect || this.getBoundingRect();\n          this._strokeGradient = style.getGradient(ctx, stroke, rect);\n        }\n      } // Use the gradient or pattern\n\n\n      if (hasFillGradient) {\n        // PENDING If may have affect the state\n        ctx.fillStyle = this._fillGradient;\n      } else if (hasFillPattern) {\n        ctx.fillStyle = Pattern.prototype.getCanvasPattern.call(fill, ctx);\n      }\n\n      if (hasStrokeGradient) {\n        ctx.strokeStyle = this._strokeGradient;\n      } else if (hasStrokePattern) {\n        ctx.strokeStyle = Pattern.prototype.getCanvasPattern.call(stroke, ctx);\n      }\n\n      var lineDash = style.lineDash;\n      var lineDashOffset = style.lineDashOffset;\n      var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n      var scale = this.getGlobalScale();\n      path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n      // Rebuild path in following 2 cases\n      // 1. Path is dirty\n      // 2. Path needs javascript implemented lineDash stroking.\n      //    In this case, lineDash information will not be saved in PathProxy\n\n      if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n        path.beginPath(ctx); // Setting line dash before build path\n\n        if (lineDash && !ctxLineDash) {\n          path.setLineDash(lineDash);\n          path.setLineDashOffset(lineDashOffset);\n        }\n\n        this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n        if (this.path) {\n          this.__dirtyPath = false;\n        }\n      } else {\n        // Replay path building\n        ctx.beginPath();\n        this.path.rebuildPath(ctx);\n      }\n\n      if (hasFill) {\n        if (style.fillOpacity != null) {\n          var originalGlobalAlpha = ctx.globalAlpha;\n          ctx.globalAlpha = style.fillOpacity * style.opacity;\n          path.fill(ctx);\n          ctx.globalAlpha = originalGlobalAlpha;\n        } else {\n          path.fill(ctx);\n        }\n      }\n\n      if (lineDash && ctxLineDash) {\n        ctx.setLineDash(lineDash);\n        ctx.lineDashOffset = lineDashOffset;\n      }\n\n      if (hasStroke) {\n        if (style.strokeOpacity != null) {\n          var _originalGlobalAlpha = ctx.globalAlpha;\n          ctx.globalAlpha = style.strokeOpacity * style.opacity;\n          path.stroke(ctx);\n          ctx.globalAlpha = _originalGlobalAlpha;\n        } else {\n          path.stroke(ctx);\n        }\n      }\n\n      if (lineDash && ctxLineDash) {\n        // PENDING\n        // Remove lineDash\n        ctx.setLineDash([]);\n      } // Draw rect text\n\n\n      if (style.text != null) {\n        // Only restore transform when needs draw text.\n        this.restoreTransform(ctx);\n        this.drawRectText(ctx, this.getBoundingRect());\n      }\n    }\n    /**\r\n     * @method buildPath\r\n     * \r\n     * Each subclass should provide its own implement for this method.\r\n     * When build path, some shape may decide if use moveTo to begin a new subpath or closePath, like in circle.\r\n     * \r\n     * 每个子类都需要为此方法提供自己的实现。\r\n     * 在构建路径时，某些形状需要根据情况决定使用 moveTo 来开始一段子路径，或者直接用 closePath 来封闭路径，比如圆形。\r\n     * \r\n     * @param {*} ctx \r\n     * @param {*} shapeCfg \r\n     * @param {*} inBundle \r\n     */\n\n  }, {\n    key: \"buildPath\",\n    value: function buildPath(ctx, shapeCfg, inBundle) {}\n    /**\r\n     * @method createPathProxy\r\n     */\n\n  }, {\n    key: \"createPathProxy\",\n    value: function createPathProxy() {\n      this.path = new PathProxy();\n    }\n    /**\r\n     * @protected\r\n     * @method getBoundingRect\r\n     */\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect() {\n      var rect = this._rect;\n      var style = this.style;\n      var needsUpdateRect = !rect;\n\n      if (needsUpdateRect) {\n        var path = this.path;\n\n        if (!path) {\n          // Create path on demand.\n          path = this.path = new PathProxy();\n        }\n\n        if (this.__dirtyPath) {\n          path.beginPath();\n          this.buildPath(path, this.shape, false);\n        }\n\n        rect = path.getBoundingRect();\n      }\n\n      this._rect = rect;\n\n      if (style.hasStroke()) {\n        // Needs update rect with stroke lineWidth when\n        // 1. Element changes scale or lineWidth\n        // 2. Shape is changed\n        var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n        if (this.__dirty || needsUpdateRect) {\n          rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n          var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n          var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n          if (!style.hasFill()) {\n            w = mathMax(w, this.strokeContainThreshold || 4);\n          } // Consider line width\n          // Line scale can't be 0;\n\n\n          if (lineScale > 1e-10) {\n            rectWithStroke.width += w / lineScale;\n            rectWithStroke.height += w / lineScale;\n            rectWithStroke.x -= w / lineScale / 2;\n            rectWithStroke.y -= w / lineScale / 2;\n          }\n        } // Return rect with stroke\n\n\n        return rectWithStroke;\n      }\n\n      return rect;\n    }\n    /**\r\n     * @method contain\r\n     * @param {*} x \r\n     * @param {*} y \r\n     */\n\n  }, {\n    key: \"contain\",\n    value: function contain(x, y) {\n      var localPos = this.transformCoordToLocal(x, y);\n      var rect = this.getBoundingRect();\n      var style = this.style;\n      x = localPos[0];\n      y = localPos[1];\n\n      if (rect.contain(x, y)) {\n        var pathData = this.path.data;\n\n        if (style.hasStroke()) {\n          var lineWidth = style.lineWidth;\n          var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n          if (lineScale > 1e-10) {\n            // Only add extra hover lineWidth when there are no fill\n            if (!style.hasFill()) {\n              lineWidth = mathMax(lineWidth, this.strokeContainThreshold);\n            }\n\n            if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n              return true;\n            }\n          }\n        }\n\n        if (style.hasFill()) {\n          return pathContain.contain(pathData, x, y);\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * @protected\r\n     * @method dirty\r\n     * @param  {Boolean} dirtyPath\r\n     */\n\n  }, {\n    key: \"dirty\",\n    value: function dirty(dirtyPath) {\n      if (dirtyPath == null) {\n        dirtyPath = true;\n      } // Only mark dirty, not mark clean\n\n\n      if (dirtyPath) {\n        this.__dirtyPath = dirtyPath;\n        this._rect = null;\n      }\n\n      this.__dirty = this.__dirtyText = true;\n      this.__qr && this.__qr.refresh(); // Used as a clipping path\n\n      if (this.__clipTarget) {\n        this.__clipTarget.dirty();\n      }\n    }\n    /**\r\n     * @method animateShape\r\n     * Alias for animate('shape')\r\n     * @param {Boolean} loop\r\n     */\n\n  }, {\n    key: \"animateShape\",\n    value: function animateShape(loop) {\n      return this.animate('shape', loop);\n    }\n    /**\r\n     * @method attrKV\r\n     * Overwrite attrKV\r\n     * @param {*} key \r\n     * @param {Object} value \r\n     */\n\n  }, {\n    key: \"attrKV\",\n    value: function attrKV(key, value) {\n      // FIXME\n      if (key === 'shape') {\n        this.setShape(value);\n        this.__dirtyPath = true;\n        this._rect = null;\n      } else {\n        Displayable.prototype.attrKV.call(this, key, value);\n      }\n    }\n    /**\r\n     * @method setShape\r\n     * @param {Object|String} key\r\n     * @param {Object} value\r\n     */\n\n  }, {\n    key: \"setShape\",\n    value: function setShape(key, value) {\n      // Path from string may not have shape\n      if (!this.shape) {\n        return this;\n      }\n\n      if (dataUtil.isObject(key)) {\n        classUtil.copyOwnProperties(this.shape, key);\n      } else {\n        this.shape[key] = value;\n      }\n\n      this.dirty(true);\n      return this;\n    }\n    /**\r\n     * @method getLineScale\r\n     */\n\n  }, {\n    key: \"getLineScale\",\n    value: function getLineScale() {\n      var m = this.transform; // Get the line scale.\n      // Determinant of `m` means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      return m && mathAbs(m[0] - 1) > 1e-10 && mathAbs(m[3] - 1) > 1e-10 ? mathSqrt(mathAbs(m[0] * m[3] - m[2] * m[1])) : 1;\n    }\n  }]);\n\n  return Path;\n}(Displayable);\n\nvar _default = Path;\nmodule.exports = _default;","var curve = require(\"../core/utils/curve_util\");\n\nvar vec2 = require(\"../core/utils/vector\");\n\nvar bbox = require(\"../core/utils/bbox_util\");\n\nvar BoundingRect = require(\"./transform/BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\nvar _constants = require(\"../graphic/constants\");\n\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\nvar mathSqrt = _constants.mathSqrt;\nvar mathAbs = _constants.mathAbs;\n// TODO: getTotalLength, getPointAtLength\n\n/**\r\n * @class qrenderer.core.PathProxy\r\n * \r\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\r\n * 可以用于 isInsidePath 判断以及获取boundingRect\r\n * \r\n * @author Yi Shen (http://www.github.com/pissang)\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  R: 7\n};\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar hasTypedArray = typeof Float32Array !== 'undefined';\n/**\r\n * @method constructor PathProxy\r\n */\n\nvar PathProxy = function PathProxy(notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\r\n     * Path data. Stored as flat array\r\n     * @property {Array<Object>}\r\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\r\n * 快速计算Path包围盒（并不是最小包围盒）\r\n * @return {Object}\r\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\r\n   * @readOnly\r\n   */\n  setScale: function setScale(sx, sy, segmentIgnoreThreshold) {\n    // Compat. Previously there is no segmentIgnoreThreshold.\n    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n    this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;\n    this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;\n  },\n  getContext: function getContext() {\n    return this._ctx;\n  },\n\n  /**\r\n   * @method beginPath\r\n   * @param  {CanvasRenderingContext2D} ctx\r\n   * @return {PathProxy}\r\n   */\n  beginPath: function beginPath(ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @method moveTo\r\n   * @param  {Number} x\r\n   * @param  {Number} y\r\n   * @return {PathProxy}\r\n   */\n  moveTo: function moveTo(x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\r\n   * @method lineTo\r\n   * @param  {Number} x\r\n   * @param  {Number} y\r\n   * @return {PathProxy}\r\n   */\n  lineTo: function lineTo(x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @method bezierCurveTo\r\n   * @param  {Number} x1\r\n   * @param  {Number} y1\r\n   * @param  {Number} x2\r\n   * @param  {Number} y2\r\n   * @param  {Number} x3\r\n   * @param  {Number} y3\r\n   * @return {PathProxy}\r\n   */\n  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\r\n   * @method quadraticCurveTo\r\n   * @param  {Number} x1\r\n   * @param  {Number} y1\r\n   * @param  {Number} x2\r\n   * @param  {Number} y2\r\n   * @return {PathProxy}\r\n   */\n  quadraticCurveTo: function quadraticCurveTo(x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\r\n   * @method arc\r\n   * @param  {Number} cx\r\n   * @param  {Number} cy\r\n   * @param  {Number} r\r\n   * @param  {Number} startAngle\r\n   * @param  {Number} endAngle\r\n   * @param  {boolean} anticlockwise\r\n   * @return {PathProxy}\r\n   */\n  arc: function arc(cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cy;\n    return this;\n  },\n  // TODO\n  arcTo: function arcTo(x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function rect(x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\r\n   * @method closePath\r\n   * @return {PathProxy}\r\n   */\n  closePath: function closePath() {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\r\n   * @method fill\r\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\r\n   * stroke 同样\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   * @return {PathProxy}\r\n   */\n  fill: function fill(ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\r\n   * @method stroke\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   * @return {PathProxy}\r\n   */\n  stroke: function stroke(ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\r\n   * @method setLineDash\r\n   * 必须在其它绘制命令前调用\r\n   * Must be invoked before all other path drawing methods\r\n   * @return {PathProxy}\r\n   */\n  setLineDash: function setLineDash(lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * @method setLineDashOffset\r\n   * 必须在其它绘制命令前调用\r\n   * Must be invoked before all other path drawing methods\r\n   * @return {PathProxy}\r\n   */\n  setLineDashOffset: function setLineDashOffset(offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\r\n   * @method len\r\n   * @return {boolean}\r\n   */\n  len: function len() {\n    return this._len;\n  },\n\n  /**\r\n   * @method setData\r\n   * 直接设置 Path 数据\r\n   */\n  setData: function setData(data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length === len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\r\n   * @method appendPath\r\n   * 添加子路径\r\n   * @param {PathProxy|Array.<PathProxy>} path\r\n   */\n  appendPath: function appendPath(path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\r\n   * @method addData\r\n   * 填充 Path 数据。\r\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\r\n   */\n  addData: function addData(cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function _expandData() {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\r\n   * If needs js implemented dashed line\r\n   * @return {boolean}\r\n   * @private\r\n   */\n  _needsDash: function _needsDash() {\n    return this._lineDash;\n  },\n  _dashedLineTo: function _dashedLineTo(x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function _dashedBezierTo(x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function _dashedQuadraticTo(x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\r\n   * 转成静态的 Float32Array 减少堆内存占用\r\n   * Convert dynamic array to static Float32Array\r\n   */\n  toStatic: function toStatic() {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\r\n   * @method getBoundingRect\r\n   * @return {BoundingRect}\r\n   */\n  getBoundingRect: function getBoundingRect() {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          i += 1;\n          var anticlockwise = 1 - data[i++];\n\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\r\n   * @method rebuildPath\r\n   * Rebuild path from current data\r\n   * Rebuild path will not consider javascript implemented line dash.\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   */\n  rebuildPath: function rebuildPath(ctx) {\n    var d = this.data;\n    var x0;\n    var y0;\n    var xi;\n    var yi;\n    var x;\n    var y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = mathAbs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;","var _vector = require(\"./vector\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathPow = _constants.mathPow;\nvar mathSqrt = _constants.mathSqrt;\nvar mathAcos = _constants.mathAcos;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\n\n/**\r\n * 曲线辅助模块\r\n * @author pissang(https://www.github.com/pissang)\r\n */\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // 临时变量\n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\r\n * 计算三次贝塞尔值\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} p3\r\n * @param  {Number} t\r\n * @return {Number}\r\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\r\n * 计算三次贝塞尔导数值\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} p3\r\n * @param  {Number} t\r\n * @return {Number}\r\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\r\n * 计算三次贝塞尔方程根，使用盛金公式\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} p3\r\n * @param  {Number} val\r\n * @param  {Array<Number>} roots\r\n * @return {Number} 有效根数目\r\n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = mathAcos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = mathCos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * mathSin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * mathSin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\r\n * 计算三次贝塞尔方程极限值的位置\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} p3\r\n * @param  {Array<Number>} extrema\r\n * @return {Number} 有效数目\r\n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\r\n * 细分三次贝塞尔曲线\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} p3\r\n * @param  {Number} t\r\n * @param  {Array<Number>} out\r\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\r\n * 投射点到三次贝塞尔曲线上，返回投射距离。\r\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\r\n * @param {Number} x0\r\n * @param {Number} y0\r\n * @param {Number} x1\r\n * @param {Number} y1\r\n * @param {Number} x2\r\n * @param {Number} y2\r\n * @param {Number} x3\r\n * @param {Number} y3\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Array<Number>} [out] 投射点\r\n * @return {Number}\r\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\r\n * 计算二次方贝塞尔值\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} t\r\n * @return {Number}\r\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\r\n * 计算二次方贝塞尔导数值\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} t\r\n * @return {Number}\r\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\r\n * 计算二次方贝塞尔方程根\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} t\r\n * @param  {Array<Number>} roots\r\n * @return {Number} 有效根数目\r\n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\r\n * 计算二次贝塞尔方程极限值\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @return {Number}\r\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\r\n * 细分二次贝塞尔曲线\r\n * @param  {Number} p0\r\n * @param  {Number} p1\r\n * @param  {Number} p2\r\n * @param  {Number} t\r\n * @param  {Array<Number>} out\r\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\r\n * 投射点到二次贝塞尔曲线上，返回投射距离。\r\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\r\n * @param {Number} x0\r\n * @param {Number} y0\r\n * @param {Number} x1\r\n * @param {Number} y1\r\n * @param {Number} x2\r\n * @param {Number} y2\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Array<Number>} out 投射点\r\n * @return {Number}\r\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;","var vec2 = require(\"./vector\");\n\nvar curve = require(\"./curve_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\nvar mathAsin = _constants.mathAsin;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\nvar mathPow = _constants.mathPow;\nvar mathSqrt = _constants.mathSqrt;\nvar PI = _constants.PI;\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\nvar mathAbs = _constants.mathAbs;\n\n/**\r\n * @author Yi Shen(https://github.com/pissang)\r\n */\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\r\n * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\r\n * @param {Array<Object>} points 顶点数组\r\n * @param {Number} min\r\n * @param {Number} max\r\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\r\n * @param {Number} x0\r\n * @param {Number} y0\r\n * @param {Number} x1\r\n * @param {Number} y1\r\n * @param {Array<Number>} min\r\n * @param {Array<Number>} max\r\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\r\n * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\r\n * @param {Number} x0\r\n * @param {Number} y0\r\n * @param {Number} x1\r\n * @param {Number} y1\r\n * @param {Number} x2\r\n * @param {Number} y2\r\n * @param {Number} x3\r\n * @param {Number} y3\r\n * @param {Array<Number>} min\r\n * @param {Array<Number>} max\r\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\r\n * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\r\n * @param {Number} x0\r\n * @param {Number} y0\r\n * @param {Number} x1\r\n * @param {Number} y1\r\n * @param {Number} x2\r\n * @param {Number} y2\r\n * @param {Array<Number>} min\r\n * @param {Array<Number>} max\r\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\r\n * 从圆弧中计算出最小包围盒，写入`min`和`max`中\r\n * @method\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} rx\r\n * @param {Number} ry\r\n * @param {Number} startAngle\r\n * @param {Number} endAngle\r\n * @param {Number} anticlockwise\r\n * @param {Array<Number>} min\r\n * @param {Array<Number>} max\r\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = mathAbs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -PI : PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;","var PathProxy = require(\"../../graphic/PathProxy\");\n\nvar line = require(\"./line\");\n\nvar cubic = require(\"./cubic\");\n\nvar quadratic = require(\"./quadratic\");\n\nvar arc = require(\"./arc\");\n\nvar _radian_util = require(\"./radian_util\");\n\nvar normalizeRadian = _radian_util.normalizeRadian;\n\nvar curve = require(\"../utils/curve_util\");\n\nvar windingLine = require(\"./winding_line\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\nvar mathAsin = _constants.mathAsin;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\nvar mathPow = _constants.mathPow;\nvar mathSqrt = _constants.mathSqrt;\nvar PI = _constants.PI;\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\nvar mathAtan2 = _constants.mathAtan2;\nvar mathAbs = _constants.mathAbs;\nvar CMD = PathProxy.CMD;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return mathAbs(a - b) < EPSILON;\n} // 临时数组\n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_;\n    var y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema === 2) {\n        // 分成三段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // 分成两段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var _unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\n      var _x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (_x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? _unit : -_unit;\n    }\n  }\n} // TODO\n// Arc 旋转\n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = mathSqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = mathAbs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var _tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(_tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = mathAtan2(y, x_);\n\n      var _dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > PI / 2 && angle < PI * 1.5) {\n          _dir = -_dir;\n        }\n\n        w += _dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } // 如果被任何一个 subpath 包含\n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i === 1) {\n      // 如果第一个命令是 L, C, Q\n      // 则 previous point 同绘制命令的第一个 point\n      //\n      // 第一个命令为 Arc 的情况下会在后面特殊处理\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var x1 = void 0;\n    var y1 = void 0;\n    var width = void 0;\n    var height = void 0;\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        i += 1;\n        var anticlockwise = 1 - data[i++];\n        x1 = mathCos(theta) * rx + cx;\n        y1 = mathSin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // qr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = mathCos(theta + dTheta) * rx + cx;\n        yi = mathSin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        width = data[i++];\n        height = data[i++];\n        x1 = x0 + width;\n        y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;","/**\r\n * 线段包含判断\r\n * @param  {Number}  x0\r\n * @param  {Number}  y0\r\n * @param  {Number}  x1\r\n * @param  {Number}  y1\r\n * @param  {Number}  lineWidth\r\n * @param  {Number}  x\r\n * @param  {Number}  y\r\n * @return {boolean}\r\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;","var curve = require(\"../utils/curve_util\");\n\n/**\r\n * 三次贝塞尔曲线描边包含判断\r\n * @param  {Number}  x0\r\n * @param  {Number}  y0\r\n * @param  {Number}  x1\r\n * @param  {Number}  y1\r\n * @param  {Number}  x2\r\n * @param  {Number}  y2\r\n * @param  {Number}  x3\r\n * @param  {Number}  y3\r\n * @param  {Number}  lineWidth\r\n * @param  {Number}  x\r\n * @param  {Number}  y\r\n * @return {boolean}\r\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;","var _curve_util = require(\"../utils/curve_util\");\n\nvar quadraticProjectPoint = _curve_util.quadraticProjectPoint;\n\n/**\r\n * 二次贝塞尔曲线描边包含判断\r\n * @param  {Number}  x0\r\n * @param  {Number}  y0\r\n * @param  {Number}  x1\r\n * @param  {Number}  y1\r\n * @param  {Number}  x2\r\n * @param  {Number}  y2\r\n * @param  {Number}  lineWidth\r\n * @param  {Number}  x\r\n * @param  {Number}  y\r\n * @return {boolean}\r\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;","var _radian_util = require(\"./radian_util\");\n\nvar normalizeRadian = _radian_util.normalizeRadian;\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\nvar mathSqrt = _constants.mathSqrt;\nvar mathAbs = _constants.mathAbs;\nvar mathAtan2 = _constants.mathAtan2;\n\n/**\r\n * 圆弧描边包含判断\r\n * @param  {Number}  cx\r\n * @param  {Number}  cy\r\n * @param  {Number}  r\r\n * @param  {Number}  startAngle\r\n * @param  {Number}  endAngle\r\n * @param  {boolean}  anticlockwise\r\n * @param  {Number} lineWidth\r\n * @param  {Number}  x\r\n * @param  {Number}  y\r\n * @return {Boolean}\r\n */\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = mathSqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (mathAbs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = mathAtan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;","var _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;","function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as \"contain\".\n\n  return x_ === x ? Infinity : x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;","var PathProxy = require(\"../../graphic/PathProxy\");\n\nvar _vector = require(\"./vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathSqrt = _constants.mathSqrt;\nvar mathAtan2 = _constants.mathAtan2;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;","var Group = require(\"../graphic/Group\");\n\nvar QImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Circle = require(\"../graphic/shape/Circle\");\n\nvar Rect = require(\"../graphic/shape/Rect\");\n\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\n\nvar Line = require(\"../graphic/shape/Line\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar Polygon = require(\"../graphic/shape/Polygon\");\n\nvar Polyline = require(\"../graphic/shape/Polyline\");\n\nvar LinearGradient = require(\"../graphic/gradient/LinearGradient\");\n\nvar Style = require(\"../graphic/Style\");\n\nvar matrix = require(\"../core/utils/matrix\");\n\nvar _path_util = require(\"../core/utils/path_util\");\n\nvar createFromString = _path_util.createFromString;\n\nvar _data_structure_util = require(\"../core/utils/data_structure_util\");\n\nvar isString = _data_structure_util.isString;\nvar extend = _data_structure_util.extend;\nvar trim = _data_structure_util.trim;\nvar each = _data_structure_util.each;\n\nvar _class_util = require(\"../core/utils/class_util\");\n\nvar defaults = _class_util.defaults;\n\nvar _constants = require(\"../graphic/constants\");\n\nvar mathMin = _constants.mathMin;\n// Most of the values can be separated by comma and/or white space.\nvar DILIMITER_REG = /[\\s,]+/;\n/**\r\n * For big svg string, this method might be time consuming.\r\n * //TODO:try to move this into webworker.\r\n * @param {String} svg xml string\r\n * @return {Object} xml root.\r\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n/**\r\n * @class qrenderer.svg.SVGParser\r\n * \r\n * This is a tool class for parsing SVG xml string to standard shape classes.\r\n * \r\n * 这是一个工具类，用来把 SVG 格式的 xml 解析成 graphic 包中定义的标准类。\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype = {\n  constructor: SVGParser,\n  parse: function parse(xml, opt) {\n    opt = opt || {};\n    var svg = parseXML(xml);\n\n    if (!svg) {\n      throw new Error('Illegal svg');\n    }\n\n    var root = new Group();\n    this._root = root; // parse view port\n\n    var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n    // TODO: Other percent value not supported yet.\n\n    var width = parseFloat(svg.getAttribute('width') || opt.width);\n    var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n    isNaN(width) && (width = null);\n    isNaN(height) && (height = null); // Apply inline style on svg element.\n\n    parseAttributes(svg, root, null, true);\n    var child = svg.firstChild;\n\n    while (child) {\n      this._parseNode(child, root);\n\n      child = child.nextSibling;\n    }\n\n    var viewBoxRect;\n    var viewBoxTransform;\n\n    if (viewBox) {\n      var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n      if (viewBoxArr.length >= 4) {\n        viewBoxRect = {\n          x: parseFloat(viewBoxArr[0] || 0),\n          y: parseFloat(viewBoxArr[1] || 0),\n          width: parseFloat(viewBoxArr[2]),\n          height: parseFloat(viewBoxArr[3])\n        };\n      }\n    }\n\n    if (viewBoxRect && width != null && height != null) {\n      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n      if (!opt.ignoreViewBox) {\n        // If set transform on the output group, it probably bring trouble when\n        // some users only intend to show the clipped content inside the viewBox,\n        // but not intend to transform the output group. So we keep the output\n        // group no transform. If the user intend to use the viewBox as a\n        // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n        // manually according to the viewBox info in the output of this method.\n        var elRoot = root;\n        root = new Group();\n        root.add(elRoot);\n        elRoot.scale = viewBoxTransform.scale.slice();\n        elRoot.position = viewBoxTransform.position.slice();\n      }\n    } // Some shapes might be overflow the viewport, which should be\n    // clipped despite whether the viewBox is used, as the SVG does.\n\n\n    if (!opt.ignoreRootClip && width != null && height != null) {\n      root.setClipPath(new Rect({\n        shape: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      }));\n    } // Set width/height on group just for output the viewport size.\n\n\n    return {\n      root: root,\n      width: width,\n      height: height,\n      viewBoxRect: viewBoxRect,\n      viewBoxTransform: viewBoxTransform\n    };\n  },\n  _parseNode: function _parseNode(xmlNode, parentGroup) {\n    var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n    // support <style>...</style> in svg, where nodeName is 'style',\n    // CSS classes is defined globally wherever the style tags are declared.\n\n    if (nodeName === 'defs') {\n      // define flag\n      this._isDefine = true;\n    } else if (nodeName === 'text') {\n      this._isText = true;\n    }\n\n    var el;\n\n    if (this._isDefine) {\n      var parser = defineParsers[nodeName];\n\n      if (parser) {\n        var def = parser.call(this, xmlNode);\n        var id = xmlNode.getAttribute('id');\n\n        if (id) {\n          this._defs[id] = def;\n        }\n      }\n    } else {\n      var _parser = nodeParsers[nodeName];\n\n      if (_parser) {\n        el = _parser.call(this, xmlNode, parentGroup);\n        parentGroup.add(el);\n      }\n    }\n\n    var child = xmlNode.firstChild;\n\n    while (child) {\n      if (child.nodeType === 1) {\n        this._parseNode(child, el);\n      } // Is text\n\n\n      if (child.nodeType === 3 && this._isText) {\n        this._parseText(child, el);\n      }\n\n      child = child.nextSibling;\n    } // Quit define\n\n\n    if (nodeName === 'defs') {\n      this._isDefine = false;\n    } else if (nodeName === 'text') {\n      this._isText = false;\n    }\n  },\n  _parseText: function _parseText(xmlNode, parentGroup) {\n    if (xmlNode.nodeType === 1) {\n      var dx = xmlNode.getAttribute('dx') || 0;\n      var dy = xmlNode.getAttribute('dy') || 0;\n      this._textX += parseFloat(dx);\n      this._textY += parseFloat(dy);\n    }\n\n    var text = new Text({\n      style: {\n        text: xmlNode.textContent,\n        transformText: true\n      },\n      position: [this._textX || 0, this._textY || 0]\n    });\n    inheritStyle(parentGroup, text);\n    parseAttributes(xmlNode, text, this._defs);\n    var fontSize = text.style.fontSize;\n\n    if (fontSize && fontSize < 9) {\n      // PENDING\n      text.style.fontSize = 9;\n      text.scale = text.scale || [1, 1];\n      text.scale[0] *= fontSize / 9;\n      text.scale[1] *= fontSize / 9;\n    }\n\n    var rect = text.getBoundingRect();\n    this._textX += rect.width;\n    parentGroup.add(text);\n    return text;\n  }\n};\nvar nodeParsers = {\n  'g': function g(xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function rect(xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function circle(xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function line(xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function ellipse(xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function polygon(xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function polyline(xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function image(xmlNode, parentGroup) {\n    var img = new QImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function text(xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function tspan(xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function path(xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function lineargradient(xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function radialgradient(xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var qrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(qrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            qrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  qrStyle.fill != null && elStyle.set(elFillProp, getPaint(qrStyle.fill, defs));\n  qrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(qrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    qrStyle[propName] != null && elStyle.set(elPropName, parseFloat(qrStyle[propName]));\n  });\n\n  if (!qrStyle.textBaseline || qrStyle.textBaseline === 'auto') {\n    qrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (qrStyle.textBaseline === 'alphabetic') {\n    qrStyle.textBaseline = 'bottom';\n  }\n\n  if (qrStyle.textAlign === 'start') {\n    qrStyle.textAlign = 'left';\n  }\n\n  if (qrStyle.textAlign === 'end') {\n    qrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    qrStyle[propName] != null && elStyle.set(propName, qrStyle[propName]);\n  });\n\n  if (qrStyle.lineDash) {\n    el.style.lineDash = trim(qrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = qrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\r\n * @param {Array<Number>} viewBoxRect\r\n * @param {Number} width\r\n * @param {Number} height\r\n * @return {Object} {scale, position}\r\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = mathMin(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\r\n * @static\r\n * @method parseSVG\r\n * \r\n * Parse SVG DOM to QuarkRenderer specific interfaces.\r\n * \r\n * 把 SVG DOM 标签解析成 QuarkRenderer 所定义的接口。\r\n * \r\n * @param {String|XMLElement} xml\r\n * @param {Object} [opt]\r\n * @param {Number} [opt.width] Default width if svg width not specified or is a percent value.\r\n * @param {Number} [opt.height] Default height if svg height not specified or is a percent value.\r\n * @param {Boolean} [opt.ignoreViewBox]\r\n * @param {Boolean} [opt.ignoreRootClip]\r\n * @return {Object} result:\r\n * {\r\n *     root: Group, The root of the the result tree of qrenderer shapes,\r\n *     width: number, the viewport width of the SVG,\r\n *     height: number, the viewport height of the SVG,\r\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\r\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\r\n * }\r\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;","var Displayable = require(\"./Displayable\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar textContain = require(\"../core/contain/text\");\n\nvar textUtil = require(\"./utils/text_util\");\n\nvar _constants = require(\"./constants\");\n\nvar ContextCachedBy = _constants.ContextCachedBy;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.Text\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar Text =\n/*#__PURE__*/\nfunction (_Displayable) {\n  _inherits(Text, _Displayable);\n\n  /**\r\n   * @method constructor Text\r\n   * @param {Object} opts \r\n   */\n  function Text(opts) {\n    var _this;\n\n    _classCallCheck(this, Text);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, opts));\n    /**\r\n     * @property {String} type\r\n     */\n\n    _this.type = 'text';\n    return _this;\n  }\n\n  _createClass(Text, [{\n    key: \"brush\",\n    value: function brush(ctx, prevEl) {\n      var style = this.style; // Optimize, avoid normalize every time.\n\n      this.__dirty && textUtil.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n      style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n      var text = style.text; // Convert to string\n\n      text != null && (text += ''); // Do not apply style.bind in Text node. Because the real bind job\n      // is in textUtil.renderText, and performance of text render should\n      // be considered.\n      // style.bind(ctx, this, prevEl);\n\n      if (!textUtil.needDrawText(text, style)) {\n        // The current el.style is not applied\n        // and should not be used as cache.\n        ctx.__attrCachedBy = ContextCachedBy.NONE;\n        return;\n      }\n\n      this.setTransform(ctx);\n      textUtil.renderText(this, ctx, text, style, null, prevEl);\n      this.restoreTransform(ctx);\n    }\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect() {\n      var style = this.style; // Optimize, avoid normalize every time.\n\n      this.__dirty && textUtil.normalizeTextStyle(style, true);\n\n      if (!this._rect) {\n        var text = style.text;\n        text != null ? text += '' : text = '';\n        var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);\n        rect.x += style.x || 0;\n        rect.y += style.y || 0;\n\n        if (textUtil.getStroke(style.textStroke, style.textStrokeWidth)) {\n          var w = style.textStrokeWidth;\n          rect.x -= w / 2;\n          rect.y -= w / 2;\n          rect.width += w;\n          rect.height += w;\n        }\n\n        this._rect = rect;\n      }\n\n      return this._rect;\n    }\n  }]);\n\n  return Text;\n}(Displayable);\n\nmodule.exports = Text;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Circle \r\n * 圆形\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  }\n};\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Circle, _Path);\n\n  /**\r\n   * @method constructor Rect\r\n   * @param {Object} options \r\n   */\n  function Circle(options) {\n    _classCallCheck(this, Circle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Circle, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape, inBundle) {\n      // Better stroking in ShapeBundle\n      // Always do it may have performence issue ( fill may be 2x more cost)\n      if (inBundle) {\n        ctx.moveTo(shape.cx + shape.r, shape.cy);\n      } // else {\n      //     if (ctx.allocate && !ctx.data.length) {\n      //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n      //     }\n      // }\n      // Better stroking in ShapeBundle\n      // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n      ctx.arc(shape.cx, shape.cy, shape.r, 0, PI2, true);\n    }\n  }]);\n\n  return Circle;\n}(Path);\n\nmodule.exports = Circle;","var Path = require(\"../Path\");\n\nvar roundRectHelper = require(\"../utils/round_rect\");\n\nvar _sub_pixel_optimize = require(\"../utils/sub_pixel_optimize\");\n\nvar subPixelOptimizeRect = _sub_pixel_optimize.subPixelOptimizeRect;\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Rect \r\n * 矩形\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n// Avoid create repeatly.\nvar subPixelOptimizeOutputShape = {};\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'rect',\n  shape: {\n    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n    // r缩写为1         相当于 [1, 1, 1, 1]\n    // r缩写为[1]       相当于 [1, 1, 1, 1]\n    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }\n};\n\nvar Rect =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Rect, _Path);\n\n  /**\r\n   * @method constructor Rect\r\n   * @param {Object} options \r\n   */\n  function Rect(options) {\n    _classCallCheck(this, Rect);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Rect, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (this.subPixelOptimize) {\n        subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);\n        x = subPixelOptimizeOutputShape.x;\n        y = subPixelOptimizeOutputShape.y;\n        width = subPixelOptimizeOutputShape.width;\n        height = subPixelOptimizeOutputShape.height;\n        subPixelOptimizeOutputShape.r = shape.r;\n        shape = subPixelOptimizeOutputShape;\n      } else {\n        x = shape.x;\n        y = shape.y;\n        width = shape.width;\n        height = shape.height;\n      }\n\n      if (!shape.r) {\n        ctx.rect(x, y, width, height);\n      } else {\n        roundRectHelper.buildPath(ctx, shape);\n      }\n\n      ctx.closePath();\n      return;\n    }\n  }]);\n\n  return Rect;\n}(Path);\n\nmodule.exports = Rect;","var _constants = require(\"../../graphic/constants\");\n\nvar mathRound = _constants.mathRound;\nvar mathMax = _constants.mathMax;\n\n/**\r\n * Sub-pixel optimize for canvas rendering, prevent from blur\r\n * when rendering a thin vertical/horizontal line.\r\n */\n\n/**\r\n * Sub pixel optimize line for canvas\r\n *\r\n * @param {Object} outputShape The modification will be performed on `outputShape`.\r\n *                 `outputShape` and `inputShape` can be the same object.\r\n *                 `outputShape` object can be used repeatly, because all of\r\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\r\n * @param {Object} [inputShape]\r\n * @param {Number} [inputShape.x1]\r\n * @param {Number} [inputShape.y1]\r\n * @param {Number} [inputShape.x2]\r\n * @param {Number} [inputShape.y2]\r\n * @param {Object} [style]\r\n * @param {Number} [style.lineWidth]\r\n */\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n\n  if (mathRound(x1 * 2) === mathRound(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  } else {\n    outputShape.x1 = x1;\n    outputShape.x2 = x2;\n  }\n\n  if (mathRound(y1 * 2) === mathRound(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  } else {\n    outputShape.y1 = y1;\n    outputShape.y2 = y2;\n  }\n}\n/**\r\n * Sub pixel optimize rect for canvas\r\n *\r\n * @param {Object} outputShape The modification will be performed on `outputShape`.\r\n *                 `outputShape` and `inputShape` can be the same object.\r\n *                 `outputShape` object can be used repeatly, because all of\r\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\r\n * @param {Object} [inputShape]\r\n * @param {Number} [inputShape.x]\r\n * @param {Number} [inputShape.y]\r\n * @param {Number} [inputShape.width]\r\n * @param {Number} [inputShape.height]\r\n * @param {Object} [style]\r\n * @param {Number} [style.lineWidth]\r\n */\n\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = mathMax(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = mathMax(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\r\n * Sub pixel optimize for canvas\r\n *\r\n * @param {Number} position Coordinate, such as x, y\r\n * @param {Number} lineWidth Should be nonnegative integer.\r\n * @param {boolean=} positiveOrNegative Default false (negative).\r\n * @return {Number} Optimized position.\r\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = mathRound(position * 2);\n  return (doubledPosition + mathRound(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Ellipse \r\n * 椭圆形状\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'ellipse',\n  shape: {\n    cx: 0,\n    cy: 0,\n    rx: 0,\n    ry: 0\n  }\n};\n\nvar Droplet =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Droplet, _Path);\n\n  /**\r\n   * @method constructor Droplet\r\n   * @param {Object} options \r\n   */\n  function Droplet(options) {\n    _classCallCheck(this, Droplet);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Droplet).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Droplet, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var k = 0.5522848;\n      var x = shape.cx;\n      var y = shape.cy;\n      var a = shape.rx;\n      var b = shape.ry;\n      var ox = a * k; // 水平控制点偏移量\n\n      var oy = b * k; // 垂直控制点偏移量\n      // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\n\n      ctx.moveTo(x - a, y);\n      ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\n      ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\n      ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\n      ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\n      ctx.closePath();\n    }\n  }]);\n\n  return Droplet;\n}(Path);\n\nmodule.exports = Droplet;","var Path = require(\"../Path\");\n\nvar _sub_pixel_optimize = require(\"../utils/sub_pixel_optimize\");\n\nvar subPixelOptimizeLine = _sub_pixel_optimize.subPixelOptimizeLine;\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Line \r\n * 直线\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n//TODO:Avoid create repeatly.\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  }\n};\n\nvar Line =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Line, _Path);\n\n  /**\r\n   * @method constructor Line\r\n   * @param {Object} options \r\n   */\n  function Line(options) {\n    _classCallCheck(this, Line);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Line, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n\n      if (this.subPixelOptimize) {\n        var subPixelOptimizeOutputShape = {};\n        subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);\n        x1 = subPixelOptimizeOutputShape.x1;\n        y1 = subPixelOptimizeOutputShape.y1;\n        x2 = subPixelOptimizeOutputShape.x2;\n        y2 = subPixelOptimizeOutputShape.y2;\n      } else {\n        x1 = shape.x1;\n        y1 = shape.y1;\n        x2 = shape.x2;\n        y2 = shape.y2;\n      }\n\n      var percent = shape.percent;\n\n      if (percent === 0) {\n        return;\n      }\n\n      ctx.moveTo(x1, y1);\n\n      if (percent < 1) {\n        x2 = x1 * (1 - percent) + x2 * percent;\n        y2 = y1 * (1 - percent) + y2 * percent;\n      }\n\n      ctx.lineTo(x2, y2);\n    }\n    /**\r\n     * Get point at percent\r\n     * @param  {Number} percent\r\n     * @return {Array<Number>}\r\n     */\n\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(p) {\n      var shape = this.shape;\n      return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n    }\n  }]);\n\n  return Line;\n}(Path);\n\nmodule.exports = Line;","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../utils/poly\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Polygon \r\n * 多边形\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  }\n};\n\nvar Polygon =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Polygon, _Path);\n\n  /**\r\n   * @method constructor Polygon\r\n   * @param {Object} options \r\n   */\n  function Polygon(options) {\n    _classCallCheck(this, Polygon);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Polygon, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      polyHelper.buildPath(ctx, shape, true);\n    }\n  }]);\n\n  return Polygon;\n}(Path);\n\nmodule.exports = Polygon;","var smoothSpline = require(\"./smooth_spline\");\n\nvar smoothBezier = require(\"./smooth_bezier\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;","var _vector = require(\"../../core/utils/vector\");\n\nvar v2Distance = _vector.distance;\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathFloor = _constants.mathFloor;\n\n/**\r\n * Catmull-Rom spline 插值折线\r\n * @author pissang (https://www.github.com/pissang)\r\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         errorrik (errorrik@gmail.com)\r\n */\n\n/**\r\n * @inner\r\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\r\n * @alias smoothSpline\r\n * @param {Array} points 线段顶点数组\r\n * @param {boolean} isLoop\r\n * @return {Array}\r\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = mathFloor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;","var _vector = require(\"../../core/utils/vector\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\r\n * 贝塞尔平滑曲线\r\n * @author pissang (https://www.github.com/pissang)\r\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\r\n *         errorrik (errorrik@gmail.com)\r\n */\n\n/**\r\n * 贝塞尔平滑曲线\r\n * @alias smoothBezier\r\n * @param {Array} points 线段顶点数组\r\n * @param {Number} smooth 平滑等级, 0-1\r\n * @param {boolean} isLoop\r\n * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\r\n *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\r\n *                           整个折线的包围盒做一个并集用来约束控制点。\r\n * @param {Array} 计算出来的控制点数组\r\n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // 与指定的包围盒做并集\n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../utils/poly\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Polyline \r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  }\n};\n\nvar Polyline =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Polyline, _Path);\n\n  /**\r\n   * @method constructor Polyline\r\n   * @param {Object} options \r\n   */\n  function Polyline(options) {\n    _classCallCheck(this, Polyline);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Polyline, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      polyHelper.buildPath(ctx, shape, false);\n    }\n  }]);\n\n  return Polyline;\n}(Path);\n\nmodule.exports = Polyline;","var classUtil = require(\"../../core/utils/class_util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\r\n * @class qrenderer.graphic.gradient.LinearGradient \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n\n/**\r\n * @method constructor LinearGradient\r\n * @param {Number} [x=0]\r\n * @param {Number} [y=0]\r\n * @param {Number} [x2=1]\r\n * @param {Number} [y2=0]\r\n * @param {Array<Object>} colorStops\r\n * @param {boolean} [globalCoord=false]\r\n */\nvar LinearGradient = function LinearGradient(x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nclassUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;","/**\r\n * @class qrenderer.graphic.gradient.Gradient \r\n * 渐变\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n\n/**\r\n * @method constructor Gradient\r\n * @param {Array<Object>} colorStops\r\n */\nvar Gradient = function Gradient(colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function addColorStop(offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;","var Path = require(\"./Path\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.CompoundPath \r\n * \r\n * CompoundPath to improve performance.\r\n * \r\n * 复合路径，用来提升性能。\r\n * \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'compound',\n  shape: {\n    paths: null\n  }\n};\n\nvar CompoundPath =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(CompoundPath, _Path);\n\n  /**\r\n   * @method constructor CompoundPath\r\n   * @param {Object} opts \r\n   */\n  function CompoundPath(opts) {\n    _classCallCheck(this, CompoundPath);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CompoundPath).call(this, opts, defaultConfig));\n  }\n  /**\r\n   * @private\r\n   * @method _updatePathDirty\r\n   */\n\n\n  _createClass(CompoundPath, [{\n    key: \"_updatePathDirty\",\n    value: function _updatePathDirty() {\n      var dirtyPath = this.__dirtyPath;\n      var paths = this.shape.paths;\n\n      for (var i = 0; i < paths.length; i++) {\n        // Mark as dirty if any subpath is dirty\n        dirtyPath = dirtyPath || paths[i].__dirtyPath;\n      }\n\n      this.__dirtyPath = dirtyPath;\n      this.__dirty = this.__dirty || dirtyPath;\n    }\n    /**\r\n     * @private\r\n     * @method beforeBrush\r\n     */\n\n  }, {\n    key: \"beforeBrush\",\n    value: function beforeBrush() {\n      this._updatePathDirty();\n\n      var paths = this.shape.paths || [];\n      var scale = this.getGlobalScale(); // Update path scale\n\n      for (var i = 0; i < paths.length; i++) {\n        if (!paths[i].path) {\n          paths[i].createPathProxy();\n        }\n\n        paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);\n      }\n    }\n    /**\r\n     * @method buildPath\r\n     * 绘制元素路径\r\n     * @param {Object} ctx \r\n     * @param {String} shape \r\n     */\n\n  }, {\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var paths = shape.paths || [];\n\n      for (var i = 0; i < paths.length; i++) {\n        paths[i].buildPath(ctx, paths[i].shape, true);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method afterBrush\r\n     */\n\n  }, {\n    key: \"afterBrush\",\n    value: function afterBrush() {\n      var paths = this.shape.paths || [];\n\n      for (var i = 0; i < paths.length; i++) {\n        paths[i].__dirtyPath = false;\n      }\n    }\n    /**\r\n     * @private\r\n     * @method getBoundingRect\r\n     */\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect() {\n      this._updatePathDirty();\n\n      return Path.prototype.getBoundingRect.call(this);\n    }\n  }]);\n\n  return CompoundPath;\n}(Path);\n\nmodule.exports = CompoundPath;","var classUtil = require(\"../core/utils/class_util\");\n\nvar Displayble = require(\"./Displayable\");\n\nvar BoundingRect = require(\"./transform/BoundingRect\");\n\n/**\r\n * @class qrenderer.graphic.IncrementalDisplayble \r\n * Displayable for incremental rendering. It will be rendered in a separate layer\r\n * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`\r\n * addDisplayables will render the added displayables incremetally.\r\n *\r\n * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n\n/**\r\n * @method constructor IncrementalDisplayble\r\n * @param {Object} opts \r\n */\n// TODO Style override ?\nfunction IncrementalDisplayble(opts) {\n  classUtil.inheritProperties(this, Displayble, opts);\n  this._displayables = [];\n  this._temporaryDisplayables = [];\n  this._cursor = 0;\n  this.notClear = true;\n}\n\nvar m = [];\nIncrementalDisplayble.prototype = {\n  constructor: IncrementalDisplayble,\n  incremental: true,\n  clearDisplaybles: function clearDisplaybles() {\n    this._displayables = [];\n    this._temporaryDisplayables = [];\n    this._cursor = 0;\n    this.dirty();\n    this.notClear = false;\n  },\n  addDisplayable: function addDisplayable(displayable, notPersistent) {\n    if (notPersistent) {\n      this._temporaryDisplayables.push(displayable);\n    } else {\n      this._displayables.push(displayable);\n    }\n\n    this.dirty();\n  },\n  addDisplayables: function addDisplayables(displayables, notPersistent) {\n    notPersistent = notPersistent || false;\n\n    for (var i = 0; i < displayables.length; i++) {\n      this.addDisplayable(displayables[i], notPersistent);\n    }\n  },\n  eachPendingDisplayable: function eachPendingDisplayable(cb) {\n    for (var i = this._cursor; i < this._displayables.length; i++) {\n      cb && cb(this._displayables[i]);\n    }\n\n    for (var _i = 0; _i < this._temporaryDisplayables.length; _i++) {\n      cb && cb(this._temporaryDisplayables[_i]);\n    }\n  },\n  update: function update() {\n    this.updateTransform();\n\n    for (var i = this._cursor; i < this._displayables.length; i++) {\n      var displayable = this._displayables[i]; // PENDING\n\n      displayable.parent = this;\n      displayable.update();\n      displayable.parent = null;\n    }\n\n    for (var _i2 = 0; _i2 < this._temporaryDisplayables.length; _i2++) {\n      var _displayable = this._temporaryDisplayables[_i2]; // PENDING\n\n      _displayable.parent = this;\n\n      _displayable.update();\n\n      _displayable.parent = null;\n    }\n  },\n  brush: function brush(ctx, prevEl) {\n    // Render persistant displayables.\n    var i = this._cursor;\n\n    for (; i < this._displayables.length; i++) {\n      var displayable = this._displayables[i];\n      displayable.beforeBrush && displayable.beforeBrush(ctx);\n      displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);\n      displayable.afterBrush && displayable.afterBrush(ctx);\n    }\n\n    this._cursor = i; // Render temporary displayables.\n\n    for (var _i3 = 0; _i3 < this._temporaryDisplayables.length; _i3++) {\n      var _displayable2 = this._temporaryDisplayables[_i3];\n      _displayable2.beforeBrush && _displayable2.beforeBrush(ctx);\n\n      _displayable2.brush(ctx, _i3 === 0 ? null : this._temporaryDisplayables[_i3 - 1]);\n\n      _displayable2.afterBrush && _displayable2.afterBrush(ctx);\n    }\n\n    this._temporaryDisplayables = [];\n    this.notClear = true;\n  },\n  getBoundingRect: function getBoundingRect() {\n    if (!this._rect) {\n      var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);\n\n      for (var i = 0; i < this._displayables.length; i++) {\n        var displayable = this._displayables[i];\n        var childRect = displayable.getBoundingRect().clone();\n\n        if (displayable.needLocalTransform()) {\n          childRect.applyTransform(displayable.getLocalTransform(m));\n        }\n\n        rect.union(childRect);\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  },\n  contain: function contain(x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n\n    if (rect.contain(localPos[0], localPos[1])) {\n      for (var i = 0; i < this._displayables.length; i++) {\n        var displayable = this._displayables[i];\n\n        if (displayable.contain(x, y)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n};\nclassUtil.inherits(IncrementalDisplayble, Displayble);\nvar _default = IncrementalDisplayble;\nmodule.exports = _default;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\nvar mathMin = _constants.mathMin;\nvar mathMax = _constants.mathMax;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Arc \r\n * 圆弧\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: PI2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  }\n};\n\nvar Arc =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Arc, _Path);\n\n  /**\r\n   * @method constructor Line\r\n   * @param {Object} options \r\n   */\n  function Arc(options) {\n    _classCallCheck(this, Arc);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Arc).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Arc, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x = shape.cx;\n      var y = shape.cy;\n      var r = mathMax(shape.r, 0);\n      var startAngle = shape.startAngle;\n      var endAngle = shape.endAngle;\n      var clockwise = shape.clockwise;\n      var unitX = mathCos(startAngle);\n      var unitY = mathSin(startAngle);\n      ctx.moveTo(unitX * r + x, unitY * r + y);\n      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    }\n  }]);\n\n  return Arc;\n}(Path);\n\nmodule.exports = Arc;","var Path = require(\"../Path\");\n\nvar vec2 = require(\"../../core/utils/vector\");\n\nvar curveUtil = require(\"../../core/utils/curve_util\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.BezierCurve \r\n * 贝塞尔曲线\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  }\n};\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? curveUtil.cubicDerivativeAt : curveUtil.cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? curveUtil.cubicDerivativeAt : curveUtil.cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? curveUtil.quadraticDerivativeAt : curveUtil.quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? curveUtil.quadraticDerivativeAt : curveUtil.quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar BezierCurve =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(BezierCurve, _Path);\n\n  /**\r\n   * @method constructor BezierCurve\r\n   * @param {Object} options \r\n   */\n  function BezierCurve(options) {\n    _classCallCheck(this, BezierCurve);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BezierCurve).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(BezierCurve, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x1 = shape.x1;\n      var y1 = shape.y1;\n      var x2 = shape.x2;\n      var y2 = shape.y2;\n      var cpx1 = shape.cpx1;\n      var cpy1 = shape.cpy1;\n      var cpx2 = shape.cpx2;\n      var cpy2 = shape.cpy2;\n      var percent = shape.percent;\n\n      if (percent === 0) {\n        return;\n      }\n\n      ctx.moveTo(x1, y1);\n\n      if (cpx2 == null || cpy2 == null) {\n        if (percent < 1) {\n          curveUtil.quadraticSubdivide(x1, cpx1, x2, percent, out);\n          cpx1 = out[1];\n          x2 = out[2];\n          curveUtil.quadraticSubdivide(y1, cpy1, y2, percent, out);\n          cpy1 = out[1];\n          y2 = out[2];\n        }\n\n        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n      } else {\n        if (percent < 1) {\n          curveUtil.cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n          cpx1 = out[1];\n          cpx2 = out[2];\n          x2 = out[3];\n          curveUtil.cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n          cpy1 = out[1];\n          cpy2 = out[2];\n          y2 = out[3];\n        }\n\n        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n      }\n    }\n    /**\r\n     * Get point at percent\r\n     * @param  {Number} t\r\n     * @return {Array<Number>}\r\n     */\n\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(t) {\n      return someVectorAt(this.shape, t, false);\n    }\n    /**\r\n     * Get tangent at percent\r\n     * @param  {Number} t\r\n     * @return {Array<Number>}\r\n     */\n\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(t) {\n      var p = someVectorAt(this.shape, t, true);\n      return vec2.normalize(p, p);\n    }\n  }]);\n\n  return BezierCurve;\n}(Path);\n\nmodule.exports = BezierCurve;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Droplet \r\n * 水滴形状\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'droplet',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  }\n};\n\nvar Droplet =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Droplet, _Path);\n\n  /**\r\n   * @method constructor Droplet\r\n   * @param {Object} options \r\n   */\n  function Droplet(options) {\n    _classCallCheck(this, Droplet);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Droplet).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Droplet, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x = shape.cx;\n      var y = shape.cy;\n      var a = shape.width;\n      var b = shape.height;\n      ctx.moveTo(x, y + a);\n      ctx.bezierCurveTo(x + a, y + a, x + a * 3 / 2, y - a / 3, x, y - b);\n      ctx.bezierCurveTo(x - a * 3 / 2, y - a / 3, x - a, y + a, x, y + a);\n      ctx.closePath();\n    }\n  }]);\n\n  return Droplet;\n}(Path);\n\nmodule.exports = Droplet;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Heart \r\n * 心形\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'heart',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  }\n};\n\nvar Heart =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Heart, _Path);\n\n  /**\r\n   * @method constructor Heart\r\n   * @param {Object} options \r\n   */\n  function Heart(options) {\n    _classCallCheck(this, Heart);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Heart).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Heart, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x = shape.cx;\n      var y = shape.cy;\n      var a = shape.width;\n      var b = shape.height;\n      ctx.moveTo(x, y);\n      ctx.bezierCurveTo(x + a / 2, y - b * 2 / 3, x + a * 2, y + b / 3, x, y + b);\n      ctx.bezierCurveTo(x - a * 2, y + b / 3, x - a / 2, y - b * 2 / 3, x, y);\n    }\n  }]);\n\n  return Heart;\n}(Path);\n\nmodule.exports = Heart;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI = _constants.PI;\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Isogon \r\n * 正多边形\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'isogon',\n  shape: {\n    x: 0,\n    y: 0,\n    r: 0,\n    n: 0\n  }\n};\n\nvar Isogon =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Isogon, _Path);\n\n  /**\r\n   * @method constructor Isogon\r\n   * @param {Object} options \r\n   */\n  function Isogon(options) {\n    _classCallCheck(this, Isogon);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Isogon).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Isogon, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var n = shape.n;\n\n      if (!n || n < 2) {\n        return;\n      }\n\n      var x = shape.x;\n      var y = shape.y;\n      var r = shape.r;\n      var dStep = 2 * PI / n;\n      var deg = -PI / 2;\n      ctx.moveTo(x + r * mathCos(deg), y + r * mathSin(deg));\n\n      for (var i = 0, end = n - 1; i < end; i++) {\n        deg += dStep;\n        ctx.lineTo(x + r * mathCos(deg), y + r * mathSin(deg));\n      }\n\n      ctx.closePath();\n      return;\n    }\n  }]);\n\n  return Isogon;\n}(Path);\n\nmodule.exports = Isogon;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar PI2 = _constants.PI2;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Ring \r\n * 圆环\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  }\n};\n\nvar Ring =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Ring, _Path);\n\n  /**\r\n   * @method constructor Ring\r\n   * @param {Object} options \r\n   */\n  function Ring(options) {\n    _classCallCheck(this, Ring);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Ring).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Ring, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x = shape.cx;\n      var y = shape.cy;\n      ctx.moveTo(x + shape.r, y);\n      ctx.arc(x, y, shape.r, 0, PI2, false);\n      ctx.moveTo(x + shape.r0, y);\n      ctx.arc(x, y, shape.r0, 0, PI2, true);\n    }\n  }]);\n\n  return Ring;\n}(Path);\n\nmodule.exports = Ring;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Rose \r\n * 玫瑰线\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar radian = Math.PI / 180;\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'rose',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: [],\n    k: 0,\n    n: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  }\n};\n\nvar Rose =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Rose, _Path);\n\n  /**\r\n   * @method constructor Rose\r\n   * @param {Object} options \r\n   */\n  function Rose(options) {\n    _classCallCheck(this, Rose);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Rose).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Rose, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x;\n      var y;\n      var R = shape.r;\n      var r;\n      var k = shape.k;\n      var n = shape.n;\n      var x0 = shape.cx;\n      var y0 = shape.cy;\n      ctx.moveTo(x0, y0);\n\n      for (var i = 0, len = R.length; i < len; i++) {\n        r = R[i];\n\n        for (var j = 0; j <= 360 * n; j++) {\n          x = r * mathSin(k / n * j % 360 * radian) * mathCos(j * radian) + x0;\n          y = r * mathSin(k / n * j % 360 * radian) * mathSin(j * radian) + y0;\n          ctx.lineTo(x, y);\n        }\n      }\n    }\n  }]);\n\n  return Rose;\n}(Path);\n\nmodule.exports = Rose;","var Path = require(\"../Path\");\n\nvar fixClipWithShadow = require(\"../utils/fix_clip_with_shadow\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\nvar mathMax = _constants.mathMax;\nvar PI2 = _constants.PI2;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Sector \r\n * 扇形\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: PI2,\n    clockwise: true\n  }\n};\n\nvar Sector =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Sector, _Path);\n\n  /**\r\n   * @method constructor Sector\r\n   * @param {Object} options \r\n   */\n  function Sector(options) {\n    var _this;\n\n    _classCallCheck(this, Sector);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Sector).call(this, dataUtil.merge(defaultConfig, options, true)));\n    _this.brush = fixClipWithShadow(Path.prototype.brush);\n    return _this;\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Sector, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x = shape.cx;\n      var y = shape.cy;\n      var r0 = mathMax(shape.r0 || 0, 0);\n      var r = mathMax(shape.r, 0);\n      var startAngle = shape.startAngle;\n      var endAngle = shape.endAngle;\n      var clockwise = shape.clockwise;\n      var unitX = mathCos(startAngle);\n      var unitY = mathSin(startAngle);\n      ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n      ctx.lineTo(unitX * r + x, unitY * r + y);\n      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n      ctx.lineTo(mathCos(endAngle) * r0 + x, mathSin(endAngle) * r0 + y);\n\n      if (r0 !== 0) {\n        ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n      }\n\n      ctx.closePath();\n    }\n  }]);\n\n  return Sector;\n}(Path);\n\nmodule.exports = Sector;","var env = require(\"../../core/env\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\nvar PI2 = _constants.PI2;\nvar PI = _constants.PI;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Star \r\n * n角星（n>3）\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'star',\n  shape: {\n    cx: 0,\n    cy: 0,\n    n: 3,\n    r0: null,\n    r: 0\n  }\n};\n\nvar Star =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Star, _Path);\n\n  /**\r\n   * @method constructor Star\r\n   * @param {Object} options \r\n   */\n  function Star(options) {\n    _classCallCheck(this, Star);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Star).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Star, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var n = shape.n;\n\n      if (!n || n < 2) {\n        return;\n      }\n\n      var x = shape.cx;\n      var y = shape.cy;\n      var r = shape.r;\n      var r0 = shape.r0; // 如果未指定内部顶点外接圆半径，则自动计算\n\n      if (r0 == null) {\n        r0 = n > 4 // 相隔的外部顶点的连线的交点，\n        // 被取为内部交点，以此计算r0\n        ? r * mathCos(2 * PI / n) / mathCos(PI / n) // 二三四角星的特殊处理\n        : r / 3;\n      }\n\n      var dStep = PI / n;\n      var deg = -PI / 2;\n      var xStart = x + r * mathCos(deg);\n      var yStart = y + r * mathSin(deg);\n      deg += dStep; // 记录边界点，用于判断inside\n\n      ctx.moveTo(xStart, yStart);\n\n      for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\n        ri = i % 2 === 0 ? r0 : r;\n        ctx.lineTo(x + ri * mathCos(deg), y + ri * mathSin(deg));\n        deg += dStep;\n      }\n\n      ctx.closePath();\n    }\n  }]);\n\n  return Star;\n}(Path);\n\nmodule.exports = Star;","var Path = require(\"../Path\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar _constants = require(\"../../graphic/constants\");\n\nvar mathSin = _constants.mathSin;\nvar mathCos = _constants.mathCos;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.graphic.shape.Trochold \r\n * 内外旋轮曲线\r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\nvar defaultConfig = {\n  /**\r\n   * @property {String} type\r\n   */\n  type: 'trochoid',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0,\n    d: 0,\n    location: 'out'\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  }\n};\n\nvar Trochold =\n/*#__PURE__*/\nfunction (_Path) {\n  _inherits(Trochold, _Path);\n\n  /**\r\n   * @method constructor Trochold\r\n   * @param {Object} options \r\n   */\n  function Trochold(options) {\n    _classCallCheck(this, Trochold);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Trochold).call(this, dataUtil.merge(defaultConfig, options, true)));\n  }\n  /**\r\n   * @method buildPath\r\n   * 绘制元素路径\r\n   * @param {Object} ctx \r\n   * @param {String} shape \r\n   */\n\n\n  _createClass(Trochold, [{\n    key: \"buildPath\",\n    value: function buildPath(ctx, shape) {\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n      var R = shape.r;\n      var r = shape.r0;\n      var d = shape.d;\n      var offsetX = shape.cx;\n      var offsetY = shape.cy;\n      var delta = shape.location === 'out' ? 1 : -1;\n\n      if (shape.location && R <= r) {\n        return;\n      }\n\n      var num = 0;\n      var i = 1;\n      var theta;\n      x1 = (R + delta * r) * mathCos(0) - delta * d * mathCos(0) + offsetX;\n      y1 = (R + delta * r) * mathSin(0) - d * mathSin(0) + offsetY;\n      ctx.moveTo(x1, y1); // 计算结束时的i\n\n      do {\n        num++;\n      } while (r * num % (R + delta * r) !== 0);\n\n      do {\n        theta = Math.PI / 180 * i;\n        x2 = (R + delta * r) * mathCos(theta) - delta * d * mathCos((R / r + delta) * theta) + offsetX;\n        y2 = (R + delta * r) * mathSin(theta) - d * mathSin((R / r + delta) * theta) + offsetY;\n        ctx.lineTo(x2, y2);\n        i++;\n      } while (i <= r * num / (R + delta * r) * 360);\n    }\n  }]);\n\n  return Trochold;\n}(Path);\n\nmodule.exports = Trochold;","var classUtil = require(\"../../core/utils/class_util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\r\n * @class qrenderer.graphic.gradient.RadialGradient \r\n * @docauthor 大漠穷秋 <damoqiongqiu@126.com>\r\n */\n\n/**\r\n * @method constructor RadialGradient\r\n * @param {Number} [x=0.5]\r\n * @param {Number} [y=0.5]\r\n * @param {Number} [r=0.5]\r\n * @param {Array<Object>} [colorStops]\r\n * @param {boolean} [globalCoord=false]\r\n */\nvar RadialGradient = function RadialGradient(x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nclassUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;","require(\"./graphic\");\n\nvar _quarkRenderer = require(\"../quark-renderer\");\n\nvar registerPainter = _quarkRenderer.registerPainter;\n\nvar SVGPainter = require(\"./SVGPainter\");\n\nregisterPainter('svg', SVGPainter);","var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = require(\"../graphic/PathProxy\");\n\nvar BoundingRect = require(\"../graphic/transform/BoundingRect\");\n\nvar matrix = require(\"../core/utils/matrix\");\n\nvar textContain = require(\"../core/contain/text\");\n\nvar textUtil = require(\"../graphic/utils/text_util\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar _constants = require(\"../graphic/constants\");\n\nvar PI = _constants.PI;\nvar PI2 = _constants.PI2;\nvar mathRound = _constants.mathRound;\nvar mathAbs = _constants.mathAbs;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\nvar CMD = PathProxy.CMD;\nvar NONE = 'none';\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + Array.prototype.join.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/**\r\n * @class qrenderer.svg.SVGPath\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = mathAbs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n/**\r\n * @class qrenderer.svg.SVGPath\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/**\r\n * @class qrenderer.svg.SVGImage\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/**\r\n * @class qrenderer.svg.SVGText\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n\nvar svgText = {};\n\nvar _tmpTextHostRect = new BoundingRect();\n\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\r\n * @param {Element} el\r\n * @param {Object|boolean} [hostRect] {x, y, width, height}\r\n *        If set false, rect text is not used.\r\n */\n\nvar svgTextDrawRectText = function svgTextDrawRectText(el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textUtil.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n\n  if (!textUtil.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n\n    _tmpTextHostRect.applyTransform(elTransform);\n\n    hostRect = _tmpTextHostRect;\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textUtil.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var _idx = 0;\n\n    for (; _idx < nTextLines; _idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[_idx];\n      var singleLineText = textLines[_idx];\n\n      if (!tspan) {\n        tspan = tspanList[_idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__qrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n\n      updateTextLocation(tspan, textAlign, textX, textY + _idx * lineHeight);\n    } // Remove unused tspan elements\n\n\n    if (tspanOriginLen > nTextLines) {\n      for (; _idx < tspanOriginLen; _idx++) {\n        textSvgEl.removeChild(tspanList[_idx]);\n      }\n\n      tspanList.length = nTextLines;\n    }\n  }\n};\n\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n\n  var textRotation = style.textRotation;\n\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\n\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;","var svgURI = 'http://www.w3.org/2000/svg';\n\nfunction createElement(name) {\n  return document.createElementNS(svgURI, name);\n}\n\nexports.createElement = createElement;","var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar QImage = require(\"../graphic/Image\");\n\nvar QText = require(\"../graphic/Text\");\n\nvar arrayDiff = require(\"../core/utils/array_diff2\");\n\nvar GradientManager = require(\"./helper/GradientManager\");\n\nvar ClippathManager = require(\"./helper/ClippathManager\");\n\nvar ShadowManager = require(\"./helper/ShadowManager\");\n\nvar _graphic = require(\"./graphic\");\n\nvar svgPath = _graphic.path;\nvar svgImage = _graphic.image;\nvar svgText = _graphic.text;\n\n/**\r\n * @class qrenderer.svg.SVGPainter\r\n * \r\n * SVG 画笔。\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n/**\r\n * @private\r\n * @method getSvgProxy\r\n * \r\n * QImage 映射成 svgImage，ZText 映射成 svgText，其它所有都映射成 svgPath。\r\n * \r\n * @param {Element} el \r\n */\nfunction getSvgProxy(el) {\n  if (el instanceof Path) {\n    return svgPath;\n  } else if (el instanceof QImage) {\n    return svgImage;\n  } else if (el instanceof QText) {\n    return svgText;\n  }\n\n  return svgPath;\n}\n\nfunction checkParentAvailable(parent, child) {\n  return child && parent && child.parentNode !== parent;\n}\n\nfunction insertAfter(parent, child, prevSibling) {\n  if (checkParentAvailable(parent, child) && prevSibling) {\n    var nextSibling = prevSibling.nextSibling;\n    nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);\n  }\n}\n\nfunction prepend(parent, child) {\n  if (checkParentAvailable(parent, child)) {\n    var firstChild = parent.firstChild;\n    firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);\n  }\n}\n\nfunction remove(parent, child) {\n  if (child && parent && child.parentNode === parent) {\n    parent.removeChild(child);\n  }\n}\n\nfunction getTextSvgElement(displayable) {\n  return displayable.__textSvgEl;\n}\n\nfunction getSvgElement(displayable) {\n  return displayable.__svgEl;\n}\n/**\r\n * @method constructor SVGPainter\r\n * @param {HTMLElement} root 绘图容器\r\n * @param {Storage} storage\r\n * @param {Object} opts\r\n */\n\n\nvar SVGPainter = function SVGPainter(root, storage, opts, qrId) {\n  this.root = root;\n  this.storage = storage;\n  this._opts = opts = dataUtil.extend({}, opts || {});\n  var svgRoot = createElement('svg');\n  svgRoot.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgRoot.setAttribute('version', '1.1');\n  svgRoot.setAttribute('baseProfile', 'full');\n  svgRoot.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';\n  this.gradientManager = new GradientManager(qrId, svgRoot);\n  this.clipPathManager = new ClippathManager(qrId, svgRoot);\n  this.shadowManager = new ShadowManager(qrId, svgRoot);\n  var viewport = document.createElement('div');\n  viewport.style.cssText = 'overflow:hidden;position:relative';\n  this._svgRoot = svgRoot;\n  this._viewport = viewport;\n  root.appendChild(viewport);\n  viewport.appendChild(svgRoot);\n  this.resize(opts.width, opts.height);\n  this._visibleList = [];\n};\n\nSVGPainter.prototype = {\n  constructor: SVGPainter,\n\n  /**\r\n   * @method getType\r\n   */\n  getType: function getType() {\n    return 'svg';\n  },\n\n  /**\r\n   * @method getViewportRoot\r\n   */\n  getViewportRoot: function getViewportRoot() {\n    return this._viewport;\n  },\n\n  /**\r\n   * @method getViewportRootOffset\r\n   */\n  getViewportRootOffset: function getViewportRootOffset() {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\r\n   * @method refresh\r\n   */\n  refresh: function refresh() {\n    var list = this.storage.getDisplayList(true);\n\n    this._paintList(list);\n  },\n\n  /**\r\n   * @method setBackgroundColor\r\n   */\n  setBackgroundColor: function setBackgroundColor(backgroundColor) {\n    // TODO gradient\n    this._viewport.style.background = backgroundColor;\n  },\n\n  /**\r\n   * @private\r\n   * @method _paintList\r\n   */\n  _paintList: function _paintList(list) {\n    this.gradientManager.markAllUnused();\n    this.clipPathManager.markAllUnused();\n    this.shadowManager.markAllUnused();\n    var svgRoot = this._svgRoot;\n    var visibleList = this._visibleList;\n    var listLen = list.length;\n    var newVisibleList = [];\n    var i;\n    var svgElement;\n    var textSvgElement;\n\n    for (i = 0; i < listLen; i++) {\n      var displayable = list[i];\n      var svgProxy = getSvgProxy(displayable);\n      svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);\n\n      if (!displayable.invisible) {\n        if (displayable.__dirty) {\n          svgProxy && svgProxy.brush(displayable); // Update clipPath\n\n          this.clipPathManager.update(displayable); // Update gradient and shadow\n\n          if (displayable.style.fill && displayable.style.stroke) {\n            this.gradientManager.update(displayable.style.fill);\n            this.gradientManager.update(displayable.style.stroke);\n          }\n\n          this.shadowManager.update(svgElement, displayable);\n          displayable.__dirty = false;\n        }\n\n        newVisibleList.push(displayable);\n      }\n    }\n\n    var diff = arrayDiff(visibleList, newVisibleList);\n    var prevSvgElement; // First do remove, in case element moved to the head and do remove\n    // after add\n\n    for (i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.removed) {\n        for (var k = 0; k < item.count; k++) {\n          var _displayable = visibleList[item.indices[k]];\n          svgElement = getSvgElement(_displayable);\n          textSvgElement = getTextSvgElement(_displayable);\n          remove(svgRoot, svgElement);\n          remove(svgRoot, textSvgElement);\n        }\n      }\n    }\n\n    for (i = 0; i < diff.length; i++) {\n      var _item = diff[i];\n\n      if (_item.added) {\n        for (var _k = 0; _k < _item.count; _k++) {\n          var _displayable2 = newVisibleList[_item.indices[_k]];\n          svgElement = getSvgElement(_displayable2);\n          textSvgElement = getTextSvgElement(_displayable2);\n          prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);\n\n          if (svgElement) {\n            insertAfter(svgRoot, textSvgElement, svgElement);\n          } else if (prevSvgElement) {\n            insertAfter(svgRoot, textSvgElement, prevSvgElement);\n          } else {\n            prepend(svgRoot, textSvgElement);\n          } // Insert text\n\n\n          insertAfter(svgRoot, textSvgElement, svgElement);\n          prevSvgElement = textSvgElement || svgElement || prevSvgElement; // qrenderer.Text only create textSvgElement.\n\n          this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, _displayable2);\n          this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, _displayable2);\n          this.clipPathManager.markUsed(_displayable2);\n        }\n      } else if (!_item.removed) {\n        for (var _k2 = 0; _k2 < _item.count; _k2++) {\n          var _displayable3 = newVisibleList[_item.indices[_k2]];\n          svgElement = getSvgElement(_displayable3);\n          textSvgElement = getTextSvgElement(_displayable3);\n          svgElement = getSvgElement(_displayable3);\n          textSvgElement = getTextSvgElement(_displayable3);\n          this.gradientManager.markUsed(_displayable3);\n          this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, _displayable3);\n          this.shadowManager.markUsed(_displayable3);\n          this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, _displayable3);\n          this.clipPathManager.markUsed(_displayable3);\n\n          if (textSvgElement) {\n            // Insert text.\n            insertAfter(svgRoot, textSvgElement, svgElement);\n          }\n\n          prevSvgElement = svgElement || textSvgElement || prevSvgElement;\n        }\n      }\n    }\n\n    this.gradientManager.removeUnused();\n    this.clipPathManager.removeUnused();\n    this.shadowManager.removeUnused();\n    this._visibleList = newVisibleList;\n  },\n\n  /**\r\n   * @private\r\n   * @method _paintList\r\n   */\n  _getDefs: function _getDefs(isForceCreating) {\n    var svgRoot = this._svgRoot;\n\n    var defs = this._svgRoot.getElementsByTagName('defs');\n\n    if (defs.length !== 0) {\n      return defs[0];\n    } // Not exist\n\n\n    if (!isForceCreating) {\n      return null;\n    }\n\n    defs = svgRoot.insertBefore(createElement('defs'), // Create new tag\n    svgRoot.firstChild // Insert in the front of svg\n    );\n\n    if (!defs.contains) {\n      // IE doesn't support contains method\n      defs.contains = function (el) {\n        var children = defs.children;\n\n        if (!children) {\n          return false;\n        }\n\n        for (var i = children.length - 1; i >= 0; --i) {\n          if (children[i] === el) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n    }\n\n    return defs;\n  },\n\n  /**\r\n   * @method resize\r\n   */\n  resize: function resize(width, height) {\n    var viewport = this._viewport; // FIXME Why ?\n\n    viewport.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    viewport.style.display = '';\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      var viewportStyle = viewport.style;\n      viewportStyle.width = width + 'px';\n      viewportStyle.height = height + 'px';\n      var svgRoot = this._svgRoot; // Set width by 'svgRoot.width = width' is invalid\n\n      svgRoot.setAttribute('width', width);\n      svgRoot.setAttribute('height', height);\n    }\n  },\n\n  /**\r\n   * @method getWidth\r\n   * 获取绘图区域宽度\r\n   */\n  getWidth: function getWidth() {\n    return this._width;\n  },\n\n  /**\r\n   * @method getHeight\r\n   * 获取绘图区域高度\r\n   */\n  getHeight: function getHeight() {\n    return this._height;\n  },\n\n  /**\r\n   * @private\r\n   * @method _getSize\r\n   */\n  _getSize: function _getSize(whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || dataUtil.parseInt10(stl[wh]) || dataUtil.parseInt10(root.style[wh])) - (dataUtil.parseInt10(stl[plt]) || 0) - (dataUtil.parseInt10(stl[prb]) || 0) | 0;\n  },\n\n  /**\r\n   * @method dispose\r\n   */\n  dispose: function dispose() {\n    this.root.innerHTML = '';\n    this._svgRoot = this._viewport = this.storage = null;\n  },\n\n  /**\r\n   * @method clear\r\n   */\n  clear: function clear() {\n    if (this._viewport) {\n      this.root.removeChild(this._viewport);\n    }\n  },\n\n  /**\r\n   * @method pathToDataUrl\r\n   */\n  pathToDataUrl: function pathToDataUrl() {\n    this.refresh();\n    var html = this._svgRoot.outerHTML;\n    return 'data:image/svg+xml;charset=UTF-8,' + html;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    console.log('In SVG mode painter not support method \"' + method + '\"');\n  };\n} // Unsuppoted methods\n\n\n['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'].forEach(function (name, index) {\n  SVGPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = SVGPainter;\nmodule.exports = _default;","// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function diff(oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function equals(a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function tokenize(value) {\n    return value.slice();\n  },\n  join: function join(value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;","var Definable = require(\"./Definable\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../../core/utils/class_util\");\n\nvar colorTool = require(\"../../core/utils/color_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.svg.helper.GradientManager\r\n * \r\n * Manages SVG gradient elements.\r\n * \r\n * @author Zhang Wenli\r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\nvar GradientManager =\n/*#__PURE__*/\nfunction (_Definable) {\n  _inherits(GradientManager, _Definable);\n\n  /**\r\n   * @method constructor GradientManager\r\n   * Manages SVG gradient elements.\r\n   *\r\n   * @param   {Number}     qrId    qrenderer instance id\r\n   * @param   {SVGElement} svgRoot root of SVG document\r\n   */\n  function GradientManager(qrId, svgRoot) {\n    _classCallCheck(this, GradientManager);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GradientManager).call(this, qrId, svgRoot, ['linearGradient', 'radialGradient'], '__gradient_in_use__'));\n  }\n  /**\r\n   * @method addWithoutUpdate\r\n   * Create new gradient DOM for fill or stroke if not exist,\r\n   * but will not update gradient if exists.\r\n   *\r\n   * @param {SvgElement}  svgElement   SVG element to paint\r\n   * @param {Displayable} displayable  qrenderer displayable element\r\n   */\n\n\n  _createClass(GradientManager, [{\n    key: \"addWithoutUpdate\",\n    value: function addWithoutUpdate(svgElement, displayable) {\n      if (displayable && displayable.style) {\n        var that = this;\n        dataUtil.each(['fill', 'stroke'], function (fillOrStroke) {\n          if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === 'linear' || displayable.style[fillOrStroke].type === 'radial')) {\n            var gradient = displayable.style[fillOrStroke];\n            var defs = that.getDefs(true); // Create dom in <defs> if not exists\n\n            var dom;\n\n            if (gradient._dom) {\n              // Gradient exists\n              dom = gradient._dom;\n\n              if (!defs.contains(gradient._dom)) {\n                // _dom is no longer in defs, recreate\n                that.addDom(dom);\n              }\n            } else {\n              // New dom\n              dom = that.add(gradient);\n            }\n\n            that.markUsed(displayable);\n            var id = dom.getAttribute('id');\n            svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');\n          }\n        });\n      }\n    }\n    /**\r\n     * @method add\r\n     * \r\n     * Add a new gradient tag in <defs>\r\n     *\r\n     * @param   {Gradient} gradient qr gradient instance\r\n     * @return {SVGLinearGradientElement | SVGRadialGradientElement} created DOM\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(gradient) {\n      var dom;\n\n      if (gradient.type === 'linear') {\n        dom = this.createElement('linearGradient');\n      } else if (gradient.type === 'radial') {\n        dom = this.createElement('radialGradient');\n      } else {\n        console.log('Illegal gradient type.');\n        return null;\n      } // Set dom id with gradient id, since each gradient instance\n      // will have no more than one dom element.\n      // id may exists before for those dirty elements, in which case\n      // id should remain the same, and other attributes should be\n      // updated.\n\n\n      gradient.id = gradient.id || this.nextId++;\n      dom.setAttribute('id', \"qr\".concat(this._qrId, \"-gradient-\").concat(gradient.id));\n      this.updateDom(gradient, dom);\n      this.addDom(dom);\n      return dom;\n    }\n    /**\r\n     * @method update\r\n     * \r\n     * Update gradient.\r\n     *\r\n     * @param {Gradient} gradient qr gradient instance\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(gradient) {\n      var that = this;\n      Definable.prototype.update.call(this, gradient, function () {\n        var type = gradient.type;\n        var tagName = gradient._dom.tagName;\n\n        if (type === 'linear' && tagName === 'linearGradient' || type === 'radial' && tagName === 'radialGradient') {\n          // Gradient type is not changed, update gradient\n          that.updateDom(gradient, gradient._dom);\n        } else {\n          // Remove and re-create if type is changed\n          that.removeDom(gradient);\n          that.add(gradient);\n        }\n      });\n    }\n    /**\r\n     * @method updateDom\r\n     * \r\n     * Update gradient dom\r\n     *\r\n     * @param {Gradient} gradient qr gradient instance\r\n     * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom\r\n     *                            DOM to update\r\n     */\n\n  }, {\n    key: \"updateDom\",\n    value: function updateDom(gradient, dom) {\n      if (gradient.type === 'linear') {\n        dom.setAttribute('x1', gradient.x);\n        dom.setAttribute('y1', gradient.y);\n        dom.setAttribute('x2', gradient.x2);\n        dom.setAttribute('y2', gradient.y2);\n      } else if (gradient.type === 'radial') {\n        dom.setAttribute('cx', gradient.x);\n        dom.setAttribute('cy', gradient.y);\n        dom.setAttribute('r', gradient.r);\n      } else {\n        console.log('Illegal gradient type.');\n        return;\n      }\n\n      if (gradient.global) {\n        // x1, x2, y1, y2 in range of 0 to canvas width or height\n        dom.setAttribute('gradientUnits', 'userSpaceOnUse');\n      } else {\n        // x1, x2, y1, y2 in range of 0 to 1\n        dom.setAttribute('gradientUnits', 'objectBoundingBox');\n      } // Remove color stops if exists\n\n\n      dom.innerHTML = ''; // Add color stops\n\n      var colors = gradient.colorStops;\n\n      for (var i = 0, len = colors.length; i < len; ++i) {\n        var stop = this.createElement('stop');\n        stop.setAttribute('offset', colors[i].offset * 100 + '%');\n        var color = colors[i].color;\n\n        if (color.indexOf('rgba' > -1)) {\n          // Fix Safari bug that stop-color not recognizing alpha #9014\n          var opacity = colorTool.parse(color)[3];\n          var hex = colorTool.toHex(color); // stop-color cannot be color, since:\n          // The opacity value used for the gradient calculation is the\n          // *product* of the value of stop-opacity and the opacity of the\n          // value of stop-color.\n          // See https://www.w3.org/TR/SVG2/pservers.html#StopOpacityProperty\n\n          stop.setAttribute('stop-color', '#' + hex);\n          stop.setAttribute('stop-opacity', opacity);\n        } else {\n          stop.setAttribute('stop-color', colors[i].color);\n        }\n\n        dom.appendChild(stop);\n      } // Store dom element in gradient, to avoid creating multiple\n      // dom instances for the same gradient element\n\n\n      gradient._dom = dom;\n    }\n    /**\r\n     * @method markUsed\r\n     * \r\n     * Mark a single gradient to be used\r\n     *\r\n     * @param {Displayable} displayable displayable element\r\n     */\n\n  }, {\n    key: \"markUsed\",\n    value: function markUsed(displayable) {\n      if (displayable.style) {\n        var gradient = displayable.style.fill;\n\n        if (gradient && gradient._dom) {\n          Definable.prototype.markUsed.call(this, gradient._dom);\n        }\n\n        gradient = displayable.style.stroke;\n\n        if (gradient && gradient._dom) {\n          Definable.prototype.markUsed.call(this, gradient._dom);\n        }\n      }\n    }\n  }]);\n\n  return GradientManager;\n}(Definable);\n\nvar _default = GradientManager;\nmodule.exports = _default;","var _core = require(\"../core\");\n\nvar createElement = _core.createElement;\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar Path = require(\"../../graphic/Path\");\n\nvar QImage = require(\"../../graphic/Image\");\n\nvar QText = require(\"../../graphic/Text\");\n\nvar _graphic = require(\"../graphic\");\n\nvar svgPath = _graphic.path;\nvar svgImage = _graphic.image;\nvar svgText = _graphic.text;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * @class qrenderer.svg.helper.Definable\r\n * \r\n * Manages elements that can be defined in <defs> in SVG,\r\n *       e.g., gradients, clip path, etc.\r\n * @author Zhang Wenli\r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\nvar MARK_UNUSED = '0';\nvar MARK_USED = '1';\n\nvar Definable =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @method constructor Definable\r\n   * \r\n   * Manages elements that can be defined in <defs> in SVG,\r\n   * e.g., gradients, clip path, etc.\r\n   *\r\n   * @param {Number}          qrId      qrenderer instance id\r\n   * @param {SVGElement}      svgRoot   root of SVG document\r\n   * @param {String|String[]} tagNames  possible tag names\r\n   * @param {String}          markLabel label name to make if the element\r\n   *                                    is used\r\n   */\n  function Definable(qrId, svgRoot, tagNames, markLabel, domName) {\n    _classCallCheck(this, Definable);\n\n    this._qrId = qrId;\n    this._svgRoot = svgRoot;\n    this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;\n    this._markLabel = markLabel;\n    this._domName = domName || '_dom';\n    this.nextId = 0;\n    this.createElement = createElement;\n  }\n  /**\r\n   * @method getDefs\r\n   * \r\n   * Get the <defs> tag for svgRoot; optionally creates one if not exists.\r\n   *\r\n   * @param {Boolean} isForceCreating if need to create when not exists\r\n   * @return {SVGDefsElement} SVG <defs> element, null if it doesn't exist and isForceCreating is false\r\n   */\n\n\n  _createClass(Definable, [{\n    key: \"getDefs\",\n    value: function getDefs(isForceCreating) {\n      var svgRoot = this._svgRoot;\n\n      var defs = this._svgRoot.getElementsByTagName('defs');\n\n      if (defs.length === 0) {\n        // Not exist\n        if (isForceCreating) {\n          defs = svgRoot.insertBefore(this.createElement('defs'), // Create new tag\n          svgRoot.firstChild // Insert in the front of svg\n          );\n\n          if (!defs.contains) {\n            // IE doesn't support contains method\n            defs.contains = function (el) {\n              var children = defs.children;\n\n              if (!children) {\n                return false;\n              }\n\n              for (var i = children.length - 1; i >= 0; --i) {\n                if (children[i] === el) {\n                  return true;\n                }\n              }\n\n              return false;\n            };\n          }\n\n          return defs;\n        } else {\n          return null;\n        }\n      } else {\n        return defs[0];\n      }\n    }\n    /**\r\n     * @method update\r\n     * \r\n     * Update DOM element if necessary.\r\n     *\r\n     * @param {Object|String} element style element. e.g., for gradient, it may be '#ccc' or {type: 'linear', ...}\r\n     * @param {Function|undefined} onUpdate update callback\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(element, onUpdate) {\n      if (!element) {\n        return;\n      }\n\n      var defs = this.getDefs(false);\n\n      if (element[this._domName] && defs.contains(element[this._domName])) {\n        // Update DOM\n        if (typeof onUpdate === 'function') {\n          onUpdate(element);\n        }\n      } else {\n        // No previous dom, create new\n        var dom = this.add(element);\n\n        if (dom) {\n          element[this._domName] = dom;\n        }\n      }\n    }\n    /**\r\n     * @method addDom\r\n     * \r\n     * Add gradient dom to defs\r\n     *\r\n     * @param {SVGElement} dom DOM to be added to <defs>\r\n     */\n\n  }, {\n    key: \"addDom\",\n    value: function addDom(dom) {\n      var defs = this.getDefs(true);\n      defs.appendChild(dom);\n    }\n    /**\r\n     * @method removeDom\r\n     * \r\n     * Remove DOM of a given element.\r\n     *\r\n     * @param {SVGElement} element element to remove dom\r\n     */\n\n  }, {\n    key: \"removeDom\",\n    value: function removeDom(element) {\n      var defs = this.getDefs(false);\n\n      if (defs && element[this._domName]) {\n        defs.removeChild(element[this._domName]);\n        element[this._domName] = null;\n      }\n    }\n    /**\r\n     * @method getDoms\r\n     * \r\n     * Get DOMs of this element.\r\n     *\r\n     * @return {HTMLDomElement} doms of this defineable elements in <defs>\r\n     */\n\n  }, {\n    key: \"getDoms\",\n    value: function getDoms() {\n      var defs = this.getDefs(false);\n\n      if (!defs) {\n        // No dom when defs is not defined\n        return [];\n      }\n\n      var doms = [];\n      dataUtil.each(this._tagNames, function (tagName) {\n        var tags = defs.getElementsByTagName(tagName); // Note that tags is HTMLCollection, which is array-like\n        // rather than real array.\n        // So `doms.concat(tags)` add tags as one object.\n\n        doms = doms.concat([].slice.call(tags));\n      });\n      return doms;\n    }\n    /**\r\n     * @method markAllUnused\r\n     * \r\n     * Mark DOMs to be unused before painting, and clear unused ones at the end\r\n     * of the painting.\r\n     */\n\n  }, {\n    key: \"markAllUnused\",\n    value: function markAllUnused() {\n      var doms = this.getDoms();\n      var that = this;\n      dataUtil.each(doms, function (dom) {\n        dom[that._markLabel] = MARK_UNUSED;\n      });\n    }\n    /**\r\n     * @method markUsed\r\n     * \r\n     * Mark a single DOM to be used.\r\n     *\r\n     * @param {SVGElement} dom DOM to mark\r\n     */\n\n  }, {\n    key: \"markUsed\",\n    value: function markUsed(dom) {\n      if (dom) {\n        dom[this._markLabel] = MARK_USED;\n      }\n    }\n    /**\r\n     * @method removeUnused\r\n     * \r\n     * Remove unused DOMs defined in <defs>\r\n     */\n\n  }, {\n    key: \"removeUnused\",\n    value: function removeUnused() {\n      var defs = this.getDefs(false);\n\n      if (!defs) {\n        // Nothing to remove\n        return;\n      }\n\n      var doms = this.getDoms();\n      var that = this;\n      dataUtil.each(doms, function (dom) {\n        if (dom[that._markLabel] !== MARK_USED) {\n          // Remove gradient\n          defs.removeChild(dom);\n        }\n      });\n    }\n    /**\r\n     * @method getSvgProxy\r\n     * \r\n     * Get SVG proxy.\r\n     *\r\n     * @param {Displayable} displayable displayable element\r\n     * @return {Path|Image|Text} svg proxy of given element\r\n     */\n\n  }, {\n    key: \"getSvgProxy\",\n    value: function getSvgProxy(displayable) {\n      if (displayable instanceof Path) {\n        return svgPath;\n      } else if (displayable instanceof QImage) {\n        return svgImage;\n      } else if (displayable instanceof QText) {\n        return svgText;\n      } else {\n        return svgPath;\n      }\n    }\n    /**\r\n     * @method getTextSvgElement\r\n     * \r\n     * Get text SVG element.\r\n     *\r\n     * @param {Displayable} displayable displayable element\r\n     * @return {SVGElement} SVG element of text\r\n     */\n\n  }, {\n    key: \"getTextSvgElement\",\n    value: function getTextSvgElement(displayable) {\n      return displayable.__textSvgEl;\n    }\n    /**\r\n     * @method getSvgElement\r\n     * \r\n     * Get SVG element.\r\n     *\r\n     * @param {Displayable} displayable displayable element\r\n     * @return {SVGElement} SVG element\r\n     */\n\n  }, {\n    key: \"getSvgElement\",\n    value: function getSvgElement(displayable) {\n      return displayable.__svgEl;\n    }\n  }]);\n\n  return Definable;\n}();\n\nvar _default = Definable;\nmodule.exports = _default;","var Definable = require(\"./Definable\");\n\nvar dataUtil = require(\"../../core/utils/data_structure_util\");\n\nvar classUtil = require(\"../../core/utils/class_util\");\n\nvar matrix = require(\"../../core/utils/matrix\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.svg.helper.ClippathManager\r\n * \r\n * Manages SVG clipPath elements.\r\n * \r\n * @author Zhang Wenli\r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\nvar ClippathManager =\n/*#__PURE__*/\nfunction (_Definable) {\n  _inherits(ClippathManager, _Definable);\n\n  /**\r\n   * @method constructor ClippathManager\r\n   * @param   {Number}     qrId    qrenderer instance id\r\n   * @param   {SVGElement} svgRoot root of SVG document\r\n   */\n  function ClippathManager(qrId, svgRoot) {\n    _classCallCheck(this, ClippathManager);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ClippathManager).call(this, qrId, svgRoot, 'clipPath', '__clippath_in_use__'));\n  }\n  /**\r\n   * @method update\r\n   * Update clipPath.\r\n   *\r\n   * @param {Displayable} displayable displayable element\r\n   */\n\n\n  _createClass(ClippathManager, [{\n    key: \"update\",\n    value: function update(displayable) {\n      var svgEl = this.getSvgElement(displayable);\n\n      if (svgEl) {\n        this.updateDom(svgEl, displayable.__clipPaths, false);\n      }\n\n      var textEl = this.getTextSvgElement(displayable);\n\n      if (textEl) {\n        // Make another clipPath for text, since it's transform\n        // matrix is not the same with svgElement\n        this.updateDom(textEl, displayable.__clipPaths, true);\n      }\n\n      this.markUsed(displayable);\n    }\n    /**\r\n     * @method updateDom\r\n     * Create an SVGElement of displayable and create a <clipPath> of its\r\n     * clipPath\r\n     *\r\n     * @param {Displayable} parentEl  parent element\r\n     * @param {ClipPath[]}  clipPaths clipPaths of parent element\r\n     * @param {boolean}     isText    if parent element is Text\r\n     */\n\n  }, {\n    key: \"updateDom\",\n    value: function updateDom(parentEl, clipPaths, isText) {\n      if (clipPaths && clipPaths.length > 0) {\n        // Has clipPath, create <clipPath> with the first clipPath\n        var defs = this.getDefs(true);\n        var clipPath = clipPaths[0];\n        var clipPathEl;\n        var id;\n        var dom = isText ? '_textDom' : '_dom';\n\n        if (clipPath[dom]) {\n          // Use a dom that is already in <defs>\n          id = clipPath[dom].getAttribute('id');\n          clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n          if (!defs.contains(clipPathEl)) {\n            // This happens when set old clipPath that has\n            // been previously removed\n            defs.appendChild(clipPathEl);\n          }\n        } else {\n          // New <clipPath>\n          id = 'qr' + this._qrId + '-clip-' + this.nextId;\n          ++this.nextId;\n          clipPathEl = this.createElement('clipPath');\n          clipPathEl.setAttribute('id', id);\n          defs.appendChild(clipPathEl);\n          clipPath[dom] = clipPathEl;\n        } // Build path and add to <clipPath>\n\n\n        var svgProxy = this.getSvgProxy(clipPath);\n\n        if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n          /**\r\n           * If a clipPath has a parent with transform, the transform\r\n           * of parent should not be considered when setting transform\r\n           * of clipPath. So we need to transform back from parent's\r\n           * transform, which is done by multiplying parent's inverse\r\n           * transform.\r\n           */\n          // Store old transform\n          var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n          matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n          svgProxy.brush(clipPath); // Set back transform of clipPath\n\n          clipPath.transform = transform;\n        } else {\n          svgProxy.brush(clipPath);\n        }\n\n        var pathEl = this.getSvgElement(clipPath);\n        clipPathEl.innerHTML = '';\n        /**\r\n         * Use `cloneNode()` here to appendChild to multiple parents,\r\n         * which may happend when Text and other shapes are using the same\r\n         * clipPath. Since Text will create an extra clipPath DOM due to\r\n         * different transform rules.\r\n         */\n\n        clipPathEl.appendChild(pathEl.cloneNode());\n        parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n        if (clipPaths.length > 1) {\n          // Make the other clipPaths recursively\n          this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n        }\n      } else {\n        // No clipPath\n        if (parentEl) {\n          parentEl.setAttribute('clip-path', 'none');\n        }\n      }\n    }\n    /**\r\n     * @method markUsed\r\n     * \r\n     * Mark a single clipPath to be used\r\n     *\r\n     * @param {Displayable} displayable displayable element\r\n     */\n\n  }, {\n    key: \"markUsed\",\n    value: function markUsed(displayable) {\n      var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n      if (displayable.__clipPaths) {\n        dataUtil.each(displayable.__clipPaths, function (clipPath) {\n          if (clipPath._dom) {\n            Definable.prototype.markUsed.call(that, clipPath._dom);\n          }\n\n          if (clipPath._textDom) {\n            Definable.prototype.markUsed.call(that, clipPath._textDom);\n          }\n        });\n      }\n    }\n  }]);\n\n  return ClippathManager;\n}(Definable);\n\nvar _default = ClippathManager;\nmodule.exports = _default;","var Definable = require(\"./Definable\");\n\nvar classUtil = require(\"../../core/utils/class_util\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * @class qrenderer.svg.helper.ShadowManager\r\n * \r\n * Manages SVG shadow elements.\r\n * \r\n * @author Zhang Wenli\r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\nfunction hasShadow(style) {\n  // TODO: textBoxShadowBlur is not supported yet\n  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);\n}\n/**\r\n * @method constructor ShadowManager\r\n * \r\n * Manages SVG shadow elements.\r\n *\r\n * @param   {Number}     qrId    qrenderer instance id\r\n * @param   {SVGElement} svgRoot root of SVG document\r\n */\n\n\nvar ShadowManager =\n/*#__PURE__*/\nfunction (_Definable) {\n  _inherits(ShadowManager, _Definable);\n\n  function ShadowManager(qrId, svgRoot) {\n    _classCallCheck(this, ShadowManager);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ShadowManager).call(this, qrId, svgRoot, ['filter'], '__filter_in_use__', '_shadowDom'));\n  }\n  /**\r\n   * Create new shadow DOM for fill or stroke if not exist,\r\n   * but will not update shadow if exists.\r\n   *\r\n   * @param {SvgElement}  svgElement   SVG element to paint\r\n   * @param {Displayable} displayable  qrenderer displayable element\r\n   */\n\n\n  _createClass(ShadowManager, [{\n    key: \"addWithoutUpdate\",\n    value: function addWithoutUpdate(svgElement, displayable) {\n      if (displayable && hasShadow(displayable.style)) {\n        // Create dom in <defs> if not exists\n        var dom;\n\n        if (displayable._shadowDom) {\n          // Gradient exists\n          dom = displayable._shadowDom;\n          var defs = this.getDefs(true);\n\n          if (!defs.contains(displayable._shadowDom)) {\n            // _shadowDom is no longer in defs, recreate\n            this.addDom(dom);\n          }\n        } else {\n          // New dom\n          dom = this.add(displayable);\n        }\n\n        this.markUsed(displayable);\n        var id = dom.getAttribute('id');\n        svgElement.style.filter = 'url(#' + id + ')';\n      }\n    }\n    /**\r\n     * Add a new shadow tag in <defs>\r\n     *\r\n     * @param {Displayable} displayable  qrenderer displayable element\r\n     * @return {SVGFilterElement} created DOM\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(displayable) {\n      var dom = this.createElement('filter'); // Set dom id with shadow id, since each shadow instance\n      // will have no more than one dom element.\n      // id may exists before for those dirty elements, in which case\n      // id should remain the same, and other attributes should be\n      // updated.\n\n      displayable._shadowDomId = displayable._shadowDomId || this.nextId++;\n      dom.setAttribute('id', 'qr' + this._qrId + '-shadow-' + displayable._shadowDomId);\n      this.updateDom(displayable, dom);\n      this.addDom(dom);\n      return dom;\n    }\n    /**\r\n     * Update shadow.\r\n     *\r\n     * @param {Displayable} displayable  qrenderer displayable element\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(svgElement, displayable) {\n      var style = displayable.style;\n\n      if (hasShadow(style)) {\n        var that = this;\n        Definable.prototype.update.call(this, displayable, function () {\n          that.updateDom(displayable, displayable._shadowDom);\n        });\n      } else {\n        // Remove shadow\n        this.remove(svgElement, displayable);\n      }\n    }\n    /**\r\n     * Remove DOM and clear parent filter\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(svgElement, displayable) {\n      if (displayable._shadowDomId != null) {\n        this.removeDom(svgElement);\n        svgElement.style.filter = '';\n      }\n    }\n    /**\r\n     * Update shadow dom\r\n     *\r\n     * @param {Displayable} displayable  qrenderer displayable element\r\n     * @param {SVGFilterElement} dom DOM to update\r\n     */\n\n  }, {\n    key: \"updateDom\",\n    value: function updateDom(displayable, dom) {\n      var domChild = dom.getElementsByTagName('feDropShadow');\n\n      if (domChild.length === 0) {\n        domChild = this.createElement('feDropShadow');\n      } else {\n        domChild = domChild[0];\n      }\n\n      var style = displayable.style;\n      var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;\n      var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1; // TODO: textBoxShadowBlur is not supported yet\n\n      var offsetX;\n      var offsetY;\n      var blur;\n      var color;\n\n      if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {\n        offsetX = style.shadowOffsetX || 0;\n        offsetY = style.shadowOffsetY || 0;\n        blur = style.shadowBlur;\n        color = style.shadowColor;\n      } else if (style.textShadowBlur) {\n        offsetX = style.textShadowOffsetX || 0;\n        offsetY = style.textShadowOffsetY || 0;\n        blur = style.textShadowBlur;\n        color = style.textShadowColor;\n      } else {\n        // Remove shadow\n        this.removeDom(dom, style);\n        return;\n      }\n\n      domChild.setAttribute('dx', offsetX / scaleX);\n      domChild.setAttribute('dy', offsetY / scaleY);\n      domChild.setAttribute('flood-color', color); // Divide by two here so that it looks the same as in canvas\n      // See: https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-shadowblur\n\n      var stdDx = blur / 2 / scaleX;\n      var stdDy = blur / 2 / scaleY;\n      var stdDeviation = stdDx + ' ' + stdDy;\n      domChild.setAttribute('stdDeviation', stdDeviation); // Fix filter clipping problem\n\n      dom.setAttribute('x', '-100%');\n      dom.setAttribute('y', '-100%');\n      dom.setAttribute('width', Math.ceil(blur / 2 * 200) + '%');\n      dom.setAttribute('height', Math.ceil(blur / 2 * 200) + '%');\n      dom.appendChild(domChild); // Store dom element in shadow, to avoid creating multiple\n      // dom instances for the same shadow element\n\n      displayable._shadowDom = dom;\n    }\n    /**\r\n     * Mark a single shadow to be used\r\n     *\r\n     * @param {Displayable} displayable displayable element\r\n     */\n\n  }, {\n    key: \"markUsed\",\n    value: function markUsed(displayable) {\n      if (displayable._shadowDom) {\n        Definable.prototype.markUsed.call(this, displayable._shadowDom);\n      }\n    }\n  }]);\n\n  return ShadowManager;\n}(Definable);\n\nvar _default = ShadowManager;\nmodule.exports = _default;","require(\"./graphic\");\n\nvar _quarkRenderer = require(\"../quark-renderer\");\n\nvar registerPainter = _quarkRenderer.registerPainter;\n\nvar VMLPainter = require(\"./VMLPainter\");\n\nregisterPainter('vml', VMLPainter);","var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/utils/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../graphic/transform/BoundingRect\");\n\nvar colorTool = require(\"../core/utils/color_util\");\n\nvar textContain = require(\"../core/contain/text\");\n\nvar textUtil = require(\"../graphic/utils/text_util\");\n\nvar RectText = require(\"../graphic/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar QImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../graphic/PathProxy\");\n\nvar Gradient = require(\"../graphic/gradient/Gradient\");\n\nvar vmlCore = require(\"./core\");\n\nvar _constants = require(\"../graphic/constants\");\n\nvar mathRound = _constants.mathRound;\nvar mathSqrt = _constants.mathSqrt;\nvar mathAbs = _constants.mathAbs;\nvar mathCos = _constants.mathCos;\nvar mathSin = _constants.mathSin;\nvar mathMax = _constants.mathMax;\nvar mathAtan2 = _constants.mathAtan2;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO:Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function initRootElStyle(el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function encodeHtmlAttribute(s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function rgb2Str(r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function append(parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function remove(parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function getZIndex(zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = textUtil.parsePercent; //--------------PATH----------------------\n\n  var setColorAndOpacity = function setColorAndOpacity(el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function getColorAndAlpha(color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function updateFillNode(el, style, qrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = qrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = qrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = mathAtan2(dx, dy) * 180 / PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var _p = [fill.x * rectWidth, fill.y * rectHeight];\n          var _transform = qrEl.transform;\n          var scale = qrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (_p[0] - rect.x) / width, (_p[1] - rect.y) / height];\n\n          if (_transform) {\n            applyTransform(_p, _p, _transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function updateStrokeNode(el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function updateFillAndStroke(vmlEl, type, style, qrEl) {\n    var isFill = type === 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, qrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function pathDataToString(path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n    var x;\n    var y;\n    var x0;\n    var y0;\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var x3;\n    var y3;\n    var cx;\n    var cy;\n    var sx;\n    var sy;\n    var rx;\n    var ry;\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          x1 = data[i++];\n          y1 = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          x = 0;\n          y = 0;\n          sx = 1;\n          sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = mathAtan2(-m[1] / sy, m[0] / sx);\n          }\n\n          cx = data[i++];\n          cy = data[i++];\n          rx = data[i++];\n          ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // let psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          x0 = cx + mathCos(startAngle) * rx;\n          y0 = cy + mathSin(startAngle) * ry;\n          x1 = cx + mathCos(endAngle) * rx;\n          y1 = cy + mathSin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (mathAbs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (mathAbs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (mathAbs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, mathRound(((cx - rx) * sx + x) * Z - Z2), comma, mathRound(((cy - ry) * sy + y) * Z - Z2), comma, mathRound(((cx + rx) * sx + x) * Z - Z2), comma, mathRound(((cy + ry) * sy + y) * Z - Z2), comma, mathRound((x0 * sx + x) * Z - Z2), comma, mathRound((y0 * sy + y) * Z - Z2), comma, mathRound((x1 * sx + x) * Z - Z2), comma, mathRound((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = mathRound(p0[0] * Z - Z2);\n          p1[0] = mathRound(p1[0] * Z - Z2);\n          p0[1] = mathRound(p0[1] * Z - Z2);\n          p1[1] = mathRound(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 mathRound 会非常慢\n\n          str.push(mathRound(p[0] * Z - Z2), comma, mathRound(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  };\n  /**\r\n   * @class qrenderer.vml.Path\r\n   * \r\n   * Append brushVML method to standard shape classes inside graphic package, VMLPainter will\r\n   * use this method instead of standard brush() method.\r\n   * \r\n   * 在标准的 shape 类上扩展一个 brushVML 方法，在 VMLPainter 中会调用此方法，而不是标准的 brush 方法。\r\n   * \r\n   * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n   */\n  // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= mathSqrt(mathAbs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      path.subPixelOptimize = false;\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  }; //--------------IMAGE----------------------\n\n\n  var isImage = function isImage(img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return _typeof(img) === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  };\n  /**\r\n   * @class qrenderer.vml.QImage\r\n   * \r\n   * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n   */\n  // Rewrite the original path method\n\n\n  QImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', mathRound(x * scaleX + m[4]), comma, 'Dy=', mathRound(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + mathRound(maxX) + 'px ' + mathRound(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = mathRound(x) + 'px';\n      vmlElStyle.top = mathRound(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = mathRound(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = mathRound(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = mathRound(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = mathRound(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = mathRound((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = mathRound((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode !== cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = mathRound(scaleX * dw) + 'px';\n      imageELStyle.height = mathRound(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + mathRound(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  QImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  QImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  }; //--------------TEXT----------------------\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function getFontStyle(fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function drawRectText(vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textUtil.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // let fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (mathRound(coords[0]) || 0) + ',' + (mathRound(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = mathRound(x) + 'px';\n      textVmlElStyle.top = mathRound(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash || null // style.lineDash can be `false`.\n\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function removeRectText(vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function appendRectText(vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, QImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n  /**\r\n   * @class qrenderer.vml.Text\r\n   * \r\n   * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n   */\n\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}","var env = require(\"../core/env\");\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\nvar vmlInited = false;\nvar doc = win && win.document; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar doCreateNode;\n\nif (doc && !env.canvasSupported) {\n  try {\n    !doc.namespaces.qrvml && doc.namespaces.add('qrvml', urn);\n\n    doCreateNode = function doCreateNode(tagName) {\n      return doc.createElement('<qrvml:' + tagName + ' class=\"qrvml\">');\n    };\n  } catch (e) {\n    doCreateNode = function doCreateNode(tagName) {\n      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"qrvml\">');\n    };\n  }\n} // From raphael\n\n\nfunction initVML() {\n  if (vmlInited || !doc) {\n    return;\n  }\n\n  vmlInited = true;\n  var styleSheets = doc.styleSheets;\n\n  if (styleSheets.length < 31) {\n    doc.createStyleSheet().addRule('.qrvml', 'behavior:url(#default#VML)');\n  } else {\n    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n    styleSheets[0].addRule('.qrvml', 'behavior:url(#default#VML)');\n  }\n}\n\nfunction createNode(tagName) {\n  return doCreateNode(tagName);\n}\n\nexports.doc = doc;\nexports.initVML = initVML;\nexports.createNode = createNode;","var vmlCore = require(\"./core\");\n\nvar dataUtil = require(\"../core/utils/data_structure_util\");\n\n/**\r\n * @class qrenderer.svg.VMLPainter\r\n * \r\n * VMLPainter.\r\n * \r\n * @docauthor 大漠穷秋 damoqiongqiu@126.com\r\n */\n\n/**\r\n * @method constructor VMLPainter\r\n * @param {*} root \r\n * @param {*} storage \r\n */\nfunction VMLPainter(root, storage) {\n  vmlCore.initVML();\n  this.root = root;\n  this.storage = storage;\n  var vmlViewport = document.createElement('div');\n  var vmlRoot = document.createElement('div');\n  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n  root.appendChild(vmlViewport);\n  this._vmlRoot = vmlRoot;\n  this._vmlViewport = vmlViewport;\n  this.resize(); // Modify storage\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n\n    if (el) {\n      el.onRemove && el.onRemove(vmlRoot);\n    }\n  };\n\n  storage.addToStorage = function (el) {\n    // Displayable already has a vml node\n    el.onAdd && el.onAdd(vmlRoot);\n    oldAddToStorage.call(storage, el);\n  };\n\n  this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n  constructor: VMLPainter,\n\n  /**\r\n   * @method getType\r\n   */\n  getType: function getType() {\n    return 'vml';\n  },\n\n  /**\r\n   * @method getViewportRoot\r\n   * @return {HTMLDivElement}\r\n   */\n  getViewportRoot: function getViewportRoot() {\n    return this._vmlViewport;\n  },\n\n  /**\r\n   * @method getViewportRootOffset\r\n   */\n  getViewportRootOffset: function getViewportRootOffset() {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\r\n   * @method refresh 刷新\r\n   */\n  refresh: function refresh() {\n    var list = this.storage.getDisplayList(true, true);\n\n    this._paintList(list);\n  },\n\n  /**\r\n   * @private\r\n   * @method _paintList\r\n   * @param {*} list \r\n   */\n  _paintList: function _paintList(list) {\n    var vmlRoot = this._vmlRoot;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n\n      if (el.invisible || el.ignore) {\n        if (!el.__alreadyNotVisible) {\n          el.onRemove(vmlRoot);\n        } // Set as already invisible\n\n\n        el.__alreadyNotVisible = true;\n      } else {\n        if (el.__alreadyNotVisible) {\n          el.onAdd(vmlRoot);\n        }\n\n        el.__alreadyNotVisible = false;\n\n        if (el.__dirty) {\n          el.beforeBrush && el.beforeBrush();\n          (el.brushVML || el.brush).call(el, vmlRoot);\n          el.afterBrush && el.afterBrush();\n        }\n      }\n\n      el.__dirty = false;\n    }\n\n    if (this._firstPaint) {\n      // Detached from document at first time\n      // to avoid page refreshing too many times\n      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n      this._vmlViewport.appendChild(vmlRoot);\n\n      this._firstPaint = false;\n    }\n  },\n\n  /**\r\n   * @method resize\r\n   * @param {Number} width \r\n   * @param {Number} height \r\n   */\n  resize: function resize(width, height) {\n    width = width == null ? this._getWidth() : width;\n    height = height == null ? this._getHeight() : height;\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      var vmlViewportStyle = this._vmlViewport.style;\n      vmlViewportStyle.width = width + 'px';\n      vmlViewportStyle.height = height + 'px';\n    }\n  },\n\n  /**\r\n   * @method dispose\r\n   */\n  dispose: function dispose() {\n    this.root.innerHTML = '';\n    this._vmlRoot = this._vmlViewport = this.storage = null;\n  },\n\n  /**\r\n   * @method getWidth\r\n   */\n  getWidth: function getWidth() {\n    return this._width;\n  },\n\n  /**\r\n   * @method getHeight\r\n   */\n  getHeight: function getHeight() {\n    return this._height;\n  },\n\n  /**\r\n   * @method clear\r\n   */\n  clear: function clear() {\n    if (this._vmlViewport) {\n      this.root.removeChild(this._vmlViewport);\n    }\n  },\n\n  /**\r\n   * @private\r\n   * @method _getWidth\r\n   */\n  _getWidth: function _getWidth() {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientWidth || dataUtil.parseInt10(stl.width)) - dataUtil.parseInt10(stl.paddingLeft) - dataUtil.parseInt10(stl.paddingRight) | 0;\n  },\n\n  /**\r\n   * @private\r\n   * @method _getHeight\r\n   */\n  _getHeight: function _getHeight() {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientHeight || dataUtil.parseInt10(stl.height)) - dataUtil.parseInt10(stl.paddingTop) - dataUtil.parseInt10(stl.paddingBottom) | 0;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    console.log('In IE8.0 VML mode painter not support method \"' + method + '\"');\n  };\n} // Unsupported methods\n\n\n['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'].forEach(function (name, index) {\n  VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = VMLPainter;\nmodule.exports = _default;"]}